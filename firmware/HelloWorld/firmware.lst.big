
build/application/firmware.elf:     file format elf32-littlearm
build/application/firmware.elf
architecture: arm, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00011e41

Program Header:
0x70000001 off    0x00016298 vaddr 0x00016298 paddr 0x00016298 align 2**2
         filesz 0x00000458 memsz 0x00000458 flags r--
    LOAD off    0x00010000 vaddr 0x00010000 paddr 0x00010000 align 2**16
         filesz 0x000066f0 memsz 0x000066f0 flags r-x
    LOAD off    0x00020000 vaddr 0x10000000 paddr 0x000166f0 align 2**16
         filesz 0x000001f0 memsz 0x000001f0 flags rw-
    LOAD off    0x000201f0 vaddr 0x100001f0 paddr 0x100001f0 align 2**16
         filesz 0x00000000 memsz 0x000001c0 flags rw-
private flags = 5000400: [Version5 EABI] [hard-float ABI]

Sections:
Idx Name             Size      VMA       LMA       File off  Algn  Flags
  0 .text            00005dac  00010000  00010000  00010000  2**4  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data            000001f0  10000000  000166f0  00020000  2**2  CONTENTS, ALLOC, LOAD, DATA
  2 .data_RAM2       00000000  20000000  20000000  000201f0  2**2  CONTENTS
  3 .bss             000001c0  100001f0  100001f0  000201f0  2**3  ALLOC
  4 .ARM.extab       000004ec  00015dac  00015dac  00015dac  2**2  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .ARM.exidx       00000458  00016298  00016298  00016298  2**2  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .uninit_RESERVED 00000000  10000000  10000000  000201f0  2**2  CONTENTS
  7 .noinit_RAM2     00000000  20000000  20000000  000201f0  2**2  CONTENTS
  8 .noinit          00000000  100003b0  100003b0  000201f0  2**2  CONTENTS
  9 .ARM.attributes  00000030  00000000  00000000  000201f0  2**0  CONTENTS, READONLY
 10 .comment         0000007e  00000000  00000000  00020220  2**0  CONTENTS, READONLY
 11 .debug_info      00035c2f  00000000  00000000  0002029e  2**0  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev    00003a2e  00000000  00000000  00055ecd  2**0  CONTENTS, READONLY, DEBUGGING
 13 .debug_aranges   00000950  00000000  00000000  000598fb  2**0  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges    000008e0  00000000  00000000  0005a24b  2**0  CONTENTS, READONLY, DEBUGGING
 15 .debug_line      000057c1  00000000  00000000  0005ab2b  2**0  CONTENTS, READONLY, DEBUGGING
 16 .debug_str       000203f1  00000000  00000000  000602ec  2**0  CONTENTS, READONLY, DEBUGGING
 17 .debug_frame     00003160  00000000  00000000  000806e0  2**2  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
00010000 l    d  .text	00000000 .text
10000000 l    d  .data	00000000 .data
20000000 l    d  .data_RAM2	00000000 .data_RAM2
100001f0 l    d  .bss	00000000 .bss
00015dac l    d  .ARM.extab	00000000 .ARM.extab
00016298 l    d  .ARM.exidx	00000000 .ARM.exidx
10000000 l    d  .uninit_RESERVED	00000000 .uninit_RESERVED
20000000 l    d  .noinit_RAM2	00000000 .noinit_RAM2
100003b0 l    d  .noinit	00000000 .noinit
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 interrupt.cpp
00011ecc l     F .text	00000034 NVIC_EnableIRQ
00011f00 l     F .text	0000005c NVIC_SetPriority
00010000 l     O .text	000000e4 kInterruptVectorTable
00015cf4 l     O .text	0000000e InterruptLookupHandler::file
00015d04 l     O .text	0000001e InterruptLookupHandler::__PRETTY_FUNCTION__
00010254 l       .text	00000000 handler2_address_const
00000000 l    df *ABS*	00000000 startup.cpp
00015840 l     O .text	00000057 sjsu::lpc40xx::SystemController::SetPeripheralClockDivider(unsigned char) const::__PRETTY_FUNCTION__
00015908 l     O .text	00000072 sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const::__PRETTY_FUNCTION__
00015898 l     O .text	00000070 sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const::__PRETTY_FUNCTION__
0001597c l     O .text	00000048 sjsu::lpc40xx::SystemController::SetCpuClockDivider(unsigned char) const::__PRETTY_FUNCTION__
000159c4 l     O .text	0000005b sjsu::lpc40xx::Timer::Initialize(unsigned long, void (*)(), long) const::__PRETTY_FUNCTION__
00015a20 l     O .text	00000065 sjsu::lpc40xx::Timer::SetTimer(unsigned long, sjsu::Timer::TimerIsrCondition, unsigned char) const::__PRETTY_FUNCTION__
1000009c l     O .data	00000004 (anonymous namespace)::system_controller
10000324 l     O .bss	0000000c (anonymous namespace)::timer0
00011d8c l     F .text	0000001c (anonymous namespace)::Lpc40xxUptime()
000102fc l     O .text	00000004 kCrpWord
00011e84 l     F .text	00000038 __static_initialization_and_destruction_0(int, int)
00011ebc l     F .text	00000010 _GLOBAL__sub_I_UptimeRTOS
00000000 l    df *ABS*	00000000 /home/kammce/Documents/SJSU-Dev2/tools/gcc-arm-none-eabi-7-2017-q4-major/bin/../lib/gcc/arm-none-eabi/7.2.1/thumb/v7e-m/fpv4-sp/hard/crti.o
00000000 l    df *ABS*	00000000 /home/kammce/Documents/SJSU-Dev2/tools/gcc-arm-none-eabi-7-2017-q4-major/bin/../lib/gcc/arm-none-eabi/7.2.1/thumb/v7e-m/fpv4-sp/hard/crtn.o
00000000 l    df *ABS*	00000000 crtstuff.c
00010324 l     F .text	00000000 __do_global_dtors_aux
100001f0 l       .bss	00000001 completed.9929
00010348 l     F .text	00000000 frame_dummy
100001f4 l       .bss	00000018 object.9934
0001030c l     O .text	00000000 __frame_dummy_init_array_entry
00000000 l    df *ABS*	00000000 main.cpp
00010580 l     F .text	00000026 _Unwind_GetGR
000105f4 l     F .text	00000048 sjsu::debug::PrintAddressAsList(_Unwind_Context*, void*)
0001063c l     F .text	00000044 sjsu::debug::PrintAddressInRow(_Unwind_Context*, void*)
10000210 l     O .bss	00000008 sjsu::(anonymous namespace)::uptime
00010724 l     F .text	00000018 sjsu::(anonymous namespace)::DefaultUptime()
00014e10 l     O .text	00000031 sjsu::lpc40xx::Gpio::ValidPortCheck() const::__PRETTY_FUNCTION__
00014e44 l     O .text	00000043 sjsu::lpc40xx::Gpio::SetInterruptEdge(sjsu::Gpio::Edge) const::__PRETTY_FUNCTION__
00014ecc l     O .text	00000023 sjsu::OnBoardLed::On(unsigned char)::__PRETTY_FUNCTION__
00014ef0 l     O .text	00000024 sjsu::OnBoardLed::Off(unsigned char)::__PRETTY_FUNCTION__
00014e88 l     O .text	00000042 sjsu::OnBoardLed::Set(unsigned char, sjsu::OnBoardLed::LightState)::__PRETTY_FUNCTION__
00014d94 l     O .text	00000009 main::file
00014da0 l     O .text	00000009 main::file
00014dac l     O .text	00000009 main::file
00014db8 l     O .text	00000009 main::file
00014e04 l     O .text	0000000b main::__PRETTY_FUNCTION__
000110f0 l     F .text	00000044 __static_initialization_and_destruction_0(int, int)
00011134 l     F .text	00000010 _GLOBAL__sub_I_main
00000000 l    df *ABS*	00000000 newlib.cpp
00000000 l    df *ABS*	00000000 tasks.c
10000334 l     O .bss	00000064 pxReadyTasksLists
10000398 l     O .bss	00000004 uxTopReadyPriority
1000039c l     O .bss	00000004 xYieldPending
100003a0 l     O .bss	00000004 uxSchedulerSuspended
100003a4 l     O .bss	00000004 ulTaskSwitchedInTime
100003a8 l     O .bss	00000004 ulTotalRunTime
00000000 l    df *ABS*	00000000 port.c
00012250 l       .text	00000000 pxCurrentTCBConst2
000122c0 l       .text	00000000 pxCurrentTCBConst
00000000 l    df *ABS*	00000000 printf.cpp
000122c8 l     F .text	0000001c _out_null(char, void*, unsigned int, unsigned int)
000122e4 l     F .text	00000026 _out_char(char, void*, unsigned int, unsigned int)
0001230a l     F .text	0000002e _strlen(char const*)
00012338 l     F .text	00000028 _is_digit(char)
00012360 l     F .text	00000048 _atoi(char const**)
000123a8 l     F .text	00000242 _ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)
000125ea l     F .text	000000d0 _ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)
000126ba l     F .text	000000e0 _ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)
00015d24 l     O .text	00000028 _ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)::pow10
0001279c l     F .text	00000442 _ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)
00012be0 l     F .text	000008d4 _vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)
00000000 l    df *ABS*	00000000 pure.cc
00000000 l    df *ABS*	00000000 eh_terminate.cc
00000000 l    df *ABS*	00000000 _arm_truncdfsf2.o
00000000 l    df *ABS*	00000000 _aeabi_uldivmod.o
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 unwind-arm.c
000138b4 l     F .text	00000012 selfrel_offset31
000138c8 l     F .text	00000060 search_EIT_table
00013928 l     F .text	00000028 __gnu_unwind_get_pr_addr
00013950 l     F .text	000000a4 get_eit_entry
000139f4 l     F .text	00000058 restore_non_core_regs
00013a4c l     F .text	0000000a _Unwind_decode_typeinfo_ptr.isra.0
00013a58 l     F .text	00000004 __gnu_unwind_24bit.isra.1
00013a5c l     F .text	00000002 _Unwind_DebugHook
00013a60 l     F .text	0000003e unwind_phase2
00013aa0 l     F .text	000000c6 unwind_phase2_forced
00013c70 l     F .text	00000018 _Unwind_GetGR
00013cb4 l     F .text	0000001a _Unwind_SetGR
00013d40 l     F .text	000002d4 __gnu_unwind_pr_common
00000000 l    df *ABS*	00000000 libunwind.o
00000000 l    df *ABS*	00000000 pr-support.c
0001444c l     F .text	00000038 next_unwind_byte
00014484 l     F .text	0000001a _Unwind_GetGR.constprop.0
000144a0 l     F .text	00000002 unwind_UCB_from_context
00000000 l    df *ABS*	00000000 _dvmd_tls.o
00000000 l    df *ABS*	00000000 abort.c
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 memcpy-stub.c
00000000 l    df *ABS*	00000000 signal.c
00000000 l    df *ABS*	00000000 signalr.c
00000000 l    df *ABS*	00000000 findfp.c
00000000 l    df *ABS*	00000000 eh_term_handler.cc
00000000 l    df *ABS*	00000000 impure.c
10000190 l     O .data	00000060 impure_data
00000000 l    df *ABS*	00000000 reent.c
00014404 g     F .text	00000022 .hidden ___Unwind_ForcedUnwind
00013b6c g     F .text	0000005e .hidden __gnu_Unwind_RaiseException
00011f5c  w    F .text	00000068 Pwm0IrqHandler
0001023c g     F .text	00000026 HardFaultHandler
000120c8 g     F .text	00000010 _getpid
000120f4 g     F .text	00000020 _putchar
00010364  w    F .text	00000018 unsigned char sjsu::util::Value<sjsu::lpc40xx::Pin::PinBitMap, unsigned char>(sjsu::lpc40xx::Pin::PinBitMap)
00011f5c  w    F .text	00000068 EepromIrqHandler
00011f5c  w    F .text	00000068 Timer2IrqHandler
00015688  w    O .text	00000016 sjsu::lpc40xx::SystemController::SetCpuClockDivider(unsigned char) const::file
00011bce  w    F .text	0000002e sjsu::lpc40xx::Uart::Send(unsigned char) const::{lambda()#1}::operator()() const
0001099c  w    F .text	00000044 sjsu::lpc40xx::Gpio::Toggle() const
00014894 g     F .text	00000024 _kill_r
0001010c g       .text	00000000 bss_section_table_end
000134b4 g     F .text	00000038 printf
00011f5c  w    F .text	00000068 I2c1IrqHandler
0001123c  w    F .text	00000020 sjsu::lpc40xx::SystemController::GetPeripheralClockDivider() const
00010000 g       *ABS*	00000000 __vectors_start__
00011ca4  w    F .text	0000002e sjsu::lpc40xx::Uart::Receive(unsigned long) const::{lambda()#1}::operator()() const
00010ec8  w    F .text	00000050 sjsu::OnBoardLed::SetAll(unsigned char)
00011f5c  w    F .text	00000068 BusFaultHandler
000156a0  w    O .text	00000010 sjsu::lpc40xx::Timer::Channel::kTimerPartial0
00010680  w    F .text	000000a4 sjsu::debug::PrintBacktrace(bool, void*)
20000000 g       *ABS*	00000000 __base_RAM2
000142c0 g     F .text	00000000 .hidden __gnu_Unwind_Save_VFP
000143e0 g     F .text	00000022 .hidden _Unwind_Resume_or_Rethrow
10000090  w    O .data	0000000c sjsu::lpc40xx::uart0
000166f0 g       .ARM.exidx	00000000 __exidx_end
000110b8  w    F .text	0000001a sjsu::I2cDevice<&sjsu::Apds9960::i2c, (unsigned char)57, (sjsu::device::Endian)0, sjsu::Apds9960Interface::MemoryMap_t>::I2cDevice()
00014014 g     F .text	00000004 .hidden __aeabi_unwind_cpp_pr0
000109e0  w    F .text	00000018 sjsu::lpc40xx::Gpio::ReadState() const
000157dc  w    O .text	00000014 vtable for sjsu::Timer
000112e8  w    F .text	0000003c sjsu::lpc40xx::SystemController::PowerUpPeripheral(sjsu::SystemController::PeripheralID const&) const
10000330 g     O .bss	00000004 pxCurrentTCB
00014790 g     F .text	0000000a .hidden _Unwind_GetRegionStart
000143e0 g     F .text	00000022 .hidden ___Unwind_Resume_or_Rethrow
00010bfc  w    F .text	0000005c sjsu::lpc40xx::Gpio::SetEdgeRising() const
100003ac g     O .bss	00000004 errno
000166f0 g       .ARM.exidx	00000000 _etext
00010504  w    F .text	0000007c sjsu::lpc40xx::Pin::SetAsOpenDrain(bool) const
000110d2  w    F .text	0000001c sjsu::Device<sjsu::I2cDevice<&sjsu::Apds9960::i2c, (unsigned char)57, (sjsu::device::Endian)0, sjsu::Apds9960Interface::MemoryMap_t>, (sjsu::device::Endian)0, sjsu::Apds9960Interface::MemoryMap_t>::Device()
000113cc  w    F .text	00000034 sjsu::lpc40xx::SystemController::SelectUsbClockSource(sjsu::lpc40xx::SystemController::UsbSource) const
00014428 g     F .text	00000022 .hidden _Unwind_Backtrace
10000000  w    O .data	00000004 sjsu::lpc40xx::Pin::pin_map
00011f5c  w    F .text	00000068 LcdIrqHandler
00080000 g       *ABS*	00000000 __top_MFlash512
000142a0 g     F .text	00000018 .hidden __restore_core_regs
000142e0 g     F .text	00000000 .hidden __gnu_Unwind_Save_VFP_D_16_to_31
0001105e  w    F .text	0000005a unsigned long sjsu::bit::Insert<unsigned long, bool>(unsigned long, bool, unsigned long, unsigned long)
00011f5c  w    F .text	00000068 I2c2IrqHandler
00015760  w    O .text	00000040 vtable for sjsu::lpc40xx::Uart
00011f5c  w    F .text	00000068 CanIrqHandler
000116e4  w    F .text	00000034 sjsu::lpc40xx::SystemController::SetEmcClockDivider(sjsu::lpc40xx::SystemController::EmcDivider) const
00013b68 g     F .text	00000004 .hidden _Unwind_GetCFA
0001481c g     F .text	00000016 memcpy
00013c88 g     F .text	0000002a .hidden _Unwind_VRS_Set
000135b8 g     F .text	00000000 .hidden __aeabi_uldivmod
100003b0 g       .noinit	00000000 _noinit
00012114 g     F .text	00000048 puts
100000a0 g     O .data	000000e4 dynamic_isr_vector_table
00010e5c  w    F .text	0000006c sjsu::OnBoardLed::Set(unsigned char, sjsu::OnBoardLed::LightState)
00011f5c  w    F .text	00000068 RitIrqHandler
00011f5c  w    F .text	00000068 Uart2IrqHandler
00014832 g     F .text	00000050 _raise_r
1000031c  w    O .bss	00000004 guard variable for sjsu::Apds9960::gesture
10010000 g       *ABS*	00000000 __top_RAM
00012260 g     F .text	00000066 xPortPendSVHandler
00011164  w    F .text	00000084 sjsu::lpc40xx::SystemController::SetClockFrequency(unsigned char) const
10000000 g       *ABS*	00000000 __base_RamLoc64
10000184 g     O .data	00000004 out
00010480  w    F .text	00000084 sjsu::lpc40xx::Pin::SetAsAnalogMode(bool) const
000148b8 g     F .text	00000004 _getpid_r
00000000 g       *ABS*	00000000 __base_MFlash512
00013cd0 g     F .text	00000070 .hidden __gnu_Unwind_Backtrace
00011144  w    F .text	00000020 sjsu::SetUptimeFunction(unsigned long long (*)())
10010000 g       *ABS*	00000000 StackTop
000135e8 g     F .text	000002cc .hidden __udivmoddi4
00011f5c  w    F .text	00000068 I2sIrqHandler
000100fc g       .text	00000000 bss_section_table
000142d0 g     F .text	00000000 .hidden __gnu_Unwind_Save_VFP_D
00010300 g       .text	00000000 __CRP_WORD_END__
20008000 g       *ABS*	00000000 __top_RAM2
00011e40 g     F .text	00000030 ResetIsr
00014020 g     F .text	0000027e .hidden _Unwind_VRS_Pop
00011f5c  w    F .text	00000068 PendSVHandler
0001401c  w    F .text	00000004 .hidden __aeabi_unwind_cpp_pr2
00014428 g     F .text	00000022 .hidden ___Unwind_Backtrace
00011f5c  w    F .text	00000068 UsageFaultHandler
00011434  w    F .text	000000e8 sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const
20000000 g       *ABS*	00000000 __user_heap_base
00016298 g       .ARM.extab	00000000 __exidx_start
00011f5c  w    F .text	00000068 Uart4IrqHandler
00015818  w    O .text	00000028 vtable for sjsu::SystemController
000147d4 g     F .text	00000048 __libc_init_array
00011f5c g     F .text	00000068 InterruptLookupHandler
00014398 g     F .text	00000022 .hidden ___Unwind_RaiseException
000147c4 g     F .text	0000000e abort
000143bc g     F .text	00000022 .hidden ___Unwind_Resume
00011f5c  w    F .text	00000068 BodIrqHandler
0001073c  w    F .text	00000024 sjsu::Milliseconds()
00014d58  w    O .text	00000009 sjsu::lpc40xx::Gpio::SetInterruptEdge(sjsu::Gpio::Edge) const::file
000156c4  w    O .text	0000000a sjsu::lpc40xx::Timer::SetTimer(unsigned long, sjsu::Timer::TimerIsrCondition, unsigned char) const::file
00010300 g     F .text	00000000 _init
0001010c g       .text	00000000 section_table_end
00010c58  w    F .text	0000005c sjsu::lpc40xx::Gpio::SetEdgeFalling() const
0001350c g     F .text	0000000a std::terminate()
00013518 g     F .text	0000009e .hidden __aeabi_d2f
000142e8 g     F .text	00000000 .hidden __gnu_Unwind_Restore_WMMXD
000119b0  w    F .text	00000164 sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const
00011f5c  w    F .text	00000068 SysTickHandler
000100e4 g       .text	00000000 section_table_start
00010bd2  w    F .text	00000028 sjsu::lpc40xx::Gpio::DetachInterrupt() const
10000008  w    O .data	00000018 sjsu::lpc40xx::Gpio::gpio_port
100003b0 g       .bss	00000000 _ebss
00010e04  w    F .text	00000058 sjsu::OnBoardLed::Off(unsigned char)
00010880  w    F .text	0000004c sjsu::lpc40xx::Gpio::SetAsOutput() const
000157f0  w    O .text	00000028 vtable for sjsu::lpc40xx::SystemController
00010214 g     F .text	00000022 InitializeFloatingPointUnit()
00011f5c  w    F .text	00000068 RtcIrqHandler
0001125c  w    F .text	0000001c sjsu::lpc40xx::SystemController::GetSystemFrequency() const
0001174c  w    F .text	00000020 sjsu::Timer::Timer()
eff8620e g       *ABS*	00000000 ValidUserCodeChecksum
00015744  w    O .text	00000008 sjsu::lpc40xx::Uart::Port::kUart0Rx
00011f5c  w    F .text	00000068 Uart0IrqHandler
0001201c g     F .text	0000007c GetRegistersFromStack
000156b0  w    O .text	00000008 sjsu::lpc40xx::Timer::Channel::kTimer0
00011f5c  w    F .text	00000068 UsbIrqHandler
00011f5c  w    F .text	00000068 AdcIrqHandler
000142b8 g     F .text	00000000 .hidden __gnu_Unwind_Restore_VFP
00015d4c g     O .text	00000020 __sf_fake_stderr
000134fc g     F .text	00000010 std::get_terminate()
000143bc g     F .text	00000022 .hidden _Unwind_Resume
00013c38 g     F .text	0000000c .hidden _Unwind_DeleteException
00011f5c  w    F .text	00000068 EnetIrqHandler
10000218  w    O .bss	00000100 sjsu::lpc40xx::Gpio::interrupthandlers
00013c34 g     F .text	00000002 .hidden _Unwind_Complete
00011398  w    F .text	00000034 sjsu::lpc40xx::SystemController::SelectMainClockSource(sjsu::lpc40xx::SystemController::MainClockSource) const
00011f5c  w    F .text	00000068 DmaIrqHandler
00011fc4 g     F .text	00000058 RegisterIsr(IRQn, void (*)(), bool, long)
00000000 g       *ABS*	00000000 __base_Flash
00011f5c  w    F .text	00000068 Eint1IrqHandler
00011f5c  w    F .text	00000068 SvcHandler
00011f5c  w    F .text	00000068 GpioIrqHandler
00011f5c  w    F .text	00000068 SdioIrqHandler
10010000 g       *ABS*	00000000 __top_RamLoc64
100001f0 g       .bss	00000000 _bss
00011f5c  w    F .text	00000068 Pll1IrqHandler
00011f5c  w    F .text	00000068 MemManageHandler
00011718  w    F .text	00000032 sjsu::lpc40xx::Timer::TimerHandler(sjsu::lpc40xx::Timer::ChannelPartial_t const&)
000134ec g     F .text	00000006 __cxa_pure_virtual
00010aac  w    F .text	0000003c sjsu::lpc40xx::Gpio::SetInterruptRoutine(void (*)()) const
00010834  w    F .text	0000004c sjsu::lpc40xx::Gpio::SetAsInput() const
00011f5c  w    F .text	00000068 Pwm1IrqHandler
10000088  w    O .data	00000004 sjsu::lpc40xx::SystemController::system_controller
000144a4 g     F .text	000002c4 .hidden __gnu_unwind_execute
00011f5c  w    F .text	00000068 Timer0IrqHandler
000142c8 g     F .text	00000000 .hidden __gnu_Unwind_Restore_VFP_D
00080000 g       *ABS*	00000000 __top_Flash
00010786  w    F .text	00000094 sjsu::Wait(unsigned long long)
00010fac  w    F .text	0000005a unsigned long sjsu::bit::Insert<unsigned long, unsigned char>(unsigned long, unsigned char, unsigned long, unsigned long)
100003b0 g       .noinit	00000000 _end_noinit
0001215c g     F .text	000000c8 vTaskSwitchContext
000157a0  w    O .text	0000003c vtable for sjsu::lpc40xx::Timer
00013be0 g     F .text	00000044 .hidden __gnu_Unwind_Resume
10000020  w    O .data	00000028 sjsu::lpc40xx::Gpio::interrupt
00015628  w    O .text	00000016 sjsu::lpc40xx::SystemController::SetPeripheralClockDivider(unsigned char) const::file
0001176c  w    F .text	00000020 sjsu::SystemController::SystemController()
00011e70  w    F .text	00000014 void sjsu::lpc40xx::Timer::TimerHandler<sjsu::lpc40xx::Timer::Channel::kTimerPartial0>()
00011f5c  w    F .text	00000068 Uart3IrqHandler
20000000 g       *ABS*	00000000 __base_RamPeriph32
000142d8 g     F .text	00000000 .hidden __gnu_Unwind_Restore_VFP_D_16_to_31
00011e24 g     F .text	0000001c SystemInitialize()
00014398 g     F .text	00000022 .hidden _Unwind_RaiseException
000147c0  w    F .text	00000002 .hidden __aeabi_ldiv0
00011f5c  w    F .text	00000068 Timer1IrqHandler
00011bfc  w    F .text	000000a8 sjsu::lpc40xx::Uart::Send(unsigned char) const
000100e4 g       .text	00000000 data_section_table
00010cb4  w    F .text	0000005c sjsu::lpc40xx::Gpio::ClearEdgeRising() const
00015670  w    O .text	00000016 sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const::file
00015d6c g     O .text	00000020 __sf_fake_stdin
000102fc g       .text	00000000 __CRP_WORD_START__
00011278  w    F .text	00000034 sjsu::lpc40xx::SystemController::GetPeripheralFrequency() const
00011cd2  w    F .text	000000ba sjsu::lpc40xx::Uart::Receive(unsigned long) const
00011680  w    F .text	00000064 sjsu::lpc40xx::SystemController::SetCpuClockDivider(unsigned char) const
00011f5c  w    F .text	00000068 Uart1IrqHandler
00010b20  w    F .text	00000018 unsigned char sjsu::util::Value<sjsu::Gpio::Edge, unsigned char>(sjsu::Gpio::Edge)
00010f18 g     F .text	00000094 main
00010d6c  w    F .text	0000003e sjsu::OnBoardLed::Initialize()
00011f5c  w    F .text	00000068 QeiIrqHandler
20000000 g       *ABS*	00000000 heap
00011f5c  w    F .text	00000068 Ssp2IrqHandler
0001574c  w    O .text	00000014 sjsu::lpc40xx::Uart::Port::kUart0
00014dec  w    O .text	00000018 vtable for sjsu::lpc40xx::Pin
00013518 g     F .text	0000009e .hidden __truncdfsf2
00010318 g       .text	00000000 __init_array_end
00012230 g     F .text	00000026 vPortSVCHandler
00012098 g     F .text	00000024 FirmwareStdOut(int)
00011f5c  w    F .text	00000068 Ssp1IrqHandler
00014d84  w    O .text	00000010 sjsu::OnBoardLed::Set(unsigned char, sjsu::OnBoardLed::LightState)::file
000111e8  w    F .text	00000054 sjsu::lpc40xx::SystemController::SetPeripheralClockDivider(unsigned char) const
000118dc  w    F .text	000000b4 sjsu::lpc40xx::Timer::SetTimer(unsigned long, sjsu::Timer::TimerIsrCondition, unsigned char) const
00010a58  w    F .text	00000054 sjsu::lpc40xx::Gpio::ValidPortCheck() const
00013bcc g     F .text	00000012 .hidden __gnu_Unwind_ForcedUnwind
00013c24 g     F .text	0000000e .hidden __gnu_Unwind_Resume_or_Rethrow
20008000 g       *ABS*	00000000 heap_end
000117f4  w    F .text	000000e8 sjsu::lpc40xx::Timer::Initialize(unsigned long, void (*)(), long) const
00011f5c  w    F .text	00000068 Ssp0IrqHandler
00010318 g     F .text	00000000 _fini
000142a0 g     F .text	00000018 .hidden restore_core_regs
000112ac  w    F .text	0000003c sjsu::lpc40xx::SystemController::IsPeripheralPoweredUp(sjsu::SystemController::PeripheralID const&) const
00011f5c  w    F .text	00000068 UsbactivityIrqHandler
00014384 g     F .text	00000000 .hidden __gnu_Unwind_Save_WMMXC
00010760  w    F .text	00000016 sjsu::Wait(unsigned long long)::{lambda()#1}::operator()() const
00011f5c  w    F .text	00000068 Pll0IrqHandler
000100fc g       .text	00000000 data_section_table_end
00011f5c  w    F .text	00000068 CanactivityIrqHandler
000109f8  w    F .text	00000048 sjsu::lpc40xx::Gpio::Read() const
00011f5c  w    F .text	00000068 NmiHandler
0001010c g     F .text	0000009c InitializeDataSection()
000147b8 g     F .text	00000006 .hidden _Unwind_GetTextRelBase
000101a8 g     F .text	0000006c InitializeBssSection()
1000018c g     O .data	00000004 _impure_ptr
10000000 g       .uninit_RESERVED	00000000 _end_uninit_RESERVED
00011f5c  w    F .text	00000068 McpwmIrqHandler
0001030c g       .text	00000000 __preinit_array_end
00011f5c  w    F .text	00000068 WdtIrqHandler
00011990  w    F .text	0000001e sjsu::lpc40xx::Timer::GetTimer() const
10000000 g       .data	00000000 _data
00010934  w    F .text	00000040 sjsu::lpc40xx::Gpio::SetLow() const
000156d0  w    O .text	0000006c sjsu::lpc40xx::Uart::kBaudRateLUT
0001479c g     F .text	00000012 .hidden _Unwind_GetLanguageSpecificData
00010ba4  w    F .text	0000002e sjsu::lpc40xx::Gpio::AttachInterrupt(void (*)(), sjsu::Gpio::Edge) const
00010974  w    F .text	00000028 sjsu::lpc40xx::Gpio::Set(sjsu::Gpio::State) const
000110b8  w    F .text	0000001a sjsu::I2cDevice<&sjsu::Apds9960::i2c, (unsigned char)57, (sjsu::device::Endian)0, sjsu::Apds9960Interface::MemoryMap_t>::I2cDevice()
000117b0  w    F .text	00000044 sjsu::lpc40xx::Timer::Timer(sjsu::lpc40xx::Timer::Channel_t)
00010776  w    F .text	00000010 sjsu::Wait(unsigned long long)::{lambda()#1}::_FUN()
00013c44 g     F .text	0000002a .hidden _Unwind_VRS_Get
10000188 g     O .data	00000004 __cxxabiv1::__terminate_handler
00014370 g     F .text	00000000 .hidden __gnu_Unwind_Restore_WMMXC
00011324  w    F .text	0000003c sjsu::lpc40xx::SystemController::PowerDownPeripheral(sjsu::SystemController::PeripheralID const&) const
10000318  w    O .bss	00000004 sjsu::Apds9960::gesture
00011360  w    F .text	00000038 sjsu::lpc40xx::SystemController::SelectOscillatorSource(sjsu::lpc40xx::SystemController::OscillatorSource) const
00014768 g     F .text	00000028 .hidden __gnu_unwind_frame
00014404 g     F .text	00000022 .hidden _Unwind_ForcedUnwind
100001f0 g       .data	00000000 _edata
10000048  w    O .data	00000040 sjtwo::Leds()::leds_
000108cc  w    F .text	00000028 sjsu::lpc40xx::Gpio::SetDirection(sjsu::Gpio::Direction) const
10000320  w    O .bss	00000004 sjsu::lpc40xx::Timer::Channel::timer0_isr
00014dc4  w    O .text	00000028 vtable for sjsu::lpc40xx::Gpio
00010d10  w    F .text	0000005c sjsu::lpc40xx::Gpio::ClearEdgeFalling() const
00011f5c  w    F .text	00000068 DebugMonHandler
00011f5c  w    F .text	00000068 Eint2IrqHandler
00014d64  w    O .text	00000010 sjsu::OnBoardLed::On(unsigned char)::file
20008000 g       *ABS*	00000000 __top_RamPeriph32
00011f5c  w    F .text	00000068 Timer3IrqHandler
00010b38  w    F .text	0000006c sjsu::lpc40xx::Gpio::SetInterruptEdge(sjsu::Gpio::Edge) const
10000000 g       *ABS*	00000000 __base_RAM
00015658  w    O .text	00000016 sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const::file
00011f5c  w    F .text	00000068 Eint3IrqHandler
000156b8  w    O .text	0000000a sjsu::lpc40xx::Timer::Initialize(unsigned long, void (*)(), long) const::file
000134f2 g     F .text	00000008 __cxxabiv1::__terminate(void (*)())
000103f8  w    F .text	00000088 sjsu::lpc40xx::Pin::SetMode(sjsu::Pin::Mode) const
0001432c g     F .text	00000000 .hidden __gnu_Unwind_Save_WMMXD
000120d8 g     F .text	0000001a _kill
00011006  w    F .text	00000058 unsigned long sjsu::bit::Insert<unsigned long, int>(unsigned long, int, unsigned long, unsigned long)
00011f5c  w    F .text	00000068 I2c0IrqHandler
00015d8c g     O .text	00000020 __sf_fake_stdout
0001174c  w    F .text	00000020 sjsu::Timer::Timer()
0001030c g       .text	00000000 __init_array_start
000147c0  w    F .text	00000002 .hidden __aeabi_idiv0
0001081a  w    F .text	0000001a sjsu::Delay(unsigned long long)
000120bc g     F .text	0000000c _exit
1000008c  w    O .data	00000004 sjsu::lpc40xx::SystemController::speed_in_hertz
00011f5c  w    F .text	00000068 Eint0IrqHandler
000110d2  w    F .text	0000001c sjsu::Device<sjsu::I2cDevice<&sjsu::Apds9960::i2c, (unsigned char)57, (sjsu::device::Endian)0, sjsu::Apds9960Interface::MemoryMap_t>, (sjsu::device::Endian)0, sjsu::Apds9960Interface::MemoryMap_t>::Device()
00010a40  w    F .text	00000018 sjsu::lpc40xx::Gpio::GetPin() const
0001151c  w    F .text	00000164 sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const
000117b0  w    F .text	00000044 sjsu::lpc40xx::Timer::Timer(sjsu::lpc40xx::Timer::Channel_t)
10000004  w    O .data	00000004 sjsu::Uptime
0001037c  w    F .text	0000007c sjsu::lpc40xx::Pin::SetPinFunction(unsigned char) const
00014018  w    F .text	00000004 .hidden __aeabi_unwind_cpp_pr1
00011dc4  w    F .text	00000060 InitializePlatform()
00011da8 g     F .text	0000001c UptimeRTOS
000105a8  w    F .text	0000004c sjsu::build::Stringify(sjsu::build::Target)
0001176c  w    F .text	00000020 sjsu::SystemController::SystemController()
000147b0 g     F .text	00000006 .hidden _Unwind_GetDataRelBase
00011f5c  w    F .text	00000068 SpiIrqHandler
000108f4  w    F .text	00000040 sjsu::lpc40xx::Gpio::SetHigh() const
0001030c g       .text	00000000 __preinit_array_start
00011400  w    F .text	00000034 sjsu::lpc40xx::SystemController::SelectSpifiClockSource(sjsu::lpc40xx::SystemController::SpifiSource) const
0001178c  w    F .text	00000024 sjsu::lpc40xx::SystemController::SystemController()
00014d4c  w    O .text	00000009 sjsu::lpc40xx::Gpio::ValidPortCheck() const::file
00010ae8  w    F .text	00000038 sjsu::lpc40xx::Gpio::ClearInterruptRoutine() const
00014d74  w    O .text	00000010 sjsu::OnBoardLed::Off(unsigned char)::file
0001573c  w    O .text	00000008 sjsu::lpc40xx::Uart::Port::kUart0Tx
00010dac  w    F .text	00000058 sjsu::OnBoardLed::On(unsigned char)
00011b14  w    F .text	000000ba sjsu::lpc40xx::Uart::Initialize(unsigned long) const
00014884 g     F .text	00000010 raise
0001178c  w    F .text	00000024 sjsu::lpc40xx::SystemController::SystemController()
00015640  w    O .text	00000016 sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const::file



Disassembly of section .text:

00010000 <kInterruptVectorTable>:
   10000:	00 00 01 10 41 1e 01 00 5d 1f 01 00 3d 02 01 00     ....A...]...=...
   10010:	5d 1f 01 00 5d 1f 01 00 5d 1f 01 00 0e 62 f8 ef     ]...]...]....b..
	...
   1002c:	31 22 01 00 5d 1f 01 00 00 00 00 00 61 22 01 00     1"..].......a"..
   1003c:	5d 1f 01 00 5d 1f 01 00 5d 1f 01 00 5d 1f 01 00     ]...]...]...]...
   1004c:	5d 1f 01 00 5d 1f 01 00 5d 1f 01 00 5d 1f 01 00     ]...]...]...]...
   1005c:	5d 1f 01 00 5d 1f 01 00 5d 1f 01 00 5d 1f 01 00     ]...]...]...]...
   1006c:	5d 1f 01 00 5d 1f 01 00 00 00 00 00 5d 1f 01 00     ]...].......]...
   1007c:	5d 1f 01 00 5d 1f 01 00 5d 1f 01 00 5d 1f 01 00     ]...]...]...]...
   1008c:	5d 1f 01 00 5d 1f 01 00 5d 1f 01 00 5d 1f 01 00     ]...]...]...]...
   1009c:	5d 1f 01 00 5d 1f 01 00 5d 1f 01 00 5d 1f 01 00     ]...]...]...]...
   100ac:	5d 1f 01 00 5d 1f 01 00 5d 1f 01 00 5d 1f 01 00     ]...]...]...]...
   100bc:	5d 1f 01 00 5d 1f 01 00 5d 1f 01 00 5d 1f 01 00     ]...]...]...]...
   100cc:	5d 1f 01 00 5d 1f 01 00 5d 1f 01 00 5d 1f 01 00     ]...]...]...]...
   100dc:	5d 1f 01 00 5d 1f 01 00                             ]...]...

000100e4 <data_section_table>:
   100e4:	000166f0 	.word	0x000166f0
   100e8:	10000000 	.word	0x10000000
   100ec:	000001f0 	.word	0x000001f0
   100f0:	000166f0 	.word	0x000166f0
   100f4:	20000000 	.word	0x20000000
   100f8:	00000000 	.word	0x00000000

000100fc <bss_section_table>:
   100fc:	100001f0 	.word	0x100001f0
   10100:	000001c0 	.word	0x000001c0
   10104:	20000000 	.word	0x20000000
   10108:	00000000 	.word	0x00000000

0001010c <InitializeDataSection()>:
SJ2_WEAK(void InitializePlatform());

// Functions to carry out the initialization of RW and BSS data sections.
SJ2_SECTION(".after_vectors")
void InitializeDataSection()
{
   1010c:	b480      	push	{r7}
   1010e:	b087      	sub	sp, #28
   10110:	af00      	add	r7, sp, #0
  for (int i = 0; &data_section_table[i] < &data_section_table_end; i++)
   10112:	2300      	movs	r3, #0
   10114:	617b      	str	r3, [r7, #20]
   10116:	697a      	ldr	r2, [r7, #20]
   10118:	4613      	mov	r3, r2
   1011a:	005b      	lsls	r3, r3, #1
   1011c:	4413      	add	r3, r2
   1011e:	009b      	lsls	r3, r3, #2
   10120:	4a1f      	ldr	r2, [pc, #124]	; (101a0 <InitializeDataSection()+0x94>)
   10122:	4413      	add	r3, r2
   10124:	4a1f      	ldr	r2, [pc, #124]	; (101a4 <InitializeDataSection()+0x98>)
   10126:	4293      	cmp	r3, r2
   10128:	d233      	bcs.n	10192 <InitializeDataSection()+0x86>
  {
    uint32_t * rom_location = data_section_table[i].rom_location;
   1012a:	491d      	ldr	r1, [pc, #116]	; (101a0 <InitializeDataSection()+0x94>)
   1012c:	697a      	ldr	r2, [r7, #20]
   1012e:	4613      	mov	r3, r2
   10130:	005b      	lsls	r3, r3, #1
   10132:	4413      	add	r3, r2
   10134:	009b      	lsls	r3, r3, #2
   10136:	440b      	add	r3, r1
   10138:	681b      	ldr	r3, [r3, #0]
   1013a:	60fb      	str	r3, [r7, #12]
    uint32_t * ram_location = data_section_table[i].ram_location;
   1013c:	4918      	ldr	r1, [pc, #96]	; (101a0 <InitializeDataSection()+0x94>)
   1013e:	697a      	ldr	r2, [r7, #20]
   10140:	4613      	mov	r3, r2
   10142:	005b      	lsls	r3, r3, #1
   10144:	4413      	add	r3, r2
   10146:	009b      	lsls	r3, r3, #2
   10148:	440b      	add	r3, r1
   1014a:	685b      	ldr	r3, [r3, #4]
   1014c:	60bb      	str	r3, [r7, #8]
    uint32_t length         = data_section_table[i].length;
   1014e:	4914      	ldr	r1, [pc, #80]	; (101a0 <InitializeDataSection()+0x94>)
   10150:	697a      	ldr	r2, [r7, #20]
   10152:	4613      	mov	r3, r2
   10154:	005b      	lsls	r3, r3, #1
   10156:	4413      	add	r3, r2
   10158:	009b      	lsls	r3, r3, #2
   1015a:	440b      	add	r3, r1
   1015c:	3308      	adds	r3, #8
   1015e:	681b      	ldr	r3, [r3, #0]
   10160:	607b      	str	r3, [r7, #4]
    for (size_t j = 0; j < length; j++)
   10162:	2300      	movs	r3, #0
   10164:	613b      	str	r3, [r7, #16]
   10166:	693a      	ldr	r2, [r7, #16]
   10168:	687b      	ldr	r3, [r7, #4]
   1016a:	429a      	cmp	r2, r3
   1016c:	d20d      	bcs.n	1018a <InitializeDataSection()+0x7e>
    {
      ram_location[j] = rom_location[j];
   1016e:	693b      	ldr	r3, [r7, #16]
   10170:	009b      	lsls	r3, r3, #2
   10172:	68fa      	ldr	r2, [r7, #12]
   10174:	441a      	add	r2, r3
   10176:	693b      	ldr	r3, [r7, #16]
   10178:	009b      	lsls	r3, r3, #2
   1017a:	68b9      	ldr	r1, [r7, #8]
   1017c:	440b      	add	r3, r1
   1017e:	6812      	ldr	r2, [r2, #0]
   10180:	601a      	str	r2, [r3, #0]
    for (size_t j = 0; j < length; j++)
   10182:	693b      	ldr	r3, [r7, #16]
   10184:	3301      	adds	r3, #1
   10186:	613b      	str	r3, [r7, #16]
   10188:	e7ed      	b.n	10166 <InitializeDataSection()+0x5a>
  for (int i = 0; &data_section_table[i] < &data_section_table_end; i++)
   1018a:	697b      	ldr	r3, [r7, #20]
   1018c:	3301      	adds	r3, #1
   1018e:	617b      	str	r3, [r7, #20]
   10190:	e7c1      	b.n	10116 <InitializeDataSection()+0xa>
    }
  }
}
   10192:	bf00      	nop
   10194:	371c      	adds	r7, #28
   10196:	46bd      	mov	sp, r7
   10198:	f85d 7b04 	ldr.w	r7, [sp], #4
   1019c:	4770      	bx	lr
   1019e:	bf00      	nop
   101a0:	000100e4 	.word	0x000100e4
   101a4:	000100fc 	.word	0x000100fc

000101a8 <InitializeBssSection()>:

// Functions to initialization BSS data sections. This is important because
// the std c libs assume that BSS is set to zero.
SJ2_SECTION(".after_vectors")
void InitializeBssSection()
{
   101a8:	b480      	push	{r7}
   101aa:	b085      	sub	sp, #20
   101ac:	af00      	add	r7, sp, #0
  for (int i = 0; &bss_section_table[i] < &bss_section_table_end; i++)
   101ae:	2300      	movs	r3, #0
   101b0:	60fb      	str	r3, [r7, #12]
   101b2:	68fb      	ldr	r3, [r7, #12]
   101b4:	00db      	lsls	r3, r3, #3
   101b6:	4a15      	ldr	r2, [pc, #84]	; (1020c <InitializeBssSection()+0x64>)
   101b8:	4413      	add	r3, r2
   101ba:	4a15      	ldr	r2, [pc, #84]	; (10210 <InitializeBssSection()+0x68>)
   101bc:	4293      	cmp	r3, r2
   101be:	d21e      	bcs.n	101fe <InitializeBssSection()+0x56>
  {
    uint32_t * ram_location = bss_section_table[i].ram_location;
   101c0:	4a12      	ldr	r2, [pc, #72]	; (1020c <InitializeBssSection()+0x64>)
   101c2:	68fb      	ldr	r3, [r7, #12]
   101c4:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
   101c8:	607b      	str	r3, [r7, #4]
    uint32_t length         = bss_section_table[i].length;
   101ca:	4a10      	ldr	r2, [pc, #64]	; (1020c <InitializeBssSection()+0x64>)
   101cc:	68fb      	ldr	r3, [r7, #12]
   101ce:	00db      	lsls	r3, r3, #3
   101d0:	4413      	add	r3, r2
   101d2:	685b      	ldr	r3, [r3, #4]
   101d4:	603b      	str	r3, [r7, #0]
    for (size_t j = 0; j < length; j++)
   101d6:	2300      	movs	r3, #0
   101d8:	60bb      	str	r3, [r7, #8]
   101da:	68ba      	ldr	r2, [r7, #8]
   101dc:	683b      	ldr	r3, [r7, #0]
   101de:	429a      	cmp	r2, r3
   101e0:	d209      	bcs.n	101f6 <InitializeBssSection()+0x4e>
    {
      ram_location[j] = 0;
   101e2:	68bb      	ldr	r3, [r7, #8]
   101e4:	009b      	lsls	r3, r3, #2
   101e6:	687a      	ldr	r2, [r7, #4]
   101e8:	4413      	add	r3, r2
   101ea:	2200      	movs	r2, #0
   101ec:	601a      	str	r2, [r3, #0]
    for (size_t j = 0; j < length; j++)
   101ee:	68bb      	ldr	r3, [r7, #8]
   101f0:	3301      	adds	r3, #1
   101f2:	60bb      	str	r3, [r7, #8]
   101f4:	e7f1      	b.n	101da <InitializeBssSection()+0x32>
  for (int i = 0; &bss_section_table[i] < &bss_section_table_end; i++)
   101f6:	68fb      	ldr	r3, [r7, #12]
   101f8:	3301      	adds	r3, #1
   101fa:	60fb      	str	r3, [r7, #12]
   101fc:	e7d9      	b.n	101b2 <InitializeBssSection()+0xa>
    }
  }
}
   101fe:	bf00      	nop
   10200:	3714      	adds	r7, #20
   10202:	46bd      	mov	sp, r7
   10204:	f85d 7b04 	ldr.w	r7, [sp], #4
   10208:	4770      	bx	lr
   1020a:	bf00      	nop
   1020c:	000100fc 	.word	0x000100fc
   10210:	0001010c 	.word	0x0001010c

00010214 <InitializeFloatingPointUnit()>:
http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0553a/
BABGHFIB.html
*/
SJ2_SECTION(".after_vectors")
void InitializeFloatingPointUnit()
{
   10214:	b480      	push	{r7}
   10216:	af00      	add	r7, sp, #0
      // Write back the modified value to the CPACR
      "STR     R1, [R0]\n"
      // Wait for store to complete
      "DSB\n"
      // reset pipeline now the FPU is enabled
      "ISB\n");
   10218:	f8df 001c 	ldr.w	r0, [pc, #28]	; 10238 <InitializeFloatingPointUnit()+0x24>
   1021c:	6801      	ldr	r1, [r0, #0]
   1021e:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   10222:	6001      	str	r1, [r0, #0]
   10224:	f3bf 8f4f 	dsb	sy
   10228:	f3bf 8f6f 	isb	sy
}
   1022c:	bf00      	nop
   1022e:	46bd      	mov	sp, r7
   10230:	f85d 7b04 	ldr.w	r7, [sp], #4
   10234:	4770      	bx	lr
   10236:	0000      	.short	0x0000
   10238:	e000ed88 	.word	0xe000ed88

0001023c <HardFaultHandler>:
  sjsu::Halt();
}

SJ2_SECTION(".after_vectors")
void HardFaultHandler(void)
{
   1023c:	b480      	push	{r7}
   1023e:	af00      	add	r7, sp, #0
      " mrseq r0, msp                                       \n"
      " mrsne r0, psp                                       \n"
      " ldr r1, [r0, #24]                                   \n"
      " ldr r2, handler2_address_const                      \n"
      " bx r2                                               \n"
      " handler2_address_const: .word GetRegistersFromStack \n");
   10240:	f01e 0f04 	tst.w	lr, #4
   10244:	bf0c      	ite	eq
   10246:	f3ef 8008 	mrseq	r0, MSP
   1024a:	f3ef 8009 	mrsne	r0, PSP
   1024e:	6981      	ldr	r1, [r0, #24]
   10250:	4a00      	ldr	r2, [pc, #0]	; (10254 <handler2_address_const>)
   10252:	4710      	bx	r2

00010254 <handler2_address_const>:
   10254:	0001201d 	.word	0x0001201d
#endif
}
   10258:	bf00      	nop
   1025a:	46bd      	mov	sp, r7
   1025c:	f85d 7b04 	ldr.w	r7, [sp], #4
   10260:	4770      	bx	lr
   10262:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10266:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1026a:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1026e:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10272:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10276:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1027a:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1027e:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10282:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10286:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1028a:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1028e:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10292:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10296:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1029a:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1029e:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102a2:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102a6:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102aa:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102ae:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102b2:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102b6:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102ba:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102be:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102c2:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102c6:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102ca:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102ce:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102d2:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102d6:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102da:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102de:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102e2:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102e6:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102ea:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102ee:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102f2:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102f6:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102fa:	Address 0x00000000000102fa is out of bounds.


000102fc <__CRP_WORD_START__>:
   102fc:	ffffffff 	.word	0xffffffff

00010300 <_init>:
   10300:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   10302:	bf00      	nop
   10304:	bcf8      	pop	{r3, r4, r5, r6, r7}
   10306:	bc08      	pop	{r3}
   10308:	469e      	mov	lr, r3
   1030a:	4770      	bx	lr

0001030c <__init_array_start>:
   1030c:	00010349 	.word	0x00010349
   10310:	00011135 	.word	0x00011135
   10314:	00011ebd 	.word	0x00011ebd

00010318 <_fini>:
   10318:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1031a:	bf00      	nop
   1031c:	bcf8      	pop	{r3, r4, r5, r6, r7}
   1031e:	bc08      	pop	{r3}
   10320:	469e      	mov	lr, r3
   10322:	4770      	bx	lr

00010324 <__do_global_dtors_aux>:
   10324:	b510      	push	{r4, lr}
   10326:	4c05      	ldr	r4, [pc, #20]	; (1033c <__do_global_dtors_aux+0x18>)
   10328:	7823      	ldrb	r3, [r4, #0]
   1032a:	b933      	cbnz	r3, 1033a <__do_global_dtors_aux+0x16>
   1032c:	4b04      	ldr	r3, [pc, #16]	; (10340 <__do_global_dtors_aux+0x1c>)
   1032e:	b113      	cbz	r3, 10336 <__do_global_dtors_aux+0x12>
   10330:	4804      	ldr	r0, [pc, #16]	; (10344 <__do_global_dtors_aux+0x20>)
   10332:	f3af 8000 	nop.w
   10336:	2301      	movs	r3, #1
   10338:	7023      	strb	r3, [r4, #0]
   1033a:	bd10      	pop	{r4, pc}
   1033c:	100001f0 	.word	0x100001f0
   10340:	00000000 	.word	0x00000000
   10344:	00016298 	.word	0x00016298

00010348 <frame_dummy>:
   10348:	b508      	push	{r3, lr}
   1034a:	4b03      	ldr	r3, [pc, #12]	; (10358 <frame_dummy+0x10>)
   1034c:	b11b      	cbz	r3, 10356 <frame_dummy+0xe>
   1034e:	4903      	ldr	r1, [pc, #12]	; (1035c <frame_dummy+0x14>)
   10350:	4803      	ldr	r0, [pc, #12]	; (10360 <frame_dummy+0x18>)
   10352:	f3af 8000 	nop.w
   10356:	bd08      	pop	{r3, pc}
   10358:	00000000 	.word	0x00000000
   1035c:	100001f4 	.word	0x100001f4
   10360:	00016298 	.word	0x00016298

00010364 <unsigned char sjsu::util::Value<sjsu::lpc40xx::Pin::PinBitMap, unsigned char>(sjsu::lpc40xx::Pin::PinBitMap)>:
//
// @param enum_type_value variable you would like to get the value of.
// @return the value of the enum class type variable of with the underlying
//         type of the enum class.
template <typename Enum, typename Type = typename std::underlying_type_t<Enum>>
constexpr Type Value(Enum enum_type_value)
   10364:	b480      	push	{r7}
   10366:	b083      	sub	sp, #12
   10368:	af00      	add	r7, sp, #0
   1036a:	4603      	mov	r3, r0
   1036c:	71fb      	strb	r3, [r7, #7]
{
  return static_cast<Type>(enum_type_value);
   1036e:	79fb      	ldrb	r3, [r7, #7]
}
   10370:	4618      	mov	r0, r3
   10372:	370c      	adds	r7, #12
   10374:	46bd      	mov	sp, r7
   10376:	f85d 7b04 	ldr.w	r7, [sp], #4
   1037a:	4770      	bx	lr

0001037c <sjsu::lpc40xx::Pin::SetPinFunction(unsigned char) const>:
  static constexpr sjsu::lpc40xx::Pin CreateInactivePin()
  {
    return Pin(5, 4);
  }
  constexpr Pin(uint8_t port, uint8_t pin) : sjsu::Pin(port, pin) {}
  void SetPinFunction(uint8_t function) const override
   1037c:	b590      	push	{r4, r7, lr}
   1037e:	b089      	sub	sp, #36	; 0x24
   10380:	af00      	add	r7, sp, #0
   10382:	6078      	str	r0, [r7, #4]
   10384:	460b      	mov	r3, r1
   10386:	70fb      	strb	r3, [r7, #3]
   10388:	687b      	ldr	r3, [r7, #4]
   1038a:	613b      	str	r3, [r7, #16]
  }

 protected:
  [[gnu::always_inline]] volatile uint32_t * GetPinRegister() const
  {
    return &pin_map->_register[GetPort()][GetPin()];
   1038c:	4b19      	ldr	r3, [pc, #100]	; (103f4 <sjsu::lpc40xx::Pin::SetPinFunction(unsigned char) const+0x78>)
   1038e:	681a      	ldr	r2, [r3, #0]
   10390:	693b      	ldr	r3, [r7, #16]
   10392:	60fb      	str	r3, [r7, #12]
  virtual void SetMode(Pin::Mode mode) const              = 0;
  virtual void SetAsOpenDrain(bool set_as_open_drain = true) const = 0;
  virtual void SetAsAnalogMode(bool set_as_analog = true) const    = 0;

  [[gnu::always_inline]] uint8_t GetPort() const {
    return port_;
   10394:	68fb      	ldr	r3, [r7, #12]
   10396:	791b      	ldrb	r3, [r3, #4]
   10398:	4618      	mov	r0, r3
   1039a:	693b      	ldr	r3, [r7, #16]
   1039c:	60bb      	str	r3, [r7, #8]
  }[[gnu::always_inline]] uint8_t GetPin() const
  {
    return pin_;
   1039e:	68bb      	ldr	r3, [r7, #8]
   103a0:	795b      	ldrb	r3, [r3, #5]
   103a2:	4619      	mov	r1, r3
   103a4:	0143      	lsls	r3, r0, #5
   103a6:	440b      	add	r3, r1
   103a8:	009b      	lsls	r3, r3, #2
   103aa:	4413      	add	r3, r2
    *GetPinRegister() = bit::Insert(*GetPinRegister(), function,
   103ac:	681c      	ldr	r4, [r3, #0]
                                    util::Value(PinBitMap::kFunction), 3);
   103ae:	2000      	movs	r0, #0
   103b0:	f7ff ffd8 	bl	10364 <unsigned char sjsu::util::Value<sjsu::lpc40xx::Pin::PinBitMap, unsigned char>(sjsu::lpc40xx::Pin::PinBitMap)>
   103b4:	4603      	mov	r3, r0
    *GetPinRegister() = bit::Insert(*GetPinRegister(), function,
   103b6:	461a      	mov	r2, r3
   103b8:	78f9      	ldrb	r1, [r7, #3]
   103ba:	2303      	movs	r3, #3
   103bc:	4620      	mov	r0, r4
   103be:	f000 fdf5 	bl	10fac <unsigned long sjsu::bit::Insert<unsigned long, unsigned char>(unsigned long, unsigned char, unsigned long, unsigned long)>
   103c2:	4601      	mov	r1, r0
   103c4:	687b      	ldr	r3, [r7, #4]
   103c6:	61fb      	str	r3, [r7, #28]
    return &pin_map->_register[GetPort()][GetPin()];
   103c8:	4b0a      	ldr	r3, [pc, #40]	; (103f4 <sjsu::lpc40xx::Pin::SetPinFunction(unsigned char) const+0x78>)
   103ca:	681a      	ldr	r2, [r3, #0]
   103cc:	69fb      	ldr	r3, [r7, #28]
   103ce:	61bb      	str	r3, [r7, #24]
    return port_;
   103d0:	69bb      	ldr	r3, [r7, #24]
   103d2:	791b      	ldrb	r3, [r3, #4]
   103d4:	461c      	mov	r4, r3
   103d6:	69fb      	ldr	r3, [r7, #28]
   103d8:	617b      	str	r3, [r7, #20]
    return pin_;
   103da:	697b      	ldr	r3, [r7, #20]
   103dc:	795b      	ldrb	r3, [r3, #5]
   103de:	4618      	mov	r0, r3
   103e0:	0163      	lsls	r3, r4, #5
   103e2:	4403      	add	r3, r0
   103e4:	009b      	lsls	r3, r3, #2
   103e6:	4413      	add	r3, r2
    *GetPinRegister() = bit::Insert(*GetPinRegister(), function,
   103e8:	6019      	str	r1, [r3, #0]
  }
   103ea:	bf00      	nop
   103ec:	3724      	adds	r7, #36	; 0x24
   103ee:	46bd      	mov	sp, r7
   103f0:	bd90      	pop	{r4, r7, pc}
   103f2:	bf00      	nop
   103f4:	10000000 	.word	0x10000000

000103f8 <sjsu::lpc40xx::Pin::SetMode(sjsu::Pin::Mode) const>:
  void SetMode(sjsu::Pin::Mode mode) const override
   103f8:	b5b0      	push	{r4, r5, r7, lr}
   103fa:	b08a      	sub	sp, #40	; 0x28
   103fc:	af00      	add	r7, sp, #0
   103fe:	6078      	str	r0, [r7, #4]
   10400:	460b      	mov	r3, r1
   10402:	70fb      	strb	r3, [r7, #3]
    uint8_t ui_mode   = static_cast<uint8_t>(mode);
   10404:	78fb      	ldrb	r3, [r7, #3]
   10406:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
   1040a:	687b      	ldr	r3, [r7, #4]
   1040c:	617b      	str	r3, [r7, #20]
    return &pin_map->_register[GetPort()][GetPin()];
   1040e:	4b1b      	ldr	r3, [pc, #108]	; (1047c <sjsu::lpc40xx::Pin::SetMode(sjsu::Pin::Mode) const+0x84>)
   10410:	681a      	ldr	r2, [r3, #0]
   10412:	697b      	ldr	r3, [r7, #20]
   10414:	613b      	str	r3, [r7, #16]
    return port_;
   10416:	693b      	ldr	r3, [r7, #16]
   10418:	791b      	ldrb	r3, [r3, #4]
   1041a:	4618      	mov	r0, r3
   1041c:	697b      	ldr	r3, [r7, #20]
   1041e:	60fb      	str	r3, [r7, #12]
    return pin_;
   10420:	68fb      	ldr	r3, [r7, #12]
   10422:	795b      	ldrb	r3, [r3, #5]
   10424:	4619      	mov	r1, r3
   10426:	0143      	lsls	r3, r0, #5
   10428:	440b      	add	r3, r1
   1042a:	009b      	lsls	r3, r3, #2
   1042c:	4413      	add	r3, r2
    *GetPinRegister() = bit::Insert(*GetPinRegister(), ui_mode & 0b11,
   1042e:	681c      	ldr	r4, [r3, #0]
   10430:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
   10434:	f003 0503 	and.w	r5, r3, #3
                                    util::Value(PinBitMap::kMode), 2);
   10438:	2003      	movs	r0, #3
   1043a:	f7ff ff93 	bl	10364 <unsigned char sjsu::util::Value<sjsu::lpc40xx::Pin::PinBitMap, unsigned char>(sjsu::lpc40xx::Pin::PinBitMap)>
   1043e:	4603      	mov	r3, r0
    *GetPinRegister() = bit::Insert(*GetPinRegister(), ui_mode & 0b11,
   10440:	461a      	mov	r2, r3
   10442:	2302      	movs	r3, #2
   10444:	4629      	mov	r1, r5
   10446:	4620      	mov	r0, r4
   10448:	f000 fddd 	bl	11006 <unsigned long sjsu::bit::Insert<unsigned long, int>(unsigned long, int, unsigned long, unsigned long)>
   1044c:	4601      	mov	r1, r0
   1044e:	687b      	ldr	r3, [r7, #4]
   10450:	623b      	str	r3, [r7, #32]
    return &pin_map->_register[GetPort()][GetPin()];
   10452:	4b0a      	ldr	r3, [pc, #40]	; (1047c <sjsu::lpc40xx::Pin::SetMode(sjsu::Pin::Mode) const+0x84>)
   10454:	681a      	ldr	r2, [r3, #0]
   10456:	6a3b      	ldr	r3, [r7, #32]
   10458:	61fb      	str	r3, [r7, #28]
    return port_;
   1045a:	69fb      	ldr	r3, [r7, #28]
   1045c:	791b      	ldrb	r3, [r3, #4]
   1045e:	461c      	mov	r4, r3
   10460:	6a3b      	ldr	r3, [r7, #32]
   10462:	61bb      	str	r3, [r7, #24]
    return pin_;
   10464:	69bb      	ldr	r3, [r7, #24]
   10466:	795b      	ldrb	r3, [r3, #5]
   10468:	4618      	mov	r0, r3
   1046a:	0163      	lsls	r3, r4, #5
   1046c:	4403      	add	r3, r0
   1046e:	009b      	lsls	r3, r3, #2
   10470:	4413      	add	r3, r2
    *GetPinRegister() = bit::Insert(*GetPinRegister(), ui_mode & 0b11,
   10472:	6019      	str	r1, [r3, #0]
  }
   10474:	bf00      	nop
   10476:	3728      	adds	r7, #40	; 0x28
   10478:	46bd      	mov	sp, r7
   1047a:	bdb0      	pop	{r4, r5, r7, pc}
   1047c:	10000000 	.word	0x10000000

00010480 <sjsu::lpc40xx::Pin::SetAsAnalogMode(bool) const>:
  void SetAsAnalogMode(bool set_as_analog = true) const override
   10480:	b5b0      	push	{r4, r5, r7, lr}
   10482:	b088      	sub	sp, #32
   10484:	af00      	add	r7, sp, #0
   10486:	6078      	str	r0, [r7, #4]
   10488:	460b      	mov	r3, r1
   1048a:	70fb      	strb	r3, [r7, #3]
   1048c:	687b      	ldr	r3, [r7, #4]
   1048e:	613b      	str	r3, [r7, #16]
    return &pin_map->_register[GetPort()][GetPin()];
   10490:	4b1b      	ldr	r3, [pc, #108]	; (10500 <sjsu::lpc40xx::Pin::SetAsAnalogMode(bool) const+0x80>)
   10492:	681a      	ldr	r2, [r3, #0]
   10494:	693b      	ldr	r3, [r7, #16]
   10496:	60fb      	str	r3, [r7, #12]
    return port_;
   10498:	68fb      	ldr	r3, [r7, #12]
   1049a:	791b      	ldrb	r3, [r3, #4]
   1049c:	4618      	mov	r0, r3
   1049e:	693b      	ldr	r3, [r7, #16]
   104a0:	60bb      	str	r3, [r7, #8]
    return pin_;
   104a2:	68bb      	ldr	r3, [r7, #8]
   104a4:	795b      	ldrb	r3, [r3, #5]
   104a6:	4619      	mov	r1, r3
   104a8:	0143      	lsls	r3, r0, #5
   104aa:	440b      	add	r3, r1
   104ac:	009b      	lsls	r3, r3, #2
   104ae:	4413      	add	r3, r2
        bit::Insert(*GetPinRegister(), !set_as_analog,
   104b0:	681c      	ldr	r4, [r3, #0]
   104b2:	78fb      	ldrb	r3, [r7, #3]
   104b4:	f083 0301 	eor.w	r3, r3, #1
   104b8:	b2dd      	uxtb	r5, r3
                    util::Value(PinBitMap::kAnalogDigitalMode), 1);
   104ba:	2007      	movs	r0, #7
   104bc:	f7ff ff52 	bl	10364 <unsigned char sjsu::util::Value<sjsu::lpc40xx::Pin::PinBitMap, unsigned char>(sjsu::lpc40xx::Pin::PinBitMap)>
   104c0:	4603      	mov	r3, r0
        bit::Insert(*GetPinRegister(), !set_as_analog,
   104c2:	461a      	mov	r2, r3
   104c4:	2301      	movs	r3, #1
   104c6:	4629      	mov	r1, r5
   104c8:	4620      	mov	r0, r4
   104ca:	f000 fdc8 	bl	1105e <unsigned long sjsu::bit::Insert<unsigned long, bool>(unsigned long, bool, unsigned long, unsigned long)>
   104ce:	4601      	mov	r1, r0
   104d0:	687b      	ldr	r3, [r7, #4]
   104d2:	61fb      	str	r3, [r7, #28]
    return &pin_map->_register[GetPort()][GetPin()];
   104d4:	4b0a      	ldr	r3, [pc, #40]	; (10500 <sjsu::lpc40xx::Pin::SetAsAnalogMode(bool) const+0x80>)
   104d6:	681a      	ldr	r2, [r3, #0]
   104d8:	69fb      	ldr	r3, [r7, #28]
   104da:	61bb      	str	r3, [r7, #24]
    return port_;
   104dc:	69bb      	ldr	r3, [r7, #24]
   104de:	791b      	ldrb	r3, [r3, #4]
   104e0:	461c      	mov	r4, r3
   104e2:	69fb      	ldr	r3, [r7, #28]
   104e4:	617b      	str	r3, [r7, #20]
    return pin_;
   104e6:	697b      	ldr	r3, [r7, #20]
   104e8:	795b      	ldrb	r3, [r3, #5]
   104ea:	4618      	mov	r0, r3
   104ec:	0163      	lsls	r3, r4, #5
   104ee:	4403      	add	r3, r0
   104f0:	009b      	lsls	r3, r3, #2
   104f2:	4413      	add	r3, r2
    *GetPinRegister() =
   104f4:	6019      	str	r1, [r3, #0]
  }
   104f6:	bf00      	nop
   104f8:	3720      	adds	r7, #32
   104fa:	46bd      	mov	sp, r7
   104fc:	bdb0      	pop	{r4, r5, r7, pc}
   104fe:	bf00      	nop
   10500:	10000000 	.word	0x10000000

00010504 <sjsu::lpc40xx::Pin::SetAsOpenDrain(bool) const>:
  void SetAsOpenDrain(bool set_as_open_drain = true) const override
   10504:	b590      	push	{r4, r7, lr}
   10506:	b089      	sub	sp, #36	; 0x24
   10508:	af00      	add	r7, sp, #0
   1050a:	6078      	str	r0, [r7, #4]
   1050c:	460b      	mov	r3, r1
   1050e:	70fb      	strb	r3, [r7, #3]
   10510:	687b      	ldr	r3, [r7, #4]
   10512:	613b      	str	r3, [r7, #16]
    return &pin_map->_register[GetPort()][GetPin()];
   10514:	4b19      	ldr	r3, [pc, #100]	; (1057c <sjsu::lpc40xx::Pin::SetAsOpenDrain(bool) const+0x78>)
   10516:	681a      	ldr	r2, [r3, #0]
   10518:	693b      	ldr	r3, [r7, #16]
   1051a:	60fb      	str	r3, [r7, #12]
    return port_;
   1051c:	68fb      	ldr	r3, [r7, #12]
   1051e:	791b      	ldrb	r3, [r3, #4]
   10520:	4618      	mov	r0, r3
   10522:	693b      	ldr	r3, [r7, #16]
   10524:	60bb      	str	r3, [r7, #8]
    return pin_;
   10526:	68bb      	ldr	r3, [r7, #8]
   10528:	795b      	ldrb	r3, [r3, #5]
   1052a:	4619      	mov	r1, r3
   1052c:	0143      	lsls	r3, r0, #5
   1052e:	440b      	add	r3, r1
   10530:	009b      	lsls	r3, r3, #2
   10532:	4413      	add	r3, r2
    *GetPinRegister() = bit::Insert(*GetPinRegister(), set_as_open_drain,
   10534:	681c      	ldr	r4, [r3, #0]
                                    util::Value(PinBitMap::kOpenDrain), 1);
   10536:	200a      	movs	r0, #10
   10538:	f7ff ff14 	bl	10364 <unsigned char sjsu::util::Value<sjsu::lpc40xx::Pin::PinBitMap, unsigned char>(sjsu::lpc40xx::Pin::PinBitMap)>
   1053c:	4603      	mov	r3, r0
    *GetPinRegister() = bit::Insert(*GetPinRegister(), set_as_open_drain,
   1053e:	461a      	mov	r2, r3
   10540:	78f9      	ldrb	r1, [r7, #3]
   10542:	2301      	movs	r3, #1
   10544:	4620      	mov	r0, r4
   10546:	f000 fd8a 	bl	1105e <unsigned long sjsu::bit::Insert<unsigned long, bool>(unsigned long, bool, unsigned long, unsigned long)>
   1054a:	4601      	mov	r1, r0
   1054c:	687b      	ldr	r3, [r7, #4]
   1054e:	61fb      	str	r3, [r7, #28]
    return &pin_map->_register[GetPort()][GetPin()];
   10550:	4b0a      	ldr	r3, [pc, #40]	; (1057c <sjsu::lpc40xx::Pin::SetAsOpenDrain(bool) const+0x78>)
   10552:	681a      	ldr	r2, [r3, #0]
   10554:	69fb      	ldr	r3, [r7, #28]
   10556:	61bb      	str	r3, [r7, #24]
    return port_;
   10558:	69bb      	ldr	r3, [r7, #24]
   1055a:	791b      	ldrb	r3, [r3, #4]
   1055c:	461c      	mov	r4, r3
   1055e:	69fb      	ldr	r3, [r7, #28]
   10560:	617b      	str	r3, [r7, #20]
    return pin_;
   10562:	697b      	ldr	r3, [r7, #20]
   10564:	795b      	ldrb	r3, [r3, #5]
   10566:	4618      	mov	r0, r3
   10568:	0163      	lsls	r3, r4, #5
   1056a:	4403      	add	r3, r0
   1056c:	009b      	lsls	r3, r3, #2
   1056e:	4413      	add	r3, r2
    *GetPinRegister() = bit::Insert(*GetPinRegister(), set_as_open_drain,
   10570:	6019      	str	r1, [r3, #0]
  }
   10572:	bf00      	nop
   10574:	3724      	adds	r7, #36	; 0x24
   10576:	46bd      	mov	sp, r7
   10578:	bd90      	pop	{r4, r7, pc}
   1057a:	bf00      	nop
   1057c:	10000000 	.word	0x10000000

00010580 <_Unwind_GetGR>:
  _Unwind_Reason_Code __gnu_unwind_execute (_Unwind_Context *,
					    __gnu_unwind_state *);

  static inline _Unwind_Word
  _Unwind_GetGR (_Unwind_Context *context, int regno)
    {
   10580:	b580      	push	{r7, lr}
   10582:	b086      	sub	sp, #24
   10584:	af02      	add	r7, sp, #8
   10586:	6078      	str	r0, [r7, #4]
   10588:	6039      	str	r1, [r7, #0]
      _uw val;
      _Unwind_VRS_Get (context, _UVRSC_CORE, regno, _UVRSD_UINT32, &val);
   1058a:	683a      	ldr	r2, [r7, #0]
   1058c:	f107 030c 	add.w	r3, r7, #12
   10590:	9300      	str	r3, [sp, #0]
   10592:	2300      	movs	r3, #0
   10594:	2100      	movs	r1, #0
   10596:	6878      	ldr	r0, [r7, #4]
   10598:	f003 fb54 	bl	13c44 <_Unwind_VRS_Get>
      return val;
   1059c:	68fb      	ldr	r3, [r7, #12]
    }
   1059e:	4618      	mov	r0, r3
   105a0:	3710      	adds	r7, #16
   105a2:	46bd      	mov	sp, r7
   105a4:	bd80      	pop	{r7, pc}
   105a6:	Address 0x00000000000105a6 is out of bounds.


000105a8 <sjsu::build::Stringify(sjsu::build::Target)>:
};

constexpr const Target kTarget = Target::TARGET;

constexpr const char * Stringify(Target target)
{
   105a8:	b480      	push	{r7}
   105aa:	b085      	sub	sp, #20
   105ac:	af00      	add	r7, sp, #0
   105ae:	6078      	str	r0, [r7, #4]
  const char * result = "";
   105b0:	4b0c      	ldr	r3, [pc, #48]	; (105e4 <sjsu::build::Stringify(sjsu::build::Target)+0x3c>)
   105b2:	60fb      	str	r3, [r7, #12]
  switch (target)
   105b4:	687b      	ldr	r3, [r7, #4]
   105b6:	2b01      	cmp	r3, #1
   105b8:	d007      	beq.n	105ca <sjsu::build::Stringify(sjsu::build::Target)+0x22>
   105ba:	2b02      	cmp	r3, #2
   105bc:	d008      	beq.n	105d0 <sjsu::build::Stringify(sjsu::build::Target)+0x28>
   105be:	2b00      	cmp	r3, #0
   105c0:	d000      	beq.n	105c4 <sjsu::build::Stringify(sjsu::build::Target)+0x1c>
  {
    case Target::Bootloader: result = "bootloader"; break;
    case Target::Application: result = "application"; break;
    case Target::HostTest: result = "host test"; break;
    default: break;
   105c2:	e008      	b.n	105d6 <sjsu::build::Stringify(sjsu::build::Target)+0x2e>
    case Target::Bootloader: result = "bootloader"; break;
   105c4:	4b08      	ldr	r3, [pc, #32]	; (105e8 <sjsu::build::Stringify(sjsu::build::Target)+0x40>)
   105c6:	60fb      	str	r3, [r7, #12]
   105c8:	e005      	b.n	105d6 <sjsu::build::Stringify(sjsu::build::Target)+0x2e>
    case Target::Application: result = "application"; break;
   105ca:	4b08      	ldr	r3, [pc, #32]	; (105ec <sjsu::build::Stringify(sjsu::build::Target)+0x44>)
   105cc:	60fb      	str	r3, [r7, #12]
   105ce:	e002      	b.n	105d6 <sjsu::build::Stringify(sjsu::build::Target)+0x2e>
    case Target::HostTest: result = "host test"; break;
   105d0:	4b07      	ldr	r3, [pc, #28]	; (105f0 <sjsu::build::Stringify(sjsu::build::Target)+0x48>)
   105d2:	60fb      	str	r3, [r7, #12]
   105d4:	bf00      	nop
  }
  return result;
   105d6:	68fb      	ldr	r3, [r7, #12]
}
   105d8:	4618      	mov	r0, r3
   105da:	3714      	adds	r7, #20
   105dc:	46bd      	mov	sp, r7
   105de:	f85d 7b04 	ldr.w	r7, [sp], #4
   105e2:	4770      	bx	lr
   105e4:	000148bc 	.word	0x000148bc
   105e8:	000148c0 	.word	0x000148c0
   105ec:	000148cc 	.word	0x000148cc
   105f0:	000148d8 	.word	0x000148d8

000105f4 <sjsu::debug::PrintAddressAsList(_Unwind_Context*, void*)>:
// ==============================================
// Hidden Backtrace Utility Functions
// ==============================================
static inline _Unwind_Reason_Code PrintAddressAsList(_Unwind_Context * context,
                                                     void * depth_pointer)
{
   105f4:	b580      	push	{r7, lr}
   105f6:	b084      	sub	sp, #16
   105f8:	af00      	add	r7, sp, #0
   105fa:	6078      	str	r0, [r7, #4]
   105fc:	6039      	str	r1, [r7, #0]
  int * depth      = static_cast<int *>(depth_pointer);
   105fe:	683b      	ldr	r3, [r7, #0]
   10600:	60fb      	str	r3, [r7, #12]
  intptr_t address = static_cast<intptr_t>(_Unwind_GetIP(context));
   10602:	210f      	movs	r1, #15
   10604:	6878      	ldr	r0, [r7, #4]
   10606:	f7ff ffbb 	bl	10580 <_Unwind_GetGR>
   1060a:	4603      	mov	r3, r0
   1060c:	f023 0301 	bic.w	r3, r3, #1
   10610:	60bb      	str	r3, [r7, #8]
  printf("  %d) 0x%08" PRIXPTR "\n", *depth,
   10612:	68fb      	ldr	r3, [r7, #12]
   10614:	6819      	ldr	r1, [r3, #0]
   10616:	68bb      	ldr	r3, [r7, #8]
   10618:	3b04      	subs	r3, #4
   1061a:	461a      	mov	r2, r3
   1061c:	4806      	ldr	r0, [pc, #24]	; (10638 <sjsu::debug::PrintAddressAsList(_Unwind_Context*, void*)+0x44>)
   1061e:	f002 ff49 	bl	134b4 <printf>
         address - config::kBacktraceAddressOffset);
  (*depth)++;
   10622:	68fb      	ldr	r3, [r7, #12]
   10624:	681b      	ldr	r3, [r3, #0]
   10626:	1c5a      	adds	r2, r3, #1
   10628:	68fb      	ldr	r3, [r7, #12]
   1062a:	601a      	str	r2, [r3, #0]
  return _URC_NO_REASON;
   1062c:	2300      	movs	r3, #0
}
   1062e:	4618      	mov	r0, r3
   10630:	3710      	adds	r7, #16
   10632:	46bd      	mov	sp, r7
   10634:	bd80      	pop	{r7, pc}
   10636:	bf00      	nop
   10638:	000148e4 	.word	0x000148e4

0001063c <sjsu::debug::PrintAddressInRow(_Unwind_Context*, void*)>:
static inline _Unwind_Reason_Code PrintAddressInRow(_Unwind_Context * context,
                                                    void * depth_pointer)
{
   1063c:	b580      	push	{r7, lr}
   1063e:	b084      	sub	sp, #16
   10640:	af00      	add	r7, sp, #0
   10642:	6078      	str	r0, [r7, #4]
   10644:	6039      	str	r1, [r7, #0]
  int * depth      = static_cast<int *>(depth_pointer);
   10646:	683b      	ldr	r3, [r7, #0]
   10648:	60fb      	str	r3, [r7, #12]
  intptr_t address = static_cast<intptr_t>(_Unwind_GetIP(context));
   1064a:	210f      	movs	r1, #15
   1064c:	6878      	ldr	r0, [r7, #4]
   1064e:	f7ff ff97 	bl	10580 <_Unwind_GetGR>
   10652:	4603      	mov	r3, r0
   10654:	f023 0301 	bic.w	r3, r3, #1
   10658:	60bb      	str	r3, [r7, #8]
  printf(" 0x%08" PRIXPTR, address - config::kBacktraceAddressOffset);
   1065a:	68bb      	ldr	r3, [r7, #8]
   1065c:	3b04      	subs	r3, #4
   1065e:	4619      	mov	r1, r3
   10660:	4806      	ldr	r0, [pc, #24]	; (1067c <sjsu::debug::PrintAddressInRow(_Unwind_Context*, void*)+0x40>)
   10662:	f002 ff27 	bl	134b4 <printf>
  (*depth)++;
   10666:	68fb      	ldr	r3, [r7, #12]
   10668:	681b      	ldr	r3, [r3, #0]
   1066a:	1c5a      	adds	r2, r3, #1
   1066c:	68fb      	ldr	r3, [r7, #12]
   1066e:	601a      	str	r2, [r3, #0]
  return _URC_NO_REASON;
   10670:	2300      	movs	r3, #0
}
   10672:	4618      	mov	r0, r3
   10674:	3710      	adds	r7, #16
   10676:	46bd      	mov	sp, r7
   10678:	bd80      	pop	{r7, pc}
   1067a:	bf00      	nop
   1067c:	000148f4 	.word	0x000148f4

00010680 <sjsu::debug::PrintBacktrace(bool, void*)>:
///        to print the file and line number that corrisponds to the printed
///        addresses.
/// @param length - the number of bytes to read from the starting location
inline void PrintBacktrace(bool show_make_command = false,
                           void * final_address   = nullptr)
{
   10680:	b580      	push	{r7, lr}
   10682:	b084      	sub	sp, #16
   10684:	af00      	add	r7, sp, #0
   10686:	4603      	mov	r3, r0
   10688:	6039      	str	r1, [r7, #0]
   1068a:	71fb      	strb	r3, [r7, #7]
  int depth = 0;
   1068c:	2300      	movs	r3, #0
   1068e:	60fb      	str	r3, [r7, #12]

  _Unwind_Backtrace(&PrintAddressAsList, &depth);
   10690:	f107 030c 	add.w	r3, r7, #12
   10694:	4619      	mov	r1, r3
   10696:	481a      	ldr	r0, [pc, #104]	; (10700 <sjsu::debug::PrintBacktrace(bool, void*)+0x80>)
   10698:	f003 fec6 	bl	14428 <_Unwind_Backtrace>
  if (final_address)
   1069c:	683b      	ldr	r3, [r7, #0]
   1069e:	2b00      	cmp	r3, #0
   106a0:	d005      	beq.n	106ae <sjsu::debug::PrintBacktrace(bool, void*)+0x2e>
  {
    printf("  %d) 0x%p\n", depth, final_address);
   106a2:	68fb      	ldr	r3, [r7, #12]
   106a4:	683a      	ldr	r2, [r7, #0]
   106a6:	4619      	mov	r1, r3
   106a8:	4816      	ldr	r0, [pc, #88]	; (10704 <sjsu::debug::PrintBacktrace(bool, void*)+0x84>)
   106aa:	f002 ff03 	bl	134b4 <printf>
  }

  if (show_make_command)
   106ae:	79fb      	ldrb	r3, [r7, #7]
   106b0:	2b00      	cmp	r3, #0
   106b2:	d020      	beq.n	106f6 <sjsu::debug::PrintBacktrace(bool, void*)+0x76>
  {
    printf("\nRun: the following command in your project directory");
   106b4:	4814      	ldr	r0, [pc, #80]	; (10708 <sjsu::debug::PrintBacktrace(bool, void*)+0x88>)
   106b6:	f002 fefd 	bl	134b4 <printf>
    printf("\n\n  " SJ2_BOLD_WHITE);
   106ba:	4814      	ldr	r0, [pc, #80]	; (1070c <sjsu::debug::PrintBacktrace(bool, void*)+0x8c>)
   106bc:	f002 fefa 	bl	134b4 <printf>
    printf("make stacktrace-%s TRACES=\"", Stringify(build::kTarget));
   106c0:	2001      	movs	r0, #1
   106c2:	f7ff ff71 	bl	105a8 <sjsu::build::Stringify(sjsu::build::Target)>
   106c6:	4603      	mov	r3, r0
   106c8:	4619      	mov	r1, r3
   106ca:	4811      	ldr	r0, [pc, #68]	; (10710 <sjsu::debug::PrintBacktrace(bool, void*)+0x90>)
   106cc:	f002 fef2 	bl	134b4 <printf>

    _Unwind_Backtrace(&PrintAddressInRow, &depth);
   106d0:	f107 030c 	add.w	r3, r7, #12
   106d4:	4619      	mov	r1, r3
   106d6:	480f      	ldr	r0, [pc, #60]	; (10714 <sjsu::debug::PrintBacktrace(bool, void*)+0x94>)
   106d8:	f003 fea6 	bl	14428 <_Unwind_Backtrace>
    if (final_address)
   106dc:	683b      	ldr	r3, [r7, #0]
   106de:	2b00      	cmp	r3, #0
   106e0:	d003      	beq.n	106ea <sjsu::debug::PrintBacktrace(bool, void*)+0x6a>
    {
      printf(" 0x%p", final_address);
   106e2:	6839      	ldr	r1, [r7, #0]
   106e4:	480c      	ldr	r0, [pc, #48]	; (10718 <sjsu::debug::PrintBacktrace(bool, void*)+0x98>)
   106e6:	f002 fee5 	bl	134b4 <printf>
    }

    printf("\"\n\n" SJ2_COLOR_RESET);
   106ea:	480c      	ldr	r0, [pc, #48]	; (1071c <sjsu::debug::PrintBacktrace(bool, void*)+0x9c>)
   106ec:	f002 fee2 	bl	134b4 <printf>
    printf(
   106f0:	480b      	ldr	r0, [pc, #44]	; (10720 <sjsu::debug::PrintBacktrace(bool, void*)+0xa0>)
   106f2:	f002 fedf 	bl	134b4 <printf>
        "This will report the file and line number that led to this function "
        "being called.");
  }
}
   106f6:	bf00      	nop
   106f8:	3710      	adds	r7, #16
   106fa:	46bd      	mov	sp, r7
   106fc:	bd80      	pop	{r7, pc}
   106fe:	bf00      	nop
   10700:	000105f5 	.word	0x000105f5
   10704:	000148fc 	.word	0x000148fc
   10708:	00014908 	.word	0x00014908
   1070c:	00014940 	.word	0x00014940
   10710:	0001494c 	.word	0x0001494c
   10714:	0001063d 	.word	0x0001063d
   10718:	00014968 	.word	0x00014968
   1071c:	00014970 	.word	0x00014970
   10720:	00014978 	.word	0x00014978

00010724 <sjsu::(anonymous namespace)::DefaultUptime()>:
{
// uptime in microseconds
inline uint64_t uptime = 0;
// Returns the system uptime in microseconds, do not use this function directly
[[gnu::always_inline]] inline uint64_t DefaultUptime()
{
   10724:	b490      	push	{r4, r7}
   10726:	af00      	add	r7, sp, #0
  return uptime;
   10728:	4b03      	ldr	r3, [pc, #12]	; (10738 <sjsu::(anonymous namespace)::DefaultUptime()+0x14>)
   1072a:	e9d3 3400 	ldrd	r3, r4, [r3]
}
   1072e:	4618      	mov	r0, r3
   10730:	4621      	mov	r1, r4
   10732:	46bd      	mov	sp, r7
   10734:	bc90      	pop	{r4, r7}
   10736:	4770      	bx	lr
   10738:	10000210 	.word	0x10000210

0001073c <sjsu::Milliseconds()>:
{
  Uptime = uptime_function;
}
// Get system uptime in milliseconds as a 64-bit integer
inline uint64_t Milliseconds()
{
   1073c:	b598      	push	{r3, r4, r7, lr}
   1073e:	af00      	add	r7, sp, #0
  return Uptime() / 1'000;
   10740:	4b06      	ldr	r3, [pc, #24]	; (1075c <sjsu::Milliseconds()+0x20>)
   10742:	681b      	ldr	r3, [r3, #0]
   10744:	4798      	blx	r3
   10746:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   1074a:	f04f 0300 	mov.w	r3, #0
   1074e:	f002 ff33 	bl	135b8 <__aeabi_uldivmod>
   10752:	4603      	mov	r3, r0
   10754:	460c      	mov	r4, r1
}
   10756:	4618      	mov	r0, r3
   10758:	4621      	mov	r1, r4
   1075a:	bd98      	pop	{r3, r4, r7, pc}
   1075c:	10000004 	.word	0x10000004

00010760 <sjsu::Wait(unsigned long long)::{lambda()#1}::operator()() const>:
  return status;
}

inline Status Wait(uint64_t timeout)
{
  return Wait(timeout, []() -> bool { return false; });
   10760:	b480      	push	{r7}
   10762:	b083      	sub	sp, #12
   10764:	af00      	add	r7, sp, #0
   10766:	6078      	str	r0, [r7, #4]
   10768:	2300      	movs	r3, #0
   1076a:	4618      	mov	r0, r3
   1076c:	370c      	adds	r7, #12
   1076e:	46bd      	mov	sp, r7
   10770:	f85d 7b04 	ldr.w	r7, [sp], #4
   10774:	4770      	bx	lr

00010776 <sjsu::Wait(unsigned long long)::{lambda()#1}::_FUN()>:
   10776:	b580      	push	{r7, lr}
   10778:	af00      	add	r7, sp, #0
   1077a:	2000      	movs	r0, #0
   1077c:	f7ff fff0 	bl	10760 <sjsu::Wait(unsigned long long)::{lambda()#1}::operator()() const>
   10780:	4603      	mov	r3, r0
   10782:	4618      	mov	r0, r3
   10784:	bd80      	pop	{r7, pc}

00010786 <sjsu::Wait(unsigned long long)>:
{
   10786:	b5f0      	push	{r4, r5, r6, r7, lr}
   10788:	b089      	sub	sp, #36	; 0x24
   1078a:	af00      	add	r7, sp, #0
   1078c:	e9c7 0100 	strd	r0, r1, [r7]
   10790:	e9d7 3400 	ldrd	r3, r4, [r7]
   10794:	e9c7 3406 	strd	r3, r4, [r7, #24]
   10798:	723a      	strb	r2, [r7, #8]
  uint64_t timeout_time = 0;
   1079a:	f04f 0300 	mov.w	r3, #0
   1079e:	f04f 0400 	mov.w	r4, #0
   107a2:	e9c7 3404 	strd	r3, r4, [r7, #16]
  if (timeout == kMaxWait)
   107a6:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
   107aa:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   107ae:	bf08      	it	eq
   107b0:	f1b3 3fff 	cmpeq.w	r3, #4294967295	; 0xffffffff
   107b4:	d106      	bne.n	107c4 <sjsu::Wait(unsigned long long)+0x3e>
    timeout_time = kMaxWait;
   107b6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   107ba:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   107be:	e9c7 3404 	strd	r3, r4, [r7, #16]
   107c2:	e00a      	b.n	107da <sjsu::Wait(unsigned long long)+0x54>
    timeout_time = Milliseconds() + timeout;
   107c4:	f7ff ffba 	bl	1073c <sjsu::Milliseconds()>
   107c8:	460a      	mov	r2, r1
   107ca:	4601      	mov	r1, r0
   107cc:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
   107d0:	185d      	adds	r5, r3, r1
   107d2:	eb44 0602 	adc.w	r6, r4, r2
   107d6:	e9c7 5604 	strd	r5, r6, [r7, #16]
  Status status = Status::kTimedOut;
   107da:	2301      	movs	r3, #1
   107dc:	60fb      	str	r3, [r7, #12]
  while (Milliseconds() < timeout_time)
   107de:	f7ff ffad 	bl	1073c <sjsu::Milliseconds()>
   107e2:	460a      	mov	r2, r1
   107e4:	4601      	mov	r1, r0
   107e6:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
   107ea:	42a2      	cmp	r2, r4
   107ec:	bf08      	it	eq
   107ee:	4299      	cmpeq	r1, r3
   107f0:	bf34      	ite	cc
   107f2:	2301      	movcc	r3, #1
   107f4:	2300      	movcs	r3, #0
   107f6:	b2db      	uxtb	r3, r3
   107f8:	2b00      	cmp	r3, #0
   107fa:	d009      	beq.n	10810 <sjsu::Wait(unsigned long long)+0x8a>
    if (is_done())
   107fc:	f107 0308 	add.w	r3, r7, #8
   10800:	4618      	mov	r0, r3
   10802:	f7ff ffad 	bl	10760 <sjsu::Wait(unsigned long long)::{lambda()#1}::operator()() const>
   10806:	4603      	mov	r3, r0
   10808:	2b00      	cmp	r3, #0
   1080a:	d0e8      	beq.n	107de <sjsu::Wait(unsigned long long)+0x58>
      status = Status::kSuccess;
   1080c:	2300      	movs	r3, #0
   1080e:	60fb      	str	r3, [r7, #12]
  return status;
   10810:	68fb      	ldr	r3, [r7, #12]
}
   10812:	4618      	mov	r0, r3
   10814:	3724      	adds	r7, #36	; 0x24
   10816:	46bd      	mov	sp, r7
   10818:	bdf0      	pop	{r4, r5, r6, r7, pc}

0001081a <sjsu::Delay(unsigned long long)>:

// Delay the system for a duration of time
inline void Delay([[maybe_unused]] uint64_t delay_time_ms)
{
   1081a:	b580      	push	{r7, lr}
   1081c:	b082      	sub	sp, #8
   1081e:	af00      	add	r7, sp, #0
   10820:	e9c7 0100 	strd	r0, r1, [r7]
#if defined(HOST_TEST)
  return;
#else
  Wait(delay_time_ms);
   10824:	e9d7 0100 	ldrd	r0, r1, [r7]
   10828:	f7ff ffad 	bl	10786 <sjsu::Wait(unsigned long long)>
#endif  // HOST_TEST
}
   1082c:	bf00      	nop
   1082e:	3708      	adds	r7, #8
   10830:	46bd      	mov	sp, r7
   10832:	bd80      	pop	{r7, pc}

00010834 <sjsu::lpc40xx::Gpio::SetAsInput() const>:
      : interupt_port_(0), pin_(port_number, pin_number)
  {
    interupt_port_ = (port_number == 2) ? 1 : 0;
  }
  // Sets the GPIO pin direction as input
  void SetAsInput() const
   10834:	b580      	push	{r7, lr}
   10836:	b084      	sub	sp, #16
   10838:	af00      	add	r7, sp, #0
   1083a:	6078      	str	r0, [r7, #4]
  {
    pin_.SetPinFunction(kGpioFunction);
   1083c:	687b      	ldr	r3, [r7, #4]
   1083e:	3308      	adds	r3, #8
   10840:	2100      	movs	r1, #0
   10842:	4618      	mov	r0, r3
   10844:	f7ff fd9a 	bl	1037c <sjsu::lpc40xx::Pin::SetPinFunction(unsigned char) const>
    gpio_port[pin_.GetPort()]->DIR &= ~(1 << pin_.GetPin());
   10848:	687b      	ldr	r3, [r7, #4]
   1084a:	3308      	adds	r3, #8
   1084c:	60bb      	str	r3, [r7, #8]
   1084e:	68bb      	ldr	r3, [r7, #8]
   10850:	795b      	ldrb	r3, [r3, #5]
   10852:	461a      	mov	r2, r3
   10854:	2301      	movs	r3, #1
   10856:	4093      	lsls	r3, r2
   10858:	43d9      	mvns	r1, r3
   1085a:	687b      	ldr	r3, [r7, #4]
   1085c:	3308      	adds	r3, #8
   1085e:	60fb      	str	r3, [r7, #12]
    return port_;
   10860:	68fb      	ldr	r3, [r7, #12]
   10862:	791b      	ldrb	r3, [r3, #4]
   10864:	461a      	mov	r2, r3
   10866:	4b05      	ldr	r3, [pc, #20]	; (1087c <sjsu::lpc40xx::Gpio::SetAsInput() const+0x48>)
   10868:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1086c:	681a      	ldr	r2, [r3, #0]
   1086e:	400a      	ands	r2, r1
   10870:	601a      	str	r2, [r3, #0]
  }
   10872:	bf00      	nop
   10874:	3710      	adds	r7, #16
   10876:	46bd      	mov	sp, r7
   10878:	bd80      	pop	{r7, pc}
   1087a:	bf00      	nop
   1087c:	10000008 	.word	0x10000008

00010880 <sjsu::lpc40xx::Gpio::SetAsOutput() const>:
  // Sets the GPIO pin direction as output
  void SetAsOutput() const
   10880:	b580      	push	{r7, lr}
   10882:	b084      	sub	sp, #16
   10884:	af00      	add	r7, sp, #0
   10886:	6078      	str	r0, [r7, #4]
  {
    pin_.SetPinFunction(kGpioFunction);
   10888:	687b      	ldr	r3, [r7, #4]
   1088a:	3308      	adds	r3, #8
   1088c:	2100      	movs	r1, #0
   1088e:	4618      	mov	r0, r3
   10890:	f7ff fd74 	bl	1037c <sjsu::lpc40xx::Pin::SetPinFunction(unsigned char) const>
    gpio_port[pin_.GetPort()]->DIR |= (1 << pin_.GetPin());
   10894:	687b      	ldr	r3, [r7, #4]
   10896:	3308      	adds	r3, #8
   10898:	60bb      	str	r3, [r7, #8]
    return pin_;
   1089a:	68bb      	ldr	r3, [r7, #8]
   1089c:	795b      	ldrb	r3, [r3, #5]
   1089e:	461a      	mov	r2, r3
   108a0:	2301      	movs	r3, #1
   108a2:	fa03 f102 	lsl.w	r1, r3, r2
   108a6:	687b      	ldr	r3, [r7, #4]
   108a8:	3308      	adds	r3, #8
   108aa:	60fb      	str	r3, [r7, #12]
    return port_;
   108ac:	68fb      	ldr	r3, [r7, #12]
   108ae:	791b      	ldrb	r3, [r3, #4]
   108b0:	461a      	mov	r2, r3
   108b2:	4b05      	ldr	r3, [pc, #20]	; (108c8 <sjsu::lpc40xx::Gpio::SetAsOutput() const+0x48>)
   108b4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   108b8:	681a      	ldr	r2, [r3, #0]
   108ba:	430a      	orrs	r2, r1
   108bc:	601a      	str	r2, [r3, #0]
  }
   108be:	bf00      	nop
   108c0:	3710      	adds	r7, #16
   108c2:	46bd      	mov	sp, r7
   108c4:	bd80      	pop	{r7, pc}
   108c6:	bf00      	nop
   108c8:	10000008 	.word	0x10000008

000108cc <sjsu::lpc40xx::Gpio::SetDirection(sjsu::Gpio::Direction) const>:
  // Sets the GPIO pin direction as output or input depending on the
  // Direction enum parameter
  inline void SetDirection(Direction direction) const override
   108cc:	b580      	push	{r7, lr}
   108ce:	b082      	sub	sp, #8
   108d0:	af00      	add	r7, sp, #0
   108d2:	6078      	str	r0, [r7, #4]
   108d4:	460b      	mov	r3, r1
   108d6:	70fb      	strb	r3, [r7, #3]
  {
    (direction) ? SetAsOutput() : SetAsInput();
   108d8:	78fb      	ldrb	r3, [r7, #3]
   108da:	2b00      	cmp	r3, #0
   108dc:	d003      	beq.n	108e6 <sjsu::lpc40xx::Gpio::SetDirection(sjsu::Gpio::Direction) const+0x1a>
   108de:	6878      	ldr	r0, [r7, #4]
   108e0:	f7ff ffce 	bl	10880 <sjsu::lpc40xx::Gpio::SetAsOutput() const>
  }
   108e4:	e002      	b.n	108ec <sjsu::lpc40xx::Gpio::SetDirection(sjsu::Gpio::Direction) const+0x20>
    (direction) ? SetAsOutput() : SetAsInput();
   108e6:	6878      	ldr	r0, [r7, #4]
   108e8:	f7ff ffa4 	bl	10834 <sjsu::lpc40xx::Gpio::SetAsInput() const>
  }
   108ec:	bf00      	nop
   108ee:	3708      	adds	r7, #8
   108f0:	46bd      	mov	sp, r7
   108f2:	bd80      	pop	{r7, pc}

000108f4 <sjsu::lpc40xx::Gpio::SetHigh() const>:
  // Sets the GPIO output pin to high
  void SetHigh() const
   108f4:	b480      	push	{r7}
   108f6:	b085      	sub	sp, #20
   108f8:	af00      	add	r7, sp, #0
   108fa:	6078      	str	r0, [r7, #4]
  {
    gpio_port[pin_.GetPort()]->SET = (1 << pin_.GetPin());
   108fc:	687b      	ldr	r3, [r7, #4]
   108fe:	3308      	adds	r3, #8
   10900:	60bb      	str	r3, [r7, #8]
    return pin_;
   10902:	68bb      	ldr	r3, [r7, #8]
   10904:	795b      	ldrb	r3, [r3, #5]
   10906:	461a      	mov	r2, r3
   10908:	2301      	movs	r3, #1
   1090a:	4093      	lsls	r3, r2
   1090c:	461a      	mov	r2, r3
   1090e:	687b      	ldr	r3, [r7, #4]
   10910:	3308      	adds	r3, #8
   10912:	60fb      	str	r3, [r7, #12]
    return port_;
   10914:	68fb      	ldr	r3, [r7, #12]
   10916:	791b      	ldrb	r3, [r3, #4]
   10918:	4619      	mov	r1, r3
   1091a:	4b05      	ldr	r3, [pc, #20]	; (10930 <sjsu::lpc40xx::Gpio::SetHigh() const+0x3c>)
   1091c:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   10920:	619a      	str	r2, [r3, #24]
  }
   10922:	bf00      	nop
   10924:	3714      	adds	r7, #20
   10926:	46bd      	mov	sp, r7
   10928:	f85d 7b04 	ldr.w	r7, [sp], #4
   1092c:	4770      	bx	lr
   1092e:	bf00      	nop
   10930:	10000008 	.word	0x10000008

00010934 <sjsu::lpc40xx::Gpio::SetLow() const>:
  // Sets the GPIO output pin to low
  void SetLow() const
   10934:	b480      	push	{r7}
   10936:	b085      	sub	sp, #20
   10938:	af00      	add	r7, sp, #0
   1093a:	6078      	str	r0, [r7, #4]
  {
    gpio_port[pin_.GetPort()]->CLR = (1 << pin_.GetPin());
   1093c:	687b      	ldr	r3, [r7, #4]
   1093e:	3308      	adds	r3, #8
   10940:	60bb      	str	r3, [r7, #8]
    return pin_;
   10942:	68bb      	ldr	r3, [r7, #8]
   10944:	795b      	ldrb	r3, [r3, #5]
   10946:	461a      	mov	r2, r3
   10948:	2301      	movs	r3, #1
   1094a:	4093      	lsls	r3, r2
   1094c:	461a      	mov	r2, r3
   1094e:	687b      	ldr	r3, [r7, #4]
   10950:	3308      	adds	r3, #8
   10952:	60fb      	str	r3, [r7, #12]
    return port_;
   10954:	68fb      	ldr	r3, [r7, #12]
   10956:	791b      	ldrb	r3, [r3, #4]
   10958:	4619      	mov	r1, r3
   1095a:	4b05      	ldr	r3, [pc, #20]	; (10970 <sjsu::lpc40xx::Gpio::SetLow() const+0x3c>)
   1095c:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   10960:	61da      	str	r2, [r3, #28]
  }
   10962:	bf00      	nop
   10964:	3714      	adds	r7, #20
   10966:	46bd      	mov	sp, r7
   10968:	f85d 7b04 	ldr.w	r7, [sp], #4
   1096c:	4770      	bx	lr
   1096e:	bf00      	nop
   10970:	10000008 	.word	0x10000008

00010974 <sjsu::lpc40xx::Gpio::Set(sjsu::Gpio::State) const>:
  // Sets the GPIO output pin to high or low depending on the State enum
  // parameter
  void Set(State output = kHigh) const override
   10974:	b580      	push	{r7, lr}
   10976:	b082      	sub	sp, #8
   10978:	af00      	add	r7, sp, #0
   1097a:	6078      	str	r0, [r7, #4]
   1097c:	460b      	mov	r3, r1
   1097e:	70fb      	strb	r3, [r7, #3]
  {
    (output) ? SetHigh() : SetLow();
   10980:	78fb      	ldrb	r3, [r7, #3]
   10982:	2b00      	cmp	r3, #0
   10984:	d003      	beq.n	1098e <sjsu::lpc40xx::Gpio::Set(sjsu::Gpio::State) const+0x1a>
   10986:	6878      	ldr	r0, [r7, #4]
   10988:	f7ff ffb4 	bl	108f4 <sjsu::lpc40xx::Gpio::SetHigh() const>
  }
   1098c:	e002      	b.n	10994 <sjsu::lpc40xx::Gpio::Set(sjsu::Gpio::State) const+0x20>
    (output) ? SetHigh() : SetLow();
   1098e:	6878      	ldr	r0, [r7, #4]
   10990:	f7ff ffd0 	bl	10934 <sjsu::lpc40xx::Gpio::SetLow() const>
  }
   10994:	bf00      	nop
   10996:	3708      	adds	r7, #8
   10998:	46bd      	mov	sp, r7
   1099a:	bd80      	pop	{r7, pc}

0001099c <sjsu::lpc40xx::Gpio::Toggle() const>:
  // Toggle the output of a GPIO output pin
  void Toggle() const override
   1099c:	b480      	push	{r7}
   1099e:	b085      	sub	sp, #20
   109a0:	af00      	add	r7, sp, #0
   109a2:	6078      	str	r0, [r7, #4]
  {
    gpio_port[pin_.GetPort()]->PIN ^= (1 << pin_.GetPin());
   109a4:	687b      	ldr	r3, [r7, #4]
   109a6:	3308      	adds	r3, #8
   109a8:	60bb      	str	r3, [r7, #8]
    return pin_;
   109aa:	68bb      	ldr	r3, [r7, #8]
   109ac:	795b      	ldrb	r3, [r3, #5]
   109ae:	461a      	mov	r2, r3
   109b0:	2301      	movs	r3, #1
   109b2:	fa03 f102 	lsl.w	r1, r3, r2
   109b6:	687b      	ldr	r3, [r7, #4]
   109b8:	3308      	adds	r3, #8
   109ba:	60fb      	str	r3, [r7, #12]
    return port_;
   109bc:	68fb      	ldr	r3, [r7, #12]
   109be:	791b      	ldrb	r3, [r3, #4]
   109c0:	461a      	mov	r2, r3
   109c2:	4b06      	ldr	r3, [pc, #24]	; (109dc <sjsu::lpc40xx::Gpio::Toggle() const+0x40>)
   109c4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   109c8:	695a      	ldr	r2, [r3, #20]
   109ca:	404a      	eors	r2, r1
   109cc:	615a      	str	r2, [r3, #20]
  }
   109ce:	bf00      	nop
   109d0:	3714      	adds	r7, #20
   109d2:	46bd      	mov	sp, r7
   109d4:	f85d 7b04 	ldr.w	r7, [sp], #4
   109d8:	4770      	bx	lr
   109da:	bf00      	nop
   109dc:	10000008 	.word	0x10000008

000109e0 <sjsu::lpc40xx::Gpio::ReadState() const>:
  // Returns the current State state of the pin
  State ReadState() const override
   109e0:	b580      	push	{r7, lr}
   109e2:	b082      	sub	sp, #8
   109e4:	af00      	add	r7, sp, #0
   109e6:	6078      	str	r0, [r7, #4]
  {
    return static_cast<State>(Read());
   109e8:	6878      	ldr	r0, [r7, #4]
   109ea:	f000 f805 	bl	109f8 <sjsu::lpc40xx::Gpio::Read() const>
   109ee:	4603      	mov	r3, r0
  }
   109f0:	4618      	mov	r0, r3
   109f2:	3708      	adds	r7, #8
   109f4:	46bd      	mov	sp, r7
   109f6:	bd80      	pop	{r7, pc}

000109f8 <sjsu::lpc40xx::Gpio::Read() const>:
  // Returns true if input or output pin is high
  bool Read() const override
   109f8:	b480      	push	{r7}
   109fa:	b085      	sub	sp, #20
   109fc:	af00      	add	r7, sp, #0
   109fe:	6078      	str	r0, [r7, #4]
  {
    return (gpio_port[pin_.GetPort()]->PIN >> pin_.GetPin()) & 1;
   10a00:	687b      	ldr	r3, [r7, #4]
   10a02:	3308      	adds	r3, #8
   10a04:	60bb      	str	r3, [r7, #8]
   10a06:	68bb      	ldr	r3, [r7, #8]
   10a08:	791b      	ldrb	r3, [r3, #4]
   10a0a:	461a      	mov	r2, r3
   10a0c:	4b0b      	ldr	r3, [pc, #44]	; (10a3c <sjsu::lpc40xx::Gpio::Read() const+0x44>)
   10a0e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   10a12:	695b      	ldr	r3, [r3, #20]
   10a14:	687a      	ldr	r2, [r7, #4]
   10a16:	3208      	adds	r2, #8
   10a18:	60fa      	str	r2, [r7, #12]
    return pin_;
   10a1a:	68fa      	ldr	r2, [r7, #12]
   10a1c:	7952      	ldrb	r2, [r2, #5]
   10a1e:	40d3      	lsrs	r3, r2
   10a20:	f003 0301 	and.w	r3, r3, #1
   10a24:	2b00      	cmp	r3, #0
   10a26:	bf14      	ite	ne
   10a28:	2301      	movne	r3, #1
   10a2a:	2300      	moveq	r3, #0
   10a2c:	b2db      	uxtb	r3, r3
  }
   10a2e:	4618      	mov	r0, r3
   10a30:	3714      	adds	r7, #20
   10a32:	46bd      	mov	sp, r7
   10a34:	f85d 7b04 	ldr.w	r7, [sp], #4
   10a38:	4770      	bx	lr
   10a3a:	bf00      	nop
   10a3c:	10000008 	.word	0x10000008

00010a40 <sjsu::lpc40xx::Gpio::GetPin() const>:
  const sjsu::Pin & GetPin() const override
   10a40:	b480      	push	{r7}
   10a42:	b083      	sub	sp, #12
   10a44:	af00      	add	r7, sp, #0
   10a46:	6078      	str	r0, [r7, #4]
  {
    return pin_;
   10a48:	687b      	ldr	r3, [r7, #4]
   10a4a:	3308      	adds	r3, #8
  }
   10a4c:	4618      	mov	r0, r3
   10a4e:	370c      	adds	r7, #12
   10a50:	46bd      	mov	sp, r7
   10a52:	f85d 7b04 	ldr.w	r7, [sp], #4
   10a56:	4770      	bx	lr

00010a58 <sjsu::lpc40xx::Gpio::ValidPortCheck() const>:

  // Checks if the selected gpio port is valid for external interrupts.
  bool ValidPortCheck() const
   10a58:	b580      	push	{r7, lr}
   10a5a:	b086      	sub	sp, #24
   10a5c:	af02      	add	r7, sp, #8
   10a5e:	6078      	str	r0, [r7, #4]
  {
    bool is_valid = (interupt_port_ <= 1);
   10a60:	687b      	ldr	r3, [r7, #4]
   10a62:	791b      	ldrb	r3, [r3, #4]
   10a64:	2b01      	cmp	r3, #1
   10a66:	bf94      	ite	ls
   10a68:	2301      	movls	r3, #1
   10a6a:	2300      	movhi	r3, #0
   10a6c:	b2db      	uxtb	r3, r3
   10a6e:	72fb      	strb	r3, [r7, #11]
    SJ2_ASSERT_WARNING(is_valid,
   10a70:	7afb      	ldrb	r3, [r7, #11]
   10a72:	f083 0301 	eor.w	r3, r3, #1
   10a76:	b2db      	uxtb	r3, r3
   10a78:	2b00      	cmp	r3, #0
   10a7a:	d00b      	beq.n	10a94 <sjsu::lpc40xx::Gpio::ValidPortCheck() const+0x3c>
   10a7c:	687b      	ldr	r3, [r7, #4]
   10a7e:	3308      	adds	r3, #8
   10a80:	60fb      	str	r3, [r7, #12]
    return port_;
   10a82:	68fb      	ldr	r3, [r7, #12]
   10a84:	791b      	ldrb	r3, [r3, #4]
   10a86:	9300      	str	r3, [sp, #0]
   10a88:	237f      	movs	r3, #127	; 0x7f
   10a8a:	4a05      	ldr	r2, [pc, #20]	; (10aa0 <sjsu::lpc40xx::Gpio::ValidPortCheck() const+0x48>)
   10a8c:	4905      	ldr	r1, [pc, #20]	; (10aa4 <sjsu::lpc40xx::Gpio::ValidPortCheck() const+0x4c>)
   10a8e:	4806      	ldr	r0, [pc, #24]	; (10aa8 <sjsu::lpc40xx::Gpio::ValidPortCheck() const+0x50>)
   10a90:	f002 fd10 	bl	134b4 <printf>
                       "Port %d cannot be used for External Interrupts. Need "
                       "to use GPIO on Port 0 or 2.",
                       pin_.GetPort());
    return is_valid;
   10a94:	7afb      	ldrb	r3, [r7, #11]
  }
   10a96:	4618      	mov	r0, r3
   10a98:	3710      	adds	r7, #16
   10a9a:	46bd      	mov	sp, r7
   10a9c:	bd80      	pop	{r7, pc}
   10a9e:	bf00      	nop
   10aa0:	00014e10 	.word	0x00014e10
   10aa4:	00014d4c 	.word	0x00014d4c
   10aa8:	000149cc 	.word	0x000149cc

00010aac <sjsu::lpc40xx::Gpio::SetInterruptRoutine(void (*)()) const>:

  // Assigns the developer's ISR function to the port/pin gpio instance.
  void SetInterruptRoutine(IsrPointer function) const
   10aac:	b590      	push	{r4, r7, lr}
   10aae:	b085      	sub	sp, #20
   10ab0:	af00      	add	r7, sp, #0
   10ab2:	6078      	str	r0, [r7, #4]
   10ab4:	6039      	str	r1, [r7, #0]
  {
    ValidPortCheck();
   10ab6:	6878      	ldr	r0, [r7, #4]
   10ab8:	f7ff ffce 	bl	10a58 <sjsu::lpc40xx::Gpio::ValidPortCheck() const>
    interrupthandlers[interupt_port_][pin_.GetPin()] = function;
   10abc:	683a      	ldr	r2, [r7, #0]
   10abe:	687b      	ldr	r3, [r7, #4]
   10ac0:	791b      	ldrb	r3, [r3, #4]
   10ac2:	461c      	mov	r4, r3
   10ac4:	687b      	ldr	r3, [r7, #4]
   10ac6:	3308      	adds	r3, #8
   10ac8:	60fb      	str	r3, [r7, #12]
    return pin_;
   10aca:	68fb      	ldr	r3, [r7, #12]
   10acc:	795b      	ldrb	r3, [r3, #5]
   10ace:	4618      	mov	r0, r3
   10ad0:	4904      	ldr	r1, [pc, #16]	; (10ae4 <sjsu::lpc40xx::Gpio::SetInterruptRoutine(void (*)()) const+0x38>)
   10ad2:	0163      	lsls	r3, r4, #5
   10ad4:	4403      	add	r3, r0
   10ad6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
   10ada:	bf00      	nop
   10adc:	3714      	adds	r7, #20
   10ade:	46bd      	mov	sp, r7
   10ae0:	bd90      	pop	{r4, r7, pc}
   10ae2:	bf00      	nop
   10ae4:	10000218 	.word	0x10000218

00010ae8 <sjsu::lpc40xx::Gpio::ClearInterruptRoutine() const>:

  // Clears the developers ISR function from the port/pin gio instance.
  void ClearInterruptRoutine() const
   10ae8:	b480      	push	{r7}
   10aea:	b085      	sub	sp, #20
   10aec:	af00      	add	r7, sp, #0
   10aee:	6078      	str	r0, [r7, #4]
  {
    interrupthandlers[interupt_port_][pin_.GetPin()] = nullptr;
   10af0:	687b      	ldr	r3, [r7, #4]
   10af2:	791b      	ldrb	r3, [r3, #4]
   10af4:	4618      	mov	r0, r3
   10af6:	687b      	ldr	r3, [r7, #4]
   10af8:	3308      	adds	r3, #8
   10afa:	60fb      	str	r3, [r7, #12]
   10afc:	68fb      	ldr	r3, [r7, #12]
   10afe:	795b      	ldrb	r3, [r3, #5]
   10b00:	4619      	mov	r1, r3
   10b02:	4a06      	ldr	r2, [pc, #24]	; (10b1c <sjsu::lpc40xx::Gpio::ClearInterruptRoutine() const+0x34>)
   10b04:	0143      	lsls	r3, r0, #5
   10b06:	440b      	add	r3, r1
   10b08:	2100      	movs	r1, #0
   10b0a:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
  }
   10b0e:	bf00      	nop
   10b10:	3714      	adds	r7, #20
   10b12:	46bd      	mov	sp, r7
   10b14:	f85d 7b04 	ldr.w	r7, [sp], #4
   10b18:	4770      	bx	lr
   10b1a:	bf00      	nop
   10b1c:	10000218 	.word	0x10000218

00010b20 <unsigned char sjsu::util::Value<sjsu::Gpio::Edge, unsigned char>(sjsu::Gpio::Edge)>:
constexpr Type Value(Enum enum_type_value)
   10b20:	b480      	push	{r7}
   10b22:	b083      	sub	sp, #12
   10b24:	af00      	add	r7, sp, #0
   10b26:	4603      	mov	r3, r0
   10b28:	71fb      	strb	r3, [r7, #7]
  return static_cast<Type>(enum_type_value);
   10b2a:	79fb      	ldrb	r3, [r7, #7]
}
   10b2c:	4618      	mov	r0, r3
   10b2e:	370c      	adds	r7, #12
   10b30:	46bd      	mov	sp, r7
   10b32:	f85d 7b04 	ldr.w	r7, [sp], #4
   10b36:	4770      	bx	lr

00010b38 <sjsu::lpc40xx::Gpio::SetInterruptEdge(sjsu::Gpio::Edge) const>:

  // Sets the selected edge that the gpio interrupt will be triggered on.
  void SetInterruptEdge(Edge edge) const
   10b38:	b580      	push	{r7, lr}
   10b3a:	b084      	sub	sp, #16
   10b3c:	af02      	add	r7, sp, #8
   10b3e:	6078      	str	r0, [r7, #4]
   10b40:	460b      	mov	r3, r1
   10b42:	70fb      	strb	r3, [r7, #3]
  {
    ValidPortCheck();
   10b44:	6878      	ldr	r0, [r7, #4]
   10b46:	f7ff ff87 	bl	10a58 <sjsu::lpc40xx::Gpio::ValidPortCheck() const>
    switch (edge)
   10b4a:	78fb      	ldrb	r3, [r7, #3]
   10b4c:	2b01      	cmp	r3, #1
   10b4e:	d008      	beq.n	10b62 <sjsu::lpc40xx::Gpio::SetInterruptEdge(sjsu::Gpio::Edge) const+0x2a>
   10b50:	2b01      	cmp	r3, #1
   10b52:	d302      	bcc.n	10b5a <sjsu::lpc40xx::Gpio::SetInterruptEdge(sjsu::Gpio::Edge) const+0x22>
   10b54:	2b02      	cmp	r3, #2
   10b56:	d008      	beq.n	10b6a <sjsu::lpc40xx::Gpio::SetInterruptEdge(sjsu::Gpio::Edge) const+0x32>
   10b58:	e00e      	b.n	10b78 <sjsu::lpc40xx::Gpio::SetInterruptEdge(sjsu::Gpio::Edge) const+0x40>
    {
      case Edge::kEdgeRising:
      {
        SetEdgeRising();
   10b5a:	6878      	ldr	r0, [r7, #4]
   10b5c:	f000 f84e 	bl	10bfc <sjsu::lpc40xx::Gpio::SetEdgeRising() const>
        break;
   10b60:	e016      	b.n	10b90 <sjsu::lpc40xx::Gpio::SetInterruptEdge(sjsu::Gpio::Edge) const+0x58>
      }
      case Edge::kEdgeFalling:
      {
        SetEdgeFalling();
   10b62:	6878      	ldr	r0, [r7, #4]
   10b64:	f000 f878 	bl	10c58 <sjsu::lpc40xx::Gpio::SetEdgeFalling() const>
        break;
   10b68:	e012      	b.n	10b90 <sjsu::lpc40xx::Gpio::SetInterruptEdge(sjsu::Gpio::Edge) const+0x58>
      }
      case Edge::kEdgeBoth:
      {
        SetEdgeRising();
   10b6a:	6878      	ldr	r0, [r7, #4]
   10b6c:	f000 f846 	bl	10bfc <sjsu::lpc40xx::Gpio::SetEdgeRising() const>
        SetEdgeFalling();
   10b70:	6878      	ldr	r0, [r7, #4]
   10b72:	f000 f871 	bl	10c58 <sjsu::lpc40xx::Gpio::SetEdgeFalling() const>
        break;
   10b76:	e00b      	b.n	10b90 <sjsu::lpc40xx::Gpio::SetInterruptEdge(sjsu::Gpio::Edge) const+0x58>
      }
      default:
      {
        LOG_WARNING(
   10b78:	78fb      	ldrb	r3, [r7, #3]
   10b7a:	4618      	mov	r0, r3
   10b7c:	f7ff ffd0 	bl	10b20 <unsigned char sjsu::util::Value<sjsu::Gpio::Edge, unsigned char>(sjsu::Gpio::Edge)>
   10b80:	4603      	mov	r3, r0
   10b82:	9300      	str	r3, [sp, #0]
   10b84:	23ab      	movs	r3, #171	; 0xab
   10b86:	4a04      	ldr	r2, [pc, #16]	; (10b98 <sjsu::lpc40xx::Gpio::SetInterruptEdge(sjsu::Gpio::Edge) const+0x60>)
   10b88:	4904      	ldr	r1, [pc, #16]	; (10b9c <sjsu::lpc40xx::Gpio::SetInterruptEdge(sjsu::Gpio::Edge) const+0x64>)
   10b8a:	4805      	ldr	r0, [pc, #20]	; (10ba0 <sjsu::lpc40xx::Gpio::SetInterruptEdge(sjsu::Gpio::Edge) const+0x68>)
   10b8c:	f002 fc92 	bl	134b4 <printf>
            "Edge %d cannot be used for External Interrupts."
            "Need to use a rising, falling, or both configuration.",
            util::Value(edge));
      }
    }
  }
   10b90:	bf00      	nop
   10b92:	3708      	adds	r7, #8
   10b94:	46bd      	mov	sp, r7
   10b96:	bd80      	pop	{r7, pc}
   10b98:	00014e44 	.word	0x00014e44
   10b9c:	00014d58 	.word	0x00014d58
   10ba0:	00014a5c 	.word	0x00014a5c

00010ba4 <sjsu::lpc40xx::Gpio::AttachInterrupt(void (*)(), sjsu::Gpio::Edge) const>:
    }
  }

  // Assign the developer's ISR and sets the selected edge that the gpio
  // interrupt will be triggered on.
  void AttachInterrupt(IsrPointer function, Edge edge) const override
   10ba4:	b580      	push	{r7, lr}
   10ba6:	b084      	sub	sp, #16
   10ba8:	af00      	add	r7, sp, #0
   10baa:	60f8      	str	r0, [r7, #12]
   10bac:	60b9      	str	r1, [r7, #8]
   10bae:	4613      	mov	r3, r2
   10bb0:	71fb      	strb	r3, [r7, #7]
  {
    ValidPortCheck();
   10bb2:	68f8      	ldr	r0, [r7, #12]
   10bb4:	f7ff ff50 	bl	10a58 <sjsu::lpc40xx::Gpio::ValidPortCheck() const>
    SetInterruptRoutine(function);
   10bb8:	68b9      	ldr	r1, [r7, #8]
   10bba:	68f8      	ldr	r0, [r7, #12]
   10bbc:	f7ff ff76 	bl	10aac <sjsu::lpc40xx::Gpio::SetInterruptRoutine(void (*)()) const>
    SetInterruptEdge(edge);
   10bc0:	79fb      	ldrb	r3, [r7, #7]
   10bc2:	4619      	mov	r1, r3
   10bc4:	68f8      	ldr	r0, [r7, #12]
   10bc6:	f7ff ffb7 	bl	10b38 <sjsu::lpc40xx::Gpio::SetInterruptEdge(sjsu::Gpio::Edge) const>
  }
   10bca:	bf00      	nop
   10bcc:	3710      	adds	r7, #16
   10bce:	46bd      	mov	sp, r7
   10bd0:	bd80      	pop	{r7, pc}

00010bd2 <sjsu::lpc40xx::Gpio::DetachInterrupt() const>:

  // Removes the developer's ISR and clears the selected edge of the gpio
  // interrupt from being triggered.
  void DetachInterrupt() const override
   10bd2:	b580      	push	{r7, lr}
   10bd4:	b082      	sub	sp, #8
   10bd6:	af00      	add	r7, sp, #0
   10bd8:	6078      	str	r0, [r7, #4]
  {
    ValidPortCheck();
   10bda:	6878      	ldr	r0, [r7, #4]
   10bdc:	f7ff ff3c 	bl	10a58 <sjsu::lpc40xx::Gpio::ValidPortCheck() const>
    ClearInterruptRoutine();
   10be0:	6878      	ldr	r0, [r7, #4]
   10be2:	f7ff ff81 	bl	10ae8 <sjsu::lpc40xx::Gpio::ClearInterruptRoutine() const>
    ClearEdgeRising();
   10be6:	6878      	ldr	r0, [r7, #4]
   10be8:	f000 f864 	bl	10cb4 <sjsu::lpc40xx::Gpio::ClearEdgeRising() const>
    ClearEdgeFalling();
   10bec:	6878      	ldr	r0, [r7, #4]
   10bee:	f000 f88f 	bl	10d10 <sjsu::lpc40xx::Gpio::ClearEdgeFalling() const>
  }
   10bf2:	bf00      	nop
   10bf4:	3708      	adds	r7, #8
   10bf6:	46bd      	mov	sp, r7
   10bf8:	bd80      	pop	{r7, pc}
   10bfa:	Address 0x0000000000010bfa is out of bounds.


00010bfc <sjsu::lpc40xx::Gpio::SetEdgeRising() const>:
    *interrupt[triggered_port].clear |= (1 << triggered_pin);
  }

 private:
  // Sets the gpio interrupt to trigger on a rising edge.
  void SetEdgeRising() const
   10bfc:	b490      	push	{r4, r7}
   10bfe:	b084      	sub	sp, #16
   10c00:	af00      	add	r7, sp, #0
   10c02:	6078      	str	r0, [r7, #4]
  {
    *interrupt[interupt_port_].enable_rising_edge |= (1 << pin_.GetPin());
   10c04:	687b      	ldr	r3, [r7, #4]
   10c06:	3308      	adds	r3, #8
   10c08:	60fb      	str	r3, [r7, #12]
   10c0a:	68fb      	ldr	r3, [r7, #12]
   10c0c:	795b      	ldrb	r3, [r3, #5]
   10c0e:	461a      	mov	r2, r3
   10c10:	2301      	movs	r3, #1
   10c12:	fa03 f002 	lsl.w	r0, r3, r2
   10c16:	687b      	ldr	r3, [r7, #4]
   10c18:	791b      	ldrb	r3, [r3, #4]
   10c1a:	4619      	mov	r1, r3
   10c1c:	4a0d      	ldr	r2, [pc, #52]	; (10c54 <sjsu::lpc40xx::Gpio::SetEdgeRising() const+0x58>)
   10c1e:	460b      	mov	r3, r1
   10c20:	009b      	lsls	r3, r3, #2
   10c22:	440b      	add	r3, r1
   10c24:	009b      	lsls	r3, r3, #2
   10c26:	4413      	add	r3, r2
   10c28:	330c      	adds	r3, #12
   10c2a:	681b      	ldr	r3, [r3, #0]
   10c2c:	681a      	ldr	r2, [r3, #0]
   10c2e:	4604      	mov	r4, r0
   10c30:	687b      	ldr	r3, [r7, #4]
   10c32:	791b      	ldrb	r3, [r3, #4]
   10c34:	4618      	mov	r0, r3
   10c36:	4907      	ldr	r1, [pc, #28]	; (10c54 <sjsu::lpc40xx::Gpio::SetEdgeRising() const+0x58>)
   10c38:	4603      	mov	r3, r0
   10c3a:	009b      	lsls	r3, r3, #2
   10c3c:	4403      	add	r3, r0
   10c3e:	009b      	lsls	r3, r3, #2
   10c40:	440b      	add	r3, r1
   10c42:	330c      	adds	r3, #12
   10c44:	681b      	ldr	r3, [r3, #0]
   10c46:	4322      	orrs	r2, r4
   10c48:	601a      	str	r2, [r3, #0]
  }
   10c4a:	bf00      	nop
   10c4c:	3710      	adds	r7, #16
   10c4e:	46bd      	mov	sp, r7
   10c50:	bc90      	pop	{r4, r7}
   10c52:	4770      	bx	lr
   10c54:	10000020 	.word	0x10000020

00010c58 <sjsu::lpc40xx::Gpio::SetEdgeFalling() const>:

  // Sets the gpio interrupt to trigger on a falling edge.
  void SetEdgeFalling() const
   10c58:	b490      	push	{r4, r7}
   10c5a:	b084      	sub	sp, #16
   10c5c:	af00      	add	r7, sp, #0
   10c5e:	6078      	str	r0, [r7, #4]
  {
    *interrupt[interupt_port_].enable_falling_edge |= (1 << pin_.GetPin());
   10c60:	687b      	ldr	r3, [r7, #4]
   10c62:	3308      	adds	r3, #8
   10c64:	60fb      	str	r3, [r7, #12]
   10c66:	68fb      	ldr	r3, [r7, #12]
   10c68:	795b      	ldrb	r3, [r3, #5]
   10c6a:	461a      	mov	r2, r3
   10c6c:	2301      	movs	r3, #1
   10c6e:	fa03 f002 	lsl.w	r0, r3, r2
   10c72:	687b      	ldr	r3, [r7, #4]
   10c74:	791b      	ldrb	r3, [r3, #4]
   10c76:	4619      	mov	r1, r3
   10c78:	4a0d      	ldr	r2, [pc, #52]	; (10cb0 <sjsu::lpc40xx::Gpio::SetEdgeFalling() const+0x58>)
   10c7a:	460b      	mov	r3, r1
   10c7c:	009b      	lsls	r3, r3, #2
   10c7e:	440b      	add	r3, r1
   10c80:	009b      	lsls	r3, r3, #2
   10c82:	4413      	add	r3, r2
   10c84:	3310      	adds	r3, #16
   10c86:	681b      	ldr	r3, [r3, #0]
   10c88:	681a      	ldr	r2, [r3, #0]
   10c8a:	4604      	mov	r4, r0
   10c8c:	687b      	ldr	r3, [r7, #4]
   10c8e:	791b      	ldrb	r3, [r3, #4]
   10c90:	4618      	mov	r0, r3
   10c92:	4907      	ldr	r1, [pc, #28]	; (10cb0 <sjsu::lpc40xx::Gpio::SetEdgeFalling() const+0x58>)
   10c94:	4603      	mov	r3, r0
   10c96:	009b      	lsls	r3, r3, #2
   10c98:	4403      	add	r3, r0
   10c9a:	009b      	lsls	r3, r3, #2
   10c9c:	440b      	add	r3, r1
   10c9e:	3310      	adds	r3, #16
   10ca0:	681b      	ldr	r3, [r3, #0]
   10ca2:	4322      	orrs	r2, r4
   10ca4:	601a      	str	r2, [r3, #0]
  }
   10ca6:	bf00      	nop
   10ca8:	3710      	adds	r7, #16
   10caa:	46bd      	mov	sp, r7
   10cac:	bc90      	pop	{r4, r7}
   10cae:	4770      	bx	lr
   10cb0:	10000020 	.word	0x10000020

00010cb4 <sjsu::lpc40xx::Gpio::ClearEdgeRising() const>:

  // Clears the gpio interrupt to no longer trigger on a rising edge.
  void ClearEdgeRising() const
   10cb4:	b490      	push	{r4, r7}
   10cb6:	b084      	sub	sp, #16
   10cb8:	af00      	add	r7, sp, #0
   10cba:	6078      	str	r0, [r7, #4]
  {
    *interrupt[interupt_port_].enable_rising_edge &= ~(1 << pin_.GetPin());
   10cbc:	687b      	ldr	r3, [r7, #4]
   10cbe:	3308      	adds	r3, #8
   10cc0:	60fb      	str	r3, [r7, #12]
   10cc2:	68fb      	ldr	r3, [r7, #12]
   10cc4:	795b      	ldrb	r3, [r3, #5]
   10cc6:	461a      	mov	r2, r3
   10cc8:	2301      	movs	r3, #1
   10cca:	4093      	lsls	r3, r2
   10ccc:	43d8      	mvns	r0, r3
   10cce:	687b      	ldr	r3, [r7, #4]
   10cd0:	791b      	ldrb	r3, [r3, #4]
   10cd2:	4619      	mov	r1, r3
   10cd4:	4a0d      	ldr	r2, [pc, #52]	; (10d0c <sjsu::lpc40xx::Gpio::ClearEdgeRising() const+0x58>)
   10cd6:	460b      	mov	r3, r1
   10cd8:	009b      	lsls	r3, r3, #2
   10cda:	440b      	add	r3, r1
   10cdc:	009b      	lsls	r3, r3, #2
   10cde:	4413      	add	r3, r2
   10ce0:	330c      	adds	r3, #12
   10ce2:	681b      	ldr	r3, [r3, #0]
   10ce4:	681a      	ldr	r2, [r3, #0]
   10ce6:	4604      	mov	r4, r0
   10ce8:	687b      	ldr	r3, [r7, #4]
   10cea:	791b      	ldrb	r3, [r3, #4]
   10cec:	4618      	mov	r0, r3
   10cee:	4907      	ldr	r1, [pc, #28]	; (10d0c <sjsu::lpc40xx::Gpio::ClearEdgeRising() const+0x58>)
   10cf0:	4603      	mov	r3, r0
   10cf2:	009b      	lsls	r3, r3, #2
   10cf4:	4403      	add	r3, r0
   10cf6:	009b      	lsls	r3, r3, #2
   10cf8:	440b      	add	r3, r1
   10cfa:	330c      	adds	r3, #12
   10cfc:	681b      	ldr	r3, [r3, #0]
   10cfe:	4022      	ands	r2, r4
   10d00:	601a      	str	r2, [r3, #0]
  }
   10d02:	bf00      	nop
   10d04:	3710      	adds	r7, #16
   10d06:	46bd      	mov	sp, r7
   10d08:	bc90      	pop	{r4, r7}
   10d0a:	4770      	bx	lr
   10d0c:	10000020 	.word	0x10000020

00010d10 <sjsu::lpc40xx::Gpio::ClearEdgeFalling() const>:

  // Clears the gpio interrupt to no longer trigger on a falling edge.
  void ClearEdgeFalling() const
   10d10:	b490      	push	{r4, r7}
   10d12:	b084      	sub	sp, #16
   10d14:	af00      	add	r7, sp, #0
   10d16:	6078      	str	r0, [r7, #4]
  {
    *interrupt[interupt_port_].enable_falling_edge &= ~(1 << pin_.GetPin());
   10d18:	687b      	ldr	r3, [r7, #4]
   10d1a:	3308      	adds	r3, #8
   10d1c:	60fb      	str	r3, [r7, #12]
   10d1e:	68fb      	ldr	r3, [r7, #12]
   10d20:	795b      	ldrb	r3, [r3, #5]
   10d22:	461a      	mov	r2, r3
   10d24:	2301      	movs	r3, #1
   10d26:	4093      	lsls	r3, r2
   10d28:	43d8      	mvns	r0, r3
   10d2a:	687b      	ldr	r3, [r7, #4]
   10d2c:	791b      	ldrb	r3, [r3, #4]
   10d2e:	4619      	mov	r1, r3
   10d30:	4a0d      	ldr	r2, [pc, #52]	; (10d68 <sjsu::lpc40xx::Gpio::ClearEdgeFalling() const+0x58>)
   10d32:	460b      	mov	r3, r1
   10d34:	009b      	lsls	r3, r3, #2
   10d36:	440b      	add	r3, r1
   10d38:	009b      	lsls	r3, r3, #2
   10d3a:	4413      	add	r3, r2
   10d3c:	3310      	adds	r3, #16
   10d3e:	681b      	ldr	r3, [r3, #0]
   10d40:	681a      	ldr	r2, [r3, #0]
   10d42:	4604      	mov	r4, r0
   10d44:	687b      	ldr	r3, [r7, #4]
   10d46:	791b      	ldrb	r3, [r3, #4]
   10d48:	4618      	mov	r0, r3
   10d4a:	4907      	ldr	r1, [pc, #28]	; (10d68 <sjsu::lpc40xx::Gpio::ClearEdgeFalling() const+0x58>)
   10d4c:	4603      	mov	r3, r0
   10d4e:	009b      	lsls	r3, r3, #2
   10d50:	4403      	add	r3, r0
   10d52:	009b      	lsls	r3, r3, #2
   10d54:	440b      	add	r3, r1
   10d56:	3310      	adds	r3, #16
   10d58:	681b      	ldr	r3, [r3, #0]
   10d5a:	4022      	ands	r2, r4
   10d5c:	601a      	str	r2, [r3, #0]
  }
   10d5e:	bf00      	nop
   10d60:	3710      	adds	r7, #16
   10d62:	46bd      	mov	sp, r7
   10d64:	bc90      	pop	{r4, r7}
   10d66:	4770      	bx	lr
   10d68:	10000020 	.word	0x10000020

00010d6c <sjsu::OnBoardLed::Initialize()>:
    kOn  = true,
    kOff = false
  };
  // Initialize takes the array of Gpios, sets each one to an output, and
  // then turns off all of the leds by setting the output high.
  void Initialize()
   10d6c:	b580      	push	{r7, lr}
   10d6e:	b084      	sub	sp, #16
   10d70:	af00      	add	r7, sp, #0
   10d72:	6078      	str	r0, [r7, #4]
  {
    for (uint8_t i = 0; i < 4; i++)
   10d74:	2300      	movs	r3, #0
   10d76:	73fb      	strb	r3, [r7, #15]
   10d78:	7bfb      	ldrb	r3, [r7, #15]
   10d7a:	2b03      	cmp	r3, #3
   10d7c:	d811      	bhi.n	10da2 <sjsu::OnBoardLed::Initialize()+0x36>
    {
      led[i].SetAsOutput();
   10d7e:	7bfb      	ldrb	r3, [r7, #15]
   10d80:	011b      	lsls	r3, r3, #4
   10d82:	687a      	ldr	r2, [r7, #4]
   10d84:	4413      	add	r3, r2
   10d86:	4618      	mov	r0, r3
   10d88:	f7ff fd7a 	bl	10880 <sjsu::lpc40xx::Gpio::SetAsOutput() const>
      led[i].SetHigh();
   10d8c:	7bfb      	ldrb	r3, [r7, #15]
   10d8e:	011b      	lsls	r3, r3, #4
   10d90:	687a      	ldr	r2, [r7, #4]
   10d92:	4413      	add	r3, r2
   10d94:	4618      	mov	r0, r3
   10d96:	f7ff fdad 	bl	108f4 <sjsu::lpc40xx::Gpio::SetHigh() const>
    for (uint8_t i = 0; i < 4; i++)
   10d9a:	7bfb      	ldrb	r3, [r7, #15]
   10d9c:	3301      	adds	r3, #1
   10d9e:	73fb      	strb	r3, [r7, #15]
   10da0:	e7ea      	b.n	10d78 <sjsu::OnBoardLed::Initialize()+0xc>
    }
  }
   10da2:	bf00      	nop
   10da4:	3710      	adds	r7, #16
   10da6:	46bd      	mov	sp, r7
   10da8:	bd80      	pop	{r7, pc}
   10daa:	Address 0x0000000000010daa is out of bounds.


00010dac <sjsu::OnBoardLed::On(unsigned char)>:

  void On(uint8_t led_number)
   10dac:	b580      	push	{r7, lr}
   10dae:	b084      	sub	sp, #16
   10db0:	af02      	add	r7, sp, #8
   10db2:	6078      	str	r0, [r7, #4]
   10db4:	460b      	mov	r3, r1
   10db6:	70fb      	strb	r3, [r7, #3]
  {
    SJ2_ASSERT_FATAL(led_number < 4,
   10db8:	78fb      	ldrb	r3, [r7, #3]
   10dba:	2b03      	cmp	r3, #3
   10dbc:	d90f      	bls.n	10dde <sjsu::OnBoardLed::On(unsigned char)+0x32>
   10dbe:	78fb      	ldrb	r3, [r7, #3]
   10dc0:	9300      	str	r3, [sp, #0]
   10dc2:	2336      	movs	r3, #54	; 0x36
   10dc4:	4a0b      	ldr	r2, [pc, #44]	; (10df4 <sjsu::OnBoardLed::On(unsigned char)+0x48>)
   10dc6:	490c      	ldr	r1, [pc, #48]	; (10df8 <sjsu::OnBoardLed::On(unsigned char)+0x4c>)
   10dc8:	480c      	ldr	r0, [pc, #48]	; (10dfc <sjsu::OnBoardLed::On(unsigned char)+0x50>)
   10dca:	f002 fb73 	bl	134b4 <printf>
   10dce:	480c      	ldr	r0, [pc, #48]	; (10e00 <sjsu::OnBoardLed::On(unsigned char)+0x54>)
   10dd0:	f001 f9a0 	bl	12114 <puts>
   10dd4:	2100      	movs	r1, #0
   10dd6:	2001      	movs	r0, #1
   10dd8:	f7ff fc52 	bl	10680 <sjsu::debug::PrintBacktrace(bool, void*)>
   10ddc:	e7fe      	b.n	10ddc <sjsu::OnBoardLed::On(unsigned char)+0x30>
                     "Input Led number can't be greater than 3, input = %d.\n",
                     led_number);
    led[led_number].SetLow();
   10dde:	78fb      	ldrb	r3, [r7, #3]
   10de0:	011b      	lsls	r3, r3, #4
   10de2:	687a      	ldr	r2, [r7, #4]
   10de4:	4413      	add	r3, r2
   10de6:	4618      	mov	r0, r3
   10de8:	f7ff fda4 	bl	10934 <sjsu::lpc40xx::Gpio::SetLow() const>
  }
   10dec:	bf00      	nop
   10dee:	3708      	adds	r7, #8
   10df0:	46bd      	mov	sp, r7
   10df2:	bd80      	pop	{r7, pc}
   10df4:	00014ecc 	.word	0x00014ecc
   10df8:	00014d64 	.word	0x00014d64
   10dfc:	00014b3c 	.word	0x00014b3c
   10e00:	00014bf0 	.word	0x00014bf0

00010e04 <sjsu::OnBoardLed::Off(unsigned char)>:

  void Off(uint8_t led_number)
   10e04:	b580      	push	{r7, lr}
   10e06:	b084      	sub	sp, #16
   10e08:	af02      	add	r7, sp, #8
   10e0a:	6078      	str	r0, [r7, #4]
   10e0c:	460b      	mov	r3, r1
   10e0e:	70fb      	strb	r3, [r7, #3]
  {
    SJ2_ASSERT_FATAL(led_number < 4,
   10e10:	78fb      	ldrb	r3, [r7, #3]
   10e12:	2b03      	cmp	r3, #3
   10e14:	d90f      	bls.n	10e36 <sjsu::OnBoardLed::Off(unsigned char)+0x32>
   10e16:	78fb      	ldrb	r3, [r7, #3]
   10e18:	9300      	str	r3, [sp, #0]
   10e1a:	233e      	movs	r3, #62	; 0x3e
   10e1c:	4a0b      	ldr	r2, [pc, #44]	; (10e4c <sjsu::OnBoardLed::Off(unsigned char)+0x48>)
   10e1e:	490c      	ldr	r1, [pc, #48]	; (10e50 <sjsu::OnBoardLed::Off(unsigned char)+0x4c>)
   10e20:	480c      	ldr	r0, [pc, #48]	; (10e54 <sjsu::OnBoardLed::Off(unsigned char)+0x50>)
   10e22:	f002 fb47 	bl	134b4 <printf>
   10e26:	480c      	ldr	r0, [pc, #48]	; (10e58 <sjsu::OnBoardLed::Off(unsigned char)+0x54>)
   10e28:	f001 f974 	bl	12114 <puts>
   10e2c:	2100      	movs	r1, #0
   10e2e:	2001      	movs	r0, #1
   10e30:	f7ff fc26 	bl	10680 <sjsu::debug::PrintBacktrace(bool, void*)>
   10e34:	e7fe      	b.n	10e34 <sjsu::OnBoardLed::Off(unsigned char)+0x30>
                     "Input Led number can't be greater than 3, input = %d.\n",
                     led_number);
    led[led_number].SetHigh();
   10e36:	78fb      	ldrb	r3, [r7, #3]
   10e38:	011b      	lsls	r3, r3, #4
   10e3a:	687a      	ldr	r2, [r7, #4]
   10e3c:	4413      	add	r3, r2
   10e3e:	4618      	mov	r0, r3
   10e40:	f7ff fd58 	bl	108f4 <sjsu::lpc40xx::Gpio::SetHigh() const>
  }
   10e44:	bf00      	nop
   10e46:	3708      	adds	r7, #8
   10e48:	46bd      	mov	sp, r7
   10e4a:	bd80      	pop	{r7, pc}
   10e4c:	00014ef0 	.word	0x00014ef0
   10e50:	00014d74 	.word	0x00014d74
   10e54:	00014b3c 	.word	0x00014b3c
   10e58:	00014bf0 	.word	0x00014bf0

00010e5c <sjsu::OnBoardLed::Set(unsigned char, sjsu::OnBoardLed::LightState)>:

  void Set(uint8_t led_number, LightState state = LightState::kOn)
   10e5c:	b580      	push	{r7, lr}
   10e5e:	b084      	sub	sp, #16
   10e60:	af02      	add	r7, sp, #8
   10e62:	6078      	str	r0, [r7, #4]
   10e64:	460b      	mov	r3, r1
   10e66:	70fb      	strb	r3, [r7, #3]
   10e68:	4613      	mov	r3, r2
   10e6a:	70bb      	strb	r3, [r7, #2]
  {
    SJ2_ASSERT_FATAL(led_number < 4,
   10e6c:	78fb      	ldrb	r3, [r7, #3]
   10e6e:	2b03      	cmp	r3, #3
   10e70:	d90f      	bls.n	10e92 <sjsu::OnBoardLed::Set(unsigned char, sjsu::OnBoardLed::LightState)+0x36>
   10e72:	78fb      	ldrb	r3, [r7, #3]
   10e74:	9300      	str	r3, [sp, #0]
   10e76:	2346      	movs	r3, #70	; 0x46
   10e78:	4a0f      	ldr	r2, [pc, #60]	; (10eb8 <sjsu::OnBoardLed::Set(unsigned char, sjsu::OnBoardLed::LightState)+0x5c>)
   10e7a:	4910      	ldr	r1, [pc, #64]	; (10ebc <sjsu::OnBoardLed::Set(unsigned char, sjsu::OnBoardLed::LightState)+0x60>)
   10e7c:	4810      	ldr	r0, [pc, #64]	; (10ec0 <sjsu::OnBoardLed::Set(unsigned char, sjsu::OnBoardLed::LightState)+0x64>)
   10e7e:	f002 fb19 	bl	134b4 <printf>
   10e82:	4810      	ldr	r0, [pc, #64]	; (10ec4 <sjsu::OnBoardLed::Set(unsigned char, sjsu::OnBoardLed::LightState)+0x68>)
   10e84:	f001 f946 	bl	12114 <puts>
   10e88:	2100      	movs	r1, #0
   10e8a:	2001      	movs	r0, #1
   10e8c:	f7ff fbf8 	bl	10680 <sjsu::debug::PrintBacktrace(bool, void*)>
   10e90:	e7fe      	b.n	10e90 <sjsu::OnBoardLed::Set(unsigned char, sjsu::OnBoardLed::LightState)+0x34>
                     "Input Led number can't be greater than 3, input = %d.\n",
                     led_number);
    if (state == LightState::kOn)
   10e92:	78bb      	ldrb	r3, [r7, #2]
   10e94:	2b01      	cmp	r3, #1
   10e96:	d105      	bne.n	10ea4 <sjsu::OnBoardLed::Set(unsigned char, sjsu::OnBoardLed::LightState)+0x48>
    {
      On(led_number);
   10e98:	78fb      	ldrb	r3, [r7, #3]
   10e9a:	4619      	mov	r1, r3
   10e9c:	6878      	ldr	r0, [r7, #4]
   10e9e:	f7ff ff85 	bl	10dac <sjsu::OnBoardLed::On(unsigned char)>
    }
    else
    {
      Off(led_number);
    }
  }
   10ea2:	e004      	b.n	10eae <sjsu::OnBoardLed::Set(unsigned char, sjsu::OnBoardLed::LightState)+0x52>
      Off(led_number);
   10ea4:	78fb      	ldrb	r3, [r7, #3]
   10ea6:	4619      	mov	r1, r3
   10ea8:	6878      	ldr	r0, [r7, #4]
   10eaa:	f7ff ffab 	bl	10e04 <sjsu::OnBoardLed::Off(unsigned char)>
  }
   10eae:	bf00      	nop
   10eb0:	3708      	adds	r7, #8
   10eb2:	46bd      	mov	sp, r7
   10eb4:	bd80      	pop	{r7, pc}
   10eb6:	bf00      	nop
   10eb8:	00014e88 	.word	0x00014e88
   10ebc:	00014d84 	.word	0x00014d84
   10ec0:	00014b3c 	.word	0x00014b3c
   10ec4:	00014bf0 	.word	0x00014bf0

00010ec8 <sjsu::OnBoardLed::SetAll(unsigned char)>:

  // This function takes in the 4 least significant bits from value, and sets
  // the led to be ON or OFF. The least significant bit corresponds to LED0,
  // next least significant corresponds to LED1, etc. ON =1, OFF =0. The four
  // most significant bits will be unused.
  void SetAll(uint8_t value)
   10ec8:	b580      	push	{r7, lr}
   10eca:	b084      	sub	sp, #16
   10ecc:	af00      	add	r7, sp, #0
   10ece:	6078      	str	r0, [r7, #4]
   10ed0:	460b      	mov	r3, r1
   10ed2:	70fb      	strb	r3, [r7, #3]
  {
    for (uint8_t i = 0; i < 4; i++)
   10ed4:	2300      	movs	r3, #0
   10ed6:	73fb      	strb	r3, [r7, #15]
   10ed8:	7bfb      	ldrb	r3, [r7, #15]
   10eda:	2b03      	cmp	r3, #3
   10edc:	d818      	bhi.n	10f10 <sjsu::OnBoardLed::SetAll(unsigned char)+0x48>
    {
      if ((value >> i) & 1)
   10ede:	78fa      	ldrb	r2, [r7, #3]
   10ee0:	7bfb      	ldrb	r3, [r7, #15]
   10ee2:	fa42 f303 	asr.w	r3, r2, r3
   10ee6:	f003 0301 	and.w	r3, r3, #1
   10eea:	2b00      	cmp	r3, #0
   10eec:	d006      	beq.n	10efc <sjsu::OnBoardLed::SetAll(unsigned char)+0x34>
      {
        Set(i, LightState::kOn);
   10eee:	7bfb      	ldrb	r3, [r7, #15]
   10ef0:	2201      	movs	r2, #1
   10ef2:	4619      	mov	r1, r3
   10ef4:	6878      	ldr	r0, [r7, #4]
   10ef6:	f7ff ffb1 	bl	10e5c <sjsu::OnBoardLed::Set(unsigned char, sjsu::OnBoardLed::LightState)>
   10efa:	e005      	b.n	10f08 <sjsu::OnBoardLed::SetAll(unsigned char)+0x40>
      }
      else
      {
        Set(i, LightState::kOff);
   10efc:	7bfb      	ldrb	r3, [r7, #15]
   10efe:	2200      	movs	r2, #0
   10f00:	4619      	mov	r1, r3
   10f02:	6878      	ldr	r0, [r7, #4]
   10f04:	f7ff ffaa 	bl	10e5c <sjsu::OnBoardLed::Set(unsigned char, sjsu::OnBoardLed::LightState)>
    for (uint8_t i = 0; i < 4; i++)
   10f08:	7bfb      	ldrb	r3, [r7, #15]
   10f0a:	3301      	adds	r3, #1
   10f0c:	73fb      	strb	r3, [r7, #15]
   10f0e:	e7e3      	b.n	10ed8 <sjsu::OnBoardLed::SetAll(unsigned char)+0x10>
      }
    }
  }
   10f10:	bf00      	nop
   10f12:	3710      	adds	r7, #16
   10f14:	46bd      	mov	sp, r7
   10f16:	bd80      	pop	{r7, pc}

00010f18 <main>:
#include "L2_HAL/boards/sjtwo.hpp"
#include "utility/log.hpp"
#include "utility/time.hpp"

int main()
{
   10f18:	b580      	push	{r7, lr}
   10f1a:	b084      	sub	sp, #16
   10f1c:	af02      	add	r7, sp, #8
  LOG_INFO("Staring Hello World Application");
   10f1e:	230c      	movs	r3, #12
   10f20:	4a18      	ldr	r2, [pc, #96]	; (10f84 <main+0x6c>)
   10f22:	4919      	ldr	r1, [pc, #100]	; (10f88 <main+0x70>)
   10f24:	4819      	ldr	r0, [pc, #100]	; (10f8c <main+0x74>)
   10f26:	f002 fac5 	bl	134b4 <printf>
  LOG_INFO("Initializing LEDs...");
   10f2a:	230d      	movs	r3, #13
   10f2c:	4a15      	ldr	r2, [pc, #84]	; (10f84 <main+0x6c>)
   10f2e:	4918      	ldr	r1, [pc, #96]	; (10f90 <main+0x78>)
   10f30:	4818      	ldr	r0, [pc, #96]	; (10f94 <main+0x7c>)
   10f32:	f002 fabf 	bl	134b4 <printf>
  }

  [[gnu::always_inline]] inline static sjsu::OnBoardLed & Leds()
  {
    static sjsu::OnBoardLed leds_;
    return leds_;
   10f36:	4b18      	ldr	r3, [pc, #96]	; (10f98 <main+0x80>)
  sjtwo::Leds().Initialize();
   10f38:	4618      	mov	r0, r3
   10f3a:	f7ff ff17 	bl	10d6c <sjsu::OnBoardLed::Initialize()>
  LOG_INFO("LEDs Initialized!");
   10f3e:	230f      	movs	r3, #15
   10f40:	4a10      	ldr	r2, [pc, #64]	; (10f84 <main+0x6c>)
   10f42:	4916      	ldr	r1, [pc, #88]	; (10f9c <main+0x84>)
   10f44:	4816      	ldr	r0, [pc, #88]	; (10fa0 <main+0x88>)
   10f46:	f002 fab5 	bl	134b4 <printf>
  while (true)
  {
    for (uint8_t i = 0; i < 16; i++)
   10f4a:	2300      	movs	r3, #0
   10f4c:	71fb      	strb	r3, [r7, #7]
   10f4e:	79fb      	ldrb	r3, [r7, #7]
   10f50:	2b0f      	cmp	r3, #15
   10f52:	d8fa      	bhi.n	10f4a <main+0x32>
    {
      LOG_INFO("Hello World 0x%X", i);
   10f54:	79fb      	ldrb	r3, [r7, #7]
   10f56:	9300      	str	r3, [sp, #0]
   10f58:	2314      	movs	r3, #20
   10f5a:	4a0a      	ldr	r2, [pc, #40]	; (10f84 <main+0x6c>)
   10f5c:	4911      	ldr	r1, [pc, #68]	; (10fa4 <main+0x8c>)
   10f5e:	4812      	ldr	r0, [pc, #72]	; (10fa8 <main+0x90>)
   10f60:	f002 faa8 	bl	134b4 <printf>
   10f64:	4a0c      	ldr	r2, [pc, #48]	; (10f98 <main+0x80>)
      sjtwo::Leds().SetAll(i);
   10f66:	79fb      	ldrb	r3, [r7, #7]
   10f68:	4619      	mov	r1, r3
   10f6a:	4610      	mov	r0, r2
   10f6c:	f7ff ffac 	bl	10ec8 <sjsu::OnBoardLed::SetAll(unsigned char)>
      sjsu::Delay(500);
   10f70:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
   10f74:	f04f 0100 	mov.w	r1, #0
   10f78:	f7ff fc4f 	bl	1081a <sjsu::Delay(unsigned long long)>
    for (uint8_t i = 0; i < 16; i++)
   10f7c:	79fb      	ldrb	r3, [r7, #7]
   10f7e:	3301      	adds	r3, #1
   10f80:	71fb      	strb	r3, [r7, #7]
   10f82:	e7e4      	b.n	10f4e <main+0x36>
   10f84:	00014e04 	.word	0x00014e04
   10f88:	00014d94 	.word	0x00014d94
   10f8c:	00014c08 	.word	0x00014c08
   10f90:	00014da0 	.word	0x00014da0
   10f94:	00014c64 	.word	0x00014c64
   10f98:	10000048 	.word	0x10000048
   10f9c:	00014dac 	.word	0x00014dac
   10fa0:	00014cb4 	.word	0x00014cb4
   10fa4:	00014db8 	.word	0x00014db8
   10fa8:	00014d00 	.word	0x00014d00

00010fac <unsigned long sjsu::bit::Insert<unsigned long, unsigned char>(unsigned long, unsigned char, unsigned long, unsigned long)>:
/// @param target the target that will have bits inserted into it.
/// @param value the bits to be inserted into the target
/// @param position the position in the target to insert the value of bits.
/// @param width the length of bits that will be overwritten in the target.
template <typename T, typename U>
[[nodiscard]] constexpr T Insert(T target, U value, uint32_t position,
   10fac:	b480      	push	{r7}
   10fae:	b089      	sub	sp, #36	; 0x24
   10fb0:	af00      	add	r7, sp, #0
   10fb2:	60f8      	str	r0, [r7, #12]
   10fb4:	607a      	str	r2, [r7, #4]
   10fb6:	603b      	str	r3, [r7, #0]
   10fb8:	460b      	mov	r3, r1
   10fba:	72fb      	strb	r3, [r7, #11]
  // Need to use an unsigned version of the type T for the mask to make sure
  // that the shift right doesn't result in a sign extended shift.
  using UnsignedT = typename std::make_unsigned<T>::type;
  // At compile time, generate variable containing all 1s with the size of the
  // target parameter.
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   10fbc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   10fc0:	61fb      	str	r3, [r7, #28]
  // At compile time calculate the number of bits in the target parameter.
  constexpr size_t kTargetWidth = sizeof(T) * 8;
   10fc2:	2320      	movs	r3, #32
   10fc4:	61bb      	str	r3, [r7, #24]
  // Create mask by shifting the set of 1s down so that the number of 1s from
  // bit position 0 is equal to the width parameter.
  UnsignedT mask = kFieldOfOnes >> (kTargetWidth - width);
   10fc6:	683b      	ldr	r3, [r7, #0]
   10fc8:	f1c3 0320 	rsb	r3, r3, #32
   10fcc:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   10fd0:	fa22 f303 	lsr.w	r3, r2, r3
   10fd4:	617b      	str	r3, [r7, #20]
  // Clear width's number of bits in the target value at the bit position
  // specified.
  target &= ~(mask << position);
   10fd6:	697a      	ldr	r2, [r7, #20]
   10fd8:	687b      	ldr	r3, [r7, #4]
   10fda:	fa02 f303 	lsl.w	r3, r2, r3
   10fde:	43db      	mvns	r3, r3
   10fe0:	68fa      	ldr	r2, [r7, #12]
   10fe2:	4013      	ands	r3, r2
   10fe4:	60fb      	str	r3, [r7, #12]
  // AND value with mask to remove any bits beyond the specified width.
  // Shift masked value into bit position and OR with target value.
  target |= (value & mask) << position;
   10fe6:	7afa      	ldrb	r2, [r7, #11]
   10fe8:	697b      	ldr	r3, [r7, #20]
   10fea:	401a      	ands	r2, r3
   10fec:	687b      	ldr	r3, [r7, #4]
   10fee:	fa02 f303 	lsl.w	r3, r2, r3
   10ff2:	68fa      	ldr	r2, [r7, #12]
   10ff4:	4313      	orrs	r3, r2
   10ff6:	60fb      	str	r3, [r7, #12]
  return target;
   10ff8:	68fb      	ldr	r3, [r7, #12]
}
   10ffa:	4618      	mov	r0, r3
   10ffc:	3724      	adds	r7, #36	; 0x24
   10ffe:	46bd      	mov	sp, r7
   11000:	f85d 7b04 	ldr.w	r7, [sp], #4
   11004:	4770      	bx	lr

00011006 <unsigned long sjsu::bit::Insert<unsigned long, int>(unsigned long, int, unsigned long, unsigned long)>:
[[nodiscard]] constexpr T Insert(T target, U value, uint32_t position,
   11006:	b480      	push	{r7}
   11008:	b089      	sub	sp, #36	; 0x24
   1100a:	af00      	add	r7, sp, #0
   1100c:	60f8      	str	r0, [r7, #12]
   1100e:	60b9      	str	r1, [r7, #8]
   11010:	607a      	str	r2, [r7, #4]
   11012:	603b      	str	r3, [r7, #0]
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   11014:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   11018:	61fb      	str	r3, [r7, #28]
  constexpr size_t kTargetWidth = sizeof(T) * 8;
   1101a:	2320      	movs	r3, #32
   1101c:	61bb      	str	r3, [r7, #24]
  UnsignedT mask = kFieldOfOnes >> (kTargetWidth - width);
   1101e:	683b      	ldr	r3, [r7, #0]
   11020:	f1c3 0320 	rsb	r3, r3, #32
   11024:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   11028:	fa22 f303 	lsr.w	r3, r2, r3
   1102c:	617b      	str	r3, [r7, #20]
  target &= ~(mask << position);
   1102e:	697a      	ldr	r2, [r7, #20]
   11030:	687b      	ldr	r3, [r7, #4]
   11032:	fa02 f303 	lsl.w	r3, r2, r3
   11036:	43db      	mvns	r3, r3
   11038:	68fa      	ldr	r2, [r7, #12]
   1103a:	4013      	ands	r3, r2
   1103c:	60fb      	str	r3, [r7, #12]
  target |= (value & mask) << position;
   1103e:	68ba      	ldr	r2, [r7, #8]
   11040:	697b      	ldr	r3, [r7, #20]
   11042:	401a      	ands	r2, r3
   11044:	687b      	ldr	r3, [r7, #4]
   11046:	fa02 f303 	lsl.w	r3, r2, r3
   1104a:	68fa      	ldr	r2, [r7, #12]
   1104c:	4313      	orrs	r3, r2
   1104e:	60fb      	str	r3, [r7, #12]
  return target;
   11050:	68fb      	ldr	r3, [r7, #12]
}
   11052:	4618      	mov	r0, r3
   11054:	3724      	adds	r7, #36	; 0x24
   11056:	46bd      	mov	sp, r7
   11058:	f85d 7b04 	ldr.w	r7, [sp], #4
   1105c:	4770      	bx	lr

0001105e <unsigned long sjsu::bit::Insert<unsigned long, bool>(unsigned long, bool, unsigned long, unsigned long)>:
[[nodiscard]] constexpr T Insert(T target, U value, uint32_t position,
   1105e:	b480      	push	{r7}
   11060:	b089      	sub	sp, #36	; 0x24
   11062:	af00      	add	r7, sp, #0
   11064:	60f8      	str	r0, [r7, #12]
   11066:	607a      	str	r2, [r7, #4]
   11068:	603b      	str	r3, [r7, #0]
   1106a:	460b      	mov	r3, r1
   1106c:	72fb      	strb	r3, [r7, #11]
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   1106e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   11072:	61fb      	str	r3, [r7, #28]
  constexpr size_t kTargetWidth = sizeof(T) * 8;
   11074:	2320      	movs	r3, #32
   11076:	61bb      	str	r3, [r7, #24]
  UnsignedT mask = kFieldOfOnes >> (kTargetWidth - width);
   11078:	683b      	ldr	r3, [r7, #0]
   1107a:	f1c3 0320 	rsb	r3, r3, #32
   1107e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   11082:	fa22 f303 	lsr.w	r3, r2, r3
   11086:	617b      	str	r3, [r7, #20]
  target &= ~(mask << position);
   11088:	697a      	ldr	r2, [r7, #20]
   1108a:	687b      	ldr	r3, [r7, #4]
   1108c:	fa02 f303 	lsl.w	r3, r2, r3
   11090:	43db      	mvns	r3, r3
   11092:	68fa      	ldr	r2, [r7, #12]
   11094:	4013      	ands	r3, r2
   11096:	60fb      	str	r3, [r7, #12]
  target |= (value & mask) << position;
   11098:	7afa      	ldrb	r2, [r7, #11]
   1109a:	697b      	ldr	r3, [r7, #20]
   1109c:	401a      	ands	r2, r3
   1109e:	687b      	ldr	r3, [r7, #4]
   110a0:	fa02 f303 	lsl.w	r3, r2, r3
   110a4:	68fa      	ldr	r2, [r7, #12]
   110a6:	4313      	orrs	r3, r2
   110a8:	60fb      	str	r3, [r7, #12]
  return target;
   110aa:	68fb      	ldr	r3, [r7, #12]
}
   110ac:	4618      	mov	r0, r3
   110ae:	3724      	adds	r7, #36	; 0x24
   110b0:	46bd      	mov	sp, r7
   110b2:	f85d 7b04 	ldr.w	r7, [sp], #4
   110b6:	4770      	bx	lr

000110b8 <sjsu::I2cDevice<&sjsu::Apds9960::i2c, (unsigned char)57, (sjsu::device::Endian)0, sjsu::Apds9960Interface::MemoryMap_t>::I2cDevice()>:
  static void Read(intptr_t address, size_t size, uint8_t * target)
  {
    uint8_t register_address = static_cast<uint8_t>(address);
    i2c->WriteThenRead(kDeviceAddress, &register_address, 1, target, size);
  }
  I2cDevice() {}
   110b8:	b580      	push	{r7, lr}
   110ba:	b082      	sub	sp, #8
   110bc:	af00      	add	r7, sp, #0
   110be:	6078      	str	r0, [r7, #4]
   110c0:	687b      	ldr	r3, [r7, #4]
   110c2:	4618      	mov	r0, r3
   110c4:	f000 f805 	bl	110d2 <sjsu::Device<sjsu::I2cDevice<&sjsu::Apds9960::i2c, (unsigned char)57, (sjsu::device::Endian)0, sjsu::Apds9960Interface::MemoryMap_t>, (sjsu::device::Endian)0, sjsu::Apds9960Interface::MemoryMap_t>::Device()>
   110c8:	687b      	ldr	r3, [r7, #4]
   110ca:	4618      	mov	r0, r3
   110cc:	3708      	adds	r7, #8
   110ce:	46bd      	mov	sp, r7
   110d0:	bd80      	pop	{r7, pc}

000110d2 <sjsu::Device<sjsu::I2cDevice<&sjsu::Apds9960::i2c, (unsigned char)57, (sjsu::device::Endian)0, sjsu::Apds9960Interface::MemoryMap_t>, (sjsu::device::Endian)0, sjsu::Apds9960Interface::MemoryMap_t>::Device()>:
  constexpr Device() : memory(*kMapAtAddressZero)
   110d2:	b480      	push	{r7}
   110d4:	b083      	sub	sp, #12
   110d6:	af00      	add	r7, sp, #0
   110d8:	6078      	str	r0, [r7, #4]
   110da:	687b      	ldr	r3, [r7, #4]
   110dc:	2200      	movs	r2, #0
   110de:	601a      	str	r2, [r3, #0]
  }
   110e0:	687b      	ldr	r3, [r7, #4]
   110e2:	4618      	mov	r0, r3
   110e4:	370c      	adds	r7, #12
   110e6:	46bd      	mov	sp, r7
   110e8:	f85d 7b04 	ldr.w	r7, [sp], #4
   110ec:	4770      	bx	lr
   110ee:	Address 0x00000000000110ee is out of bounds.


000110f0 <__static_initialization_and_destruction_0(int, int)>:
    }
  }

  return 0;
}
   110f0:	b580      	push	{r7, lr}
   110f2:	b082      	sub	sp, #8
   110f4:	af00      	add	r7, sp, #0
   110f6:	6078      	str	r0, [r7, #4]
   110f8:	6039      	str	r1, [r7, #0]
   110fa:	687b      	ldr	r3, [r7, #4]
   110fc:	2b01      	cmp	r3, #1
   110fe:	d110      	bne.n	11122 <__static_initialization_and_destruction_0(int, int)+0x32>
   11100:	683b      	ldr	r3, [r7, #0]
   11102:	f64f 72ff 	movw	r2, #65535	; 0xffff
   11106:	4293      	cmp	r3, r2
   11108:	d10b      	bne.n	11122 <__static_initialization_and_destruction_0(int, int)+0x32>
 private:
  inline static sjsu::lpc40xx::I2c i2c =
      sjsu::lpc40xx::I2c(sjsu::lpc40xx::I2c::Bus::kI2c2);
  inline static I2cDevice<&i2c, 0x39, device::Endian::kLittle,
                          Apds9960Interface::MemoryMap_t>
      gesture;
   1110a:	4b08      	ldr	r3, [pc, #32]	; (1112c <__static_initialization_and_destruction_0(int, int)+0x3c>)
   1110c:	681b      	ldr	r3, [r3, #0]
   1110e:	f003 0301 	and.w	r3, r3, #1
   11112:	2b00      	cmp	r3, #0
   11114:	d105      	bne.n	11122 <__static_initialization_and_destruction_0(int, int)+0x32>
   11116:	4b05      	ldr	r3, [pc, #20]	; (1112c <__static_initialization_and_destruction_0(int, int)+0x3c>)
   11118:	2201      	movs	r2, #1
   1111a:	601a      	str	r2, [r3, #0]
   1111c:	4804      	ldr	r0, [pc, #16]	; (11130 <__static_initialization_and_destruction_0(int, int)+0x40>)
   1111e:	f7ff ffcb 	bl	110b8 <sjsu::I2cDevice<&sjsu::Apds9960::i2c, (unsigned char)57, (sjsu::device::Endian)0, sjsu::Apds9960Interface::MemoryMap_t>::I2cDevice()>
   11122:	bf00      	nop
   11124:	3708      	adds	r7, #8
   11126:	46bd      	mov	sp, r7
   11128:	bd80      	pop	{r7, pc}
   1112a:	bf00      	nop
   1112c:	1000031c 	.word	0x1000031c
   11130:	10000318 	.word	0x10000318

00011134 <_GLOBAL__sub_I_main>:
   11134:	b580      	push	{r7, lr}
   11136:	af00      	add	r7, sp, #0
   11138:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1113c:	2001      	movs	r0, #1
   1113e:	f7ff ffd7 	bl	110f0 <__static_initialization_and_destruction_0(int, int)>
   11142:	bd80      	pop	{r7, pc}

00011144 <sjsu::SetUptimeFunction(unsigned long long (*)())>:
{
   11144:	b480      	push	{r7}
   11146:	b083      	sub	sp, #12
   11148:	af00      	add	r7, sp, #0
   1114a:	6078      	str	r0, [r7, #4]
  Uptime = uptime_function;
   1114c:	4a04      	ldr	r2, [pc, #16]	; (11160 <sjsu::SetUptimeFunction(unsigned long long (*)())+0x1c>)
   1114e:	687b      	ldr	r3, [r7, #4]
   11150:	6013      	str	r3, [r2, #0]
}
   11152:	bf00      	nop
   11154:	370c      	adds	r7, #12
   11156:	46bd      	mov	sp, r7
   11158:	f85d 7b04 	ldr.w	r7, [sp], #4
   1115c:	4770      	bx	lr
   1115e:	bf00      	nop
   11160:	10000004 	.word	0x10000004

00011164 <sjsu::lpc40xx::SystemController::SetClockFrequency(unsigned char) const>:
  static constexpr uint32_t kDefaultIRCFrequency    = 12'000'000;
  static constexpr uint32_t kDefaultTimeout         = 1'000;  // ms

  inline static LPC_SC_TypeDef * system_controller = LPC_SC;

  uint32_t SetClockFrequency(uint8_t frequency_in_mhz) const final override
   11164:	b580      	push	{r7, lr}
   11166:	b084      	sub	sp, #16
   11168:	af00      	add	r7, sp, #0
   1116a:	6078      	str	r0, [r7, #4]
   1116c:	460b      	mov	r3, r1
   1116e:	70fb      	strb	r3, [r7, #3]
  {
    uint32_t offset = 0;
   11170:	2300      	movs	r3, #0
   11172:	60fb      	str	r3, [r7, #12]
    SelectOscillatorSource(OscillatorSource::kIrc);
   11174:	2100      	movs	r1, #0
   11176:	6878      	ldr	r0, [r7, #4]
   11178:	f000 f8f2 	bl	11360 <sjsu::lpc40xx::SystemController::SelectOscillatorSource(sjsu::lpc40xx::SystemController::OscillatorSource) const>
    if (frequency_in_mhz > 12)
   1117c:	78fb      	ldrb	r3, [r7, #3]
   1117e:	2b0c      	cmp	r3, #12
   11180:	d914      	bls.n	111ac <sjsu::lpc40xx::SystemController::SetClockFrequency(unsigned char) const+0x48>
    {
      offset = SetMainPll(PllInput::kIrc, frequency_in_mhz);
   11182:	78fb      	ldrb	r3, [r7, #3]
   11184:	b29b      	uxth	r3, r3
   11186:	461a      	mov	r2, r3
   11188:	210c      	movs	r1, #12
   1118a:	6878      	ldr	r0, [r7, #4]
   1118c:	f000 f9c6 	bl	1151c <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const>
   11190:	60f8      	str	r0, [r7, #12]
      SelectMainClockSource(MainClockSource::kPllClock);
   11192:	f44f 7180 	mov.w	r1, #256	; 0x100
   11196:	6878      	ldr	r0, [r7, #4]
   11198:	f000 f8fe 	bl	11398 <sjsu::lpc40xx::SystemController::SelectMainClockSource(sjsu::lpc40xx::SystemController::MainClockSource) const>
      speed_in_hertz = frequency_in_mhz * 1'000'000;
   1119c:	78fb      	ldrb	r3, [r7, #3]
   1119e:	4a0f      	ldr	r2, [pc, #60]	; (111dc <sjsu::lpc40xx::SystemController::SetClockFrequency(unsigned char) const+0x78>)
   111a0:	fb02 f303 	mul.w	r3, r2, r3
   111a4:	461a      	mov	r2, r3
   111a6:	4b0e      	ldr	r3, [pc, #56]	; (111e0 <sjsu::lpc40xx::SystemController::SetClockFrequency(unsigned char) const+0x7c>)
   111a8:	601a      	str	r2, [r3, #0]
   111aa:	e006      	b.n	111ba <sjsu::lpc40xx::SystemController::SetClockFrequency(unsigned char) const+0x56>
    }
    else
    {
      SelectMainClockSource(MainClockSource::kBaseClock);
   111ac:	2100      	movs	r1, #0
   111ae:	6878      	ldr	r0, [r7, #4]
   111b0:	f000 f8f2 	bl	11398 <sjsu::lpc40xx::SystemController::SelectMainClockSource(sjsu::lpc40xx::SystemController::MainClockSource) const>
      speed_in_hertz = kDefaultIRCFrequency;
   111b4:	4b0a      	ldr	r3, [pc, #40]	; (111e0 <sjsu::lpc40xx::SystemController::SetClockFrequency(unsigned char) const+0x7c>)
   111b6:	4a0b      	ldr	r2, [pc, #44]	; (111e4 <sjsu::lpc40xx::SystemController::SetClockFrequency(unsigned char) const+0x80>)
   111b8:	601a      	str	r2, [r3, #0]
    }
    SetCpuClockDivider(kDivideInputBy1);
   111ba:	2101      	movs	r1, #1
   111bc:	6878      	ldr	r0, [r7, #4]
   111be:	f000 fa5f 	bl	11680 <sjsu::lpc40xx::SystemController::SetCpuClockDivider(unsigned char) const>
    SetPeripheralClockDivider(kDivideInputBy1);
   111c2:	2101      	movs	r1, #1
   111c4:	6878      	ldr	r0, [r7, #4]
   111c6:	f000 f80f 	bl	111e8 <sjsu::lpc40xx::SystemController::SetPeripheralClockDivider(unsigned char) const>
    SetEmcClockDivider(EmcDivider::kSameSpeedAsCpu);
   111ca:	2100      	movs	r1, #0
   111cc:	6878      	ldr	r0, [r7, #4]
   111ce:	f000 fa89 	bl	116e4 <sjsu::lpc40xx::SystemController::SetEmcClockDivider(sjsu::lpc40xx::SystemController::EmcDivider) const>
    return offset;
   111d2:	68fb      	ldr	r3, [r7, #12]
  }
   111d4:	4618      	mov	r0, r3
   111d6:	3710      	adds	r7, #16
   111d8:	46bd      	mov	sp, r7
   111da:	bd80      	pop	{r7, pc}
   111dc:	000f4240 	.word	0x000f4240
   111e0:	1000008c 	.word	0x1000008c
   111e4:	00b71b00 	.word	0x00b71b00

000111e8 <sjsu::lpc40xx::SystemController::SetPeripheralClockDivider(unsigned char) const>:

  void SetPeripheralClockDivider(
   111e8:	b580      	push	{r7, lr}
   111ea:	b082      	sub	sp, #8
   111ec:	af00      	add	r7, sp, #0
   111ee:	6078      	str	r0, [r7, #4]
   111f0:	460b      	mov	r3, r1
   111f2:	70fb      	strb	r3, [r7, #3]
      uint8_t peripheral_divider) const final override
  {
    SJ2_ASSERT_FATAL(peripheral_divider <= 4, "Divider mustn't exceed 32");
   111f4:	78fb      	ldrb	r3, [r7, #3]
   111f6:	2b04      	cmp	r3, #4
   111f8:	d90d      	bls.n	11216 <sjsu::lpc40xx::SystemController::SetPeripheralClockDivider(unsigned char) const+0x2e>
   111fa:	2398      	movs	r3, #152	; 0x98
   111fc:	4a0a      	ldr	r2, [pc, #40]	; (11228 <sjsu::lpc40xx::SystemController::SetPeripheralClockDivider(unsigned char) const+0x40>)
   111fe:	490b      	ldr	r1, [pc, #44]	; (1122c <sjsu::lpc40xx::SystemController::SetPeripheralClockDivider(unsigned char) const+0x44>)
   11200:	480b      	ldr	r0, [pc, #44]	; (11230 <sjsu::lpc40xx::SystemController::SetPeripheralClockDivider(unsigned char) const+0x48>)
   11202:	f002 f957 	bl	134b4 <printf>
   11206:	480b      	ldr	r0, [pc, #44]	; (11234 <sjsu::lpc40xx::SystemController::SetPeripheralClockDivider(unsigned char) const+0x4c>)
   11208:	f000 ff84 	bl	12114 <puts>
   1120c:	2100      	movs	r1, #0
   1120e:	2001      	movs	r0, #1
   11210:	f7ff fa36 	bl	10680 <sjsu::debug::PrintBacktrace(bool, void*)>
   11214:	e7fe      	b.n	11214 <sjsu::lpc40xx::SystemController::SetPeripheralClockDivider(unsigned char) const+0x2c>
    system_controller->PCLKSEL = peripheral_divider;
   11216:	4b08      	ldr	r3, [pc, #32]	; (11238 <sjsu::lpc40xx::SystemController::SetPeripheralClockDivider(unsigned char) const+0x50>)
   11218:	681b      	ldr	r3, [r3, #0]
   1121a:	78fa      	ldrb	r2, [r7, #3]
   1121c:	f8c3 21a8 	str.w	r2, [r3, #424]	; 0x1a8
  }
   11220:	bf00      	nop
   11222:	3708      	adds	r7, #8
   11224:	46bd      	mov	sp, r7
   11226:	bd80      	pop	{r7, pc}
   11228:	00015840 	.word	0x00015840
   1122c:	00015628 	.word	0x00015628
   11230:	00015024 	.word	0x00015024
   11234:	000150c4 	.word	0x000150c4
   11238:	10000088 	.word	0x10000088

0001123c <sjsu::lpc40xx::SystemController::GetPeripheralClockDivider() const>:

  uint32_t GetPeripheralClockDivider() const final override
   1123c:	b480      	push	{r7}
   1123e:	b083      	sub	sp, #12
   11240:	af00      	add	r7, sp, #0
   11242:	6078      	str	r0, [r7, #4]
    {
      return 1;
    }
    else
    {
      return system_controller->PCLKSEL;
   11244:	4b04      	ldr	r3, [pc, #16]	; (11258 <sjsu::lpc40xx::SystemController::GetPeripheralClockDivider() const+0x1c>)
   11246:	681b      	ldr	r3, [r3, #0]
   11248:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
    }
  }
   1124c:	4618      	mov	r0, r3
   1124e:	370c      	adds	r7, #12
   11250:	46bd      	mov	sp, r7
   11252:	f85d 7b04 	ldr.w	r7, [sp], #4
   11256:	4770      	bx	lr
   11258:	10000088 	.word	0x10000088

0001125c <sjsu::lpc40xx::SystemController::GetSystemFrequency() const>:

  uint32_t GetSystemFrequency() const final override
   1125c:	b480      	push	{r7}
   1125e:	b083      	sub	sp, #12
   11260:	af00      	add	r7, sp, #0
   11262:	6078      	str	r0, [r7, #4]
    {
      return config::kSystemClockRate;
    }
    else
    {
      return speed_in_hertz;
   11264:	4b03      	ldr	r3, [pc, #12]	; (11274 <sjsu::lpc40xx::SystemController::GetSystemFrequency() const+0x18>)
   11266:	681b      	ldr	r3, [r3, #0]
    }
  }
   11268:	4618      	mov	r0, r3
   1126a:	370c      	adds	r7, #12
   1126c:	46bd      	mov	sp, r7
   1126e:	f85d 7b04 	ldr.w	r7, [sp], #4
   11272:	4770      	bx	lr
   11274:	1000008c 	.word	0x1000008c

00011278 <sjsu::lpc40xx::SystemController::GetPeripheralFrequency() const>:

  uint32_t GetPeripheralFrequency() const final override
   11278:	b580      	push	{r7, lr}
   1127a:	b084      	sub	sp, #16
   1127c:	af00      	add	r7, sp, #0
   1127e:	6078      	str	r0, [r7, #4]
  {
    uint32_t peripheral_clock_divider = GetPeripheralClockDivider();
   11280:	6878      	ldr	r0, [r7, #4]
   11282:	f7ff ffdb 	bl	1123c <sjsu::lpc40xx::SystemController::GetPeripheralClockDivider() const>
   11286:	60b8      	str	r0, [r7, #8]
    uint32_t result = 0;  // return 0 if peripheral_clock_divider == 0
   11288:	2300      	movs	r3, #0
   1128a:	60fb      	str	r3, [r7, #12]
    if (peripheral_clock_divider != 0)
   1128c:	68bb      	ldr	r3, [r7, #8]
   1128e:	2b00      	cmp	r3, #0
   11290:	d007      	beq.n	112a2 <sjsu::lpc40xx::SystemController::GetPeripheralFrequency() const+0x2a>
    {
      result = GetSystemFrequency() / peripheral_clock_divider;
   11292:	6878      	ldr	r0, [r7, #4]
   11294:	f7ff ffe2 	bl	1125c <sjsu::lpc40xx::SystemController::GetSystemFrequency() const>
   11298:	4602      	mov	r2, r0
   1129a:	68bb      	ldr	r3, [r7, #8]
   1129c:	fbb2 f3f3 	udiv	r3, r2, r3
   112a0:	60fb      	str	r3, [r7, #12]
    }
    return result;
   112a2:	68fb      	ldr	r3, [r7, #12]
  }
   112a4:	4618      	mov	r0, r3
   112a6:	3710      	adds	r7, #16
   112a8:	46bd      	mov	sp, r7
   112aa:	bd80      	pop	{r7, pc}

000112ac <sjsu::lpc40xx::SystemController::IsPeripheralPoweredUp(sjsu::SystemController::PeripheralID const&) const>:
  /// Check if a peripheral is powered up by checking the power connection
  /// register. Should typically only be used for unit testing code and
  /// debugging.
  bool IsPeripheralPoweredUp(
   112ac:	b480      	push	{r7}
   112ae:	b085      	sub	sp, #20
   112b0:	af00      	add	r7, sp, #0
   112b2:	6078      	str	r0, [r7, #4]
   112b4:	6039      	str	r1, [r7, #0]
      const PeripheralID & peripheral_select) const final override
  {
    bool peripheral_is_powered_on =
        system_controller->PCONP & (1 << peripheral_select.device_id);
   112b6:	4b0b      	ldr	r3, [pc, #44]	; (112e4 <sjsu::lpc40xx::SystemController::IsPeripheralPoweredUp(sjsu::SystemController::PeripheralID const&) const+0x38>)
   112b8:	681b      	ldr	r3, [r3, #0]
   112ba:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
   112be:	683a      	ldr	r2, [r7, #0]
   112c0:	6812      	ldr	r2, [r2, #0]
   112c2:	2101      	movs	r1, #1
   112c4:	fa01 f202 	lsl.w	r2, r1, r2
   112c8:	4013      	ands	r3, r2
   112ca:	2b00      	cmp	r3, #0
   112cc:	bf14      	ite	ne
   112ce:	2301      	movne	r3, #1
   112d0:	2300      	moveq	r3, #0
   112d2:	73fb      	strb	r3, [r7, #15]

    return peripheral_is_powered_on;
   112d4:	7bfb      	ldrb	r3, [r7, #15]
  }
   112d6:	4618      	mov	r0, r3
   112d8:	3714      	adds	r7, #20
   112da:	46bd      	mov	sp, r7
   112dc:	f85d 7b04 	ldr.w	r7, [sp], #4
   112e0:	4770      	bx	lr
   112e2:	bf00      	nop
   112e4:	10000088 	.word	0x10000088

000112e8 <sjsu::lpc40xx::SystemController::PowerUpPeripheral(sjsu::SystemController::PeripheralID const&) const>:
  void PowerUpPeripheral(
   112e8:	b480      	push	{r7}
   112ea:	b085      	sub	sp, #20
   112ec:	af00      	add	r7, sp, #0
   112ee:	6078      	str	r0, [r7, #4]
   112f0:	6039      	str	r1, [r7, #0]
      const PeripheralID & peripheral_select) const final override
  {
    auto power_connection_with_enabled_peripheral =
        system_controller->PCONP | (1 << peripheral_select.device_id);
   112f2:	4b0b      	ldr	r3, [pc, #44]	; (11320 <sjsu::lpc40xx::SystemController::PowerUpPeripheral(sjsu::SystemController::PeripheralID const&) const+0x38>)
   112f4:	681b      	ldr	r3, [r3, #0]
   112f6:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
   112fa:	683a      	ldr	r2, [r7, #0]
   112fc:	6812      	ldr	r2, [r2, #0]
   112fe:	2101      	movs	r1, #1
   11300:	fa01 f202 	lsl.w	r2, r1, r2
   11304:	4313      	orrs	r3, r2
   11306:	60fb      	str	r3, [r7, #12]

    system_controller->PCONP = power_connection_with_enabled_peripheral;
   11308:	4b05      	ldr	r3, [pc, #20]	; (11320 <sjsu::lpc40xx::SystemController::PowerUpPeripheral(sjsu::SystemController::PeripheralID const&) const+0x38>)
   1130a:	681b      	ldr	r3, [r3, #0]
   1130c:	68fa      	ldr	r2, [r7, #12]
   1130e:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
  }
   11312:	bf00      	nop
   11314:	3714      	adds	r7, #20
   11316:	46bd      	mov	sp, r7
   11318:	f85d 7b04 	ldr.w	r7, [sp], #4
   1131c:	4770      	bx	lr
   1131e:	bf00      	nop
   11320:	10000088 	.word	0x10000088

00011324 <sjsu::lpc40xx::SystemController::PowerDownPeripheral(sjsu::SystemController::PeripheralID const&) const>:
  void PowerDownPeripheral(
   11324:	b480      	push	{r7}
   11326:	b085      	sub	sp, #20
   11328:	af00      	add	r7, sp, #0
   1132a:	6078      	str	r0, [r7, #4]
   1132c:	6039      	str	r1, [r7, #0]
      const PeripheralID & peripheral_select) const final override
  {
    auto power_connection_without_enabled_peripheral =
        system_controller->PCONP & (1 << peripheral_select.device_id);
   1132e:	4b0b      	ldr	r3, [pc, #44]	; (1135c <sjsu::lpc40xx::SystemController::PowerDownPeripheral(sjsu::SystemController::PeripheralID const&) const+0x38>)
   11330:	681b      	ldr	r3, [r3, #0]
   11332:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
   11336:	683a      	ldr	r2, [r7, #0]
   11338:	6812      	ldr	r2, [r2, #0]
   1133a:	2101      	movs	r1, #1
   1133c:	fa01 f202 	lsl.w	r2, r1, r2
   11340:	4013      	ands	r3, r2
   11342:	60fb      	str	r3, [r7, #12]

    system_controller->PCONP = power_connection_without_enabled_peripheral;
   11344:	4b05      	ldr	r3, [pc, #20]	; (1135c <sjsu::lpc40xx::SystemController::PowerDownPeripheral(sjsu::SystemController::PeripheralID const&) const+0x38>)
   11346:	681b      	ldr	r3, [r3, #0]
   11348:	68fa      	ldr	r2, [r7, #12]
   1134a:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
  }
   1134e:	bf00      	nop
   11350:	3714      	adds	r7, #20
   11352:	46bd      	mov	sp, r7
   11354:	f85d 7b04 	ldr.w	r7, [sp], #4
   11358:	4770      	bx	lr
   1135a:	bf00      	nop
   1135c:	10000088 	.word	0x10000088

00011360 <sjsu::lpc40xx::SystemController::SelectOscillatorSource(sjsu::lpc40xx::SystemController::OscillatorSource) const>:

 private:
  void SelectOscillatorSource(OscillatorSource source) const
   11360:	b480      	push	{r7}
   11362:	b085      	sub	sp, #20
   11364:	af00      	add	r7, sp, #0
   11366:	6078      	str	r0, [r7, #4]
   11368:	460b      	mov	r3, r1
   1136a:	807b      	strh	r3, [r7, #2]
  {
    uint32_t source_bit = static_cast<uint32_t>(source);
   1136c:	887b      	ldrh	r3, [r7, #2]
   1136e:	60fb      	str	r3, [r7, #12]
    system_controller->CLKSRCSEL =
        (system_controller->CLKSRCSEL & ~(kOscillatorSelect)) | source_bit;
   11370:	4b08      	ldr	r3, [pc, #32]	; (11394 <sjsu::lpc40xx::SystemController::SelectOscillatorSource(sjsu::lpc40xx::SystemController::OscillatorSource) const+0x34>)
   11372:	681b      	ldr	r3, [r3, #0]
   11374:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
   11378:	f023 0101 	bic.w	r1, r3, #1
    system_controller->CLKSRCSEL =
   1137c:	4b05      	ldr	r3, [pc, #20]	; (11394 <sjsu::lpc40xx::SystemController::SelectOscillatorSource(sjsu::lpc40xx::SystemController::OscillatorSource) const+0x34>)
   1137e:	681b      	ldr	r3, [r3, #0]
        (system_controller->CLKSRCSEL & ~(kOscillatorSelect)) | source_bit;
   11380:	68fa      	ldr	r2, [r7, #12]
   11382:	430a      	orrs	r2, r1
    system_controller->CLKSRCSEL =
   11384:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
  }
   11388:	bf00      	nop
   1138a:	3714      	adds	r7, #20
   1138c:	46bd      	mov	sp, r7
   1138e:	f85d 7b04 	ldr.w	r7, [sp], #4
   11392:	4770      	bx	lr
   11394:	10000088 	.word	0x10000088

00011398 <sjsu::lpc40xx::SystemController::SelectMainClockSource(sjsu::lpc40xx::SystemController::MainClockSource) const>:

  void SelectMainClockSource(MainClockSource source) const
   11398:	b480      	push	{r7}
   1139a:	b083      	sub	sp, #12
   1139c:	af00      	add	r7, sp, #0
   1139e:	6078      	str	r0, [r7, #4]
   113a0:	460b      	mov	r3, r1
   113a2:	807b      	strh	r3, [r7, #2]
  {
    system_controller->CCLKSEL =
        (system_controller->CCLKSEL & ~(kBaseClockSelect)) |
   113a4:	4b08      	ldr	r3, [pc, #32]	; (113c8 <sjsu::lpc40xx::SystemController::SelectMainClockSource(sjsu::lpc40xx::SystemController::MainClockSource) const+0x30>)
   113a6:	681b      	ldr	r3, [r3, #0]
   113a8:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
   113ac:	f423 7180 	bic.w	r1, r3, #256	; 0x100
        static_cast<uint32_t>(source);
   113b0:	887a      	ldrh	r2, [r7, #2]
    system_controller->CCLKSEL =
   113b2:	4b05      	ldr	r3, [pc, #20]	; (113c8 <sjsu::lpc40xx::SystemController::SelectMainClockSource(sjsu::lpc40xx::SystemController::MainClockSource) const+0x30>)
   113b4:	681b      	ldr	r3, [r3, #0]
        (system_controller->CCLKSEL & ~(kBaseClockSelect)) |
   113b6:	430a      	orrs	r2, r1
    system_controller->CCLKSEL =
   113b8:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
  }
   113bc:	bf00      	nop
   113be:	370c      	adds	r7, #12
   113c0:	46bd      	mov	sp, r7
   113c2:	f85d 7b04 	ldr.w	r7, [sp], #4
   113c6:	4770      	bx	lr
   113c8:	10000088 	.word	0x10000088

000113cc <sjsu::lpc40xx::SystemController::SelectUsbClockSource(sjsu::lpc40xx::SystemController::UsbSource) const>:

  void SelectUsbClockSource(UsbSource usb_clock) const
   113cc:	b480      	push	{r7}
   113ce:	b083      	sub	sp, #12
   113d0:	af00      	add	r7, sp, #0
   113d2:	6078      	str	r0, [r7, #4]
   113d4:	460b      	mov	r3, r1
   113d6:	807b      	strh	r3, [r7, #2]
  {
    system_controller->USBCLKSEL =
        (system_controller->USBCLKSEL & ~(kUsbClockSource)) |
   113d8:	4b08      	ldr	r3, [pc, #32]	; (113fc <sjsu::lpc40xx::SystemController::SelectUsbClockSource(sjsu::lpc40xx::SystemController::UsbSource) const+0x30>)
   113da:	681b      	ldr	r3, [r3, #0]
   113dc:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
   113e0:	f423 7140 	bic.w	r1, r3, #768	; 0x300
        static_cast<uint32_t>(usb_clock);
   113e4:	887a      	ldrh	r2, [r7, #2]
    system_controller->USBCLKSEL =
   113e6:	4b05      	ldr	r3, [pc, #20]	; (113fc <sjsu::lpc40xx::SystemController::SelectUsbClockSource(sjsu::lpc40xx::SystemController::UsbSource) const+0x30>)
   113e8:	681b      	ldr	r3, [r3, #0]
        (system_controller->USBCLKSEL & ~(kUsbClockSource)) |
   113ea:	430a      	orrs	r2, r1
    system_controller->USBCLKSEL =
   113ec:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
  }
   113f0:	bf00      	nop
   113f2:	370c      	adds	r7, #12
   113f4:	46bd      	mov	sp, r7
   113f6:	f85d 7b04 	ldr.w	r7, [sp], #4
   113fa:	4770      	bx	lr
   113fc:	10000088 	.word	0x10000088

00011400 <sjsu::lpc40xx::SystemController::SelectSpifiClockSource(sjsu::lpc40xx::SystemController::SpifiSource) const>:

  void SelectSpifiClockSource(SpifiSource spifi_clock) const
   11400:	b480      	push	{r7}
   11402:	b083      	sub	sp, #12
   11404:	af00      	add	r7, sp, #0
   11406:	6078      	str	r0, [r7, #4]
   11408:	460b      	mov	r3, r1
   1140a:	807b      	strh	r3, [r7, #2]
  {
    system_controller->SPIFISEL =
        (system_controller->SPIFISEL & ~(kSpifiClockSource)) |
   1140c:	4b08      	ldr	r3, [pc, #32]	; (11430 <sjsu::lpc40xx::SystemController::SelectSpifiClockSource(sjsu::lpc40xx::SystemController::SpifiSource) const+0x30>)
   1140e:	681b      	ldr	r3, [r3, #0]
   11410:	f8d3 31b4 	ldr.w	r3, [r3, #436]	; 0x1b4
   11414:	f423 7140 	bic.w	r1, r3, #768	; 0x300
        static_cast<uint32_t>(spifi_clock);
   11418:	887a      	ldrh	r2, [r7, #2]
    system_controller->SPIFISEL =
   1141a:	4b05      	ldr	r3, [pc, #20]	; (11430 <sjsu::lpc40xx::SystemController::SelectSpifiClockSource(sjsu::lpc40xx::SystemController::SpifiSource) const+0x30>)
   1141c:	681b      	ldr	r3, [r3, #0]
        (system_controller->SPIFISEL & ~(kSpifiClockSource)) |
   1141e:	430a      	orrs	r2, r1
    system_controller->SPIFISEL =
   11420:	f8c3 21b4 	str.w	r2, [r3, #436]	; 0x1b4
  }
   11424:	bf00      	nop
   11426:	370c      	adds	r7, #12
   11428:	46bd      	mov	sp, r7
   1142a:	f85d 7b04 	ldr.w	r7, [sp], #4
   1142e:	4770      	bx	lr
   11430:	10000088 	.word	0x10000088

00011434 <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const>:

  uint32_t CalculatePll(PllInput input_frequency,
   11434:	b580      	push	{r7, lr}
   11436:	b086      	sub	sp, #24
   11438:	af00      	add	r7, sp, #0
   1143a:	6078      	str	r0, [r7, #4]
   1143c:	460b      	mov	r3, r1
   1143e:	807b      	strh	r3, [r7, #2]
   11440:	4613      	mov	r3, r2
   11442:	803b      	strh	r3, [r7, #0]
                        uint16_t desired_speed_in_mhz) const
  {
    SJ2_ASSERT_FATAL(desired_speed_in_mhz < 384 && desired_speed_in_mhz > 12,
   11444:	883b      	ldrh	r3, [r7, #0]
   11446:	f5b3 7fc0 	cmp.w	r3, #384	; 0x180
   1144a:	d202      	bcs.n	11452 <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x1e>
   1144c:	883b      	ldrh	r3, [r7, #0]
   1144e:	2b0c      	cmp	r3, #12
   11450:	d80d      	bhi.n	1146e <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x3a>
   11452:	23fc      	movs	r3, #252	; 0xfc
   11454:	4a2b      	ldr	r2, [pc, #172]	; (11504 <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0xd0>)
   11456:	492c      	ldr	r1, [pc, #176]	; (11508 <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0xd4>)
   11458:	482c      	ldr	r0, [pc, #176]	; (1150c <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0xd8>)
   1145a:	f002 f82b 	bl	134b4 <printf>
   1145e:	482c      	ldr	r0, [pc, #176]	; (11510 <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0xdc>)
   11460:	f000 fe58 	bl	12114 <puts>
   11464:	2100      	movs	r1, #0
   11466:	2001      	movs	r0, #1
   11468:	f7ff f90a 	bl	10680 <sjsu::debug::PrintBacktrace(bool, void*)>
   1146c:	e7fe      	b.n	1146c <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x38>
                     "Frequency must be lower than 384 MHz"
                     "and greater than or equal to 12 MHz");
    bool calculating = true;
   1146e:	2301      	movs	r3, #1
   11470:	75fb      	strb	r3, [r7, #23]
    uint32_t multiplier_value;
    if ((desired_speed_in_mhz % static_cast<uint16_t>(input_frequency)) >= 1)
   11472:	883b      	ldrh	r3, [r7, #0]
   11474:	887a      	ldrh	r2, [r7, #2]
   11476:	fbb3 f1f2 	udiv	r1, r3, r2
   1147a:	fb02 f201 	mul.w	r2, r2, r1
   1147e:	1a9b      	subs	r3, r3, r2
   11480:	b29b      	uxth	r3, r3
   11482:	2b00      	cmp	r3, #0
   11484:	d007      	beq.n	11496 <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x62>
    {
      multiplier_value = static_cast<uint32_t>(
          (desired_speed_in_mhz / static_cast<uint16_t>(input_frequency)) + 1);
   11486:	883a      	ldrh	r2, [r7, #0]
   11488:	887b      	ldrh	r3, [r7, #2]
   1148a:	fbb2 f3f3 	udiv	r3, r2, r3
   1148e:	b29b      	uxth	r3, r3
   11490:	3301      	adds	r3, #1
      multiplier_value = static_cast<uint32_t>(
   11492:	613b      	str	r3, [r7, #16]
   11494:	e005      	b.n	114a2 <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x6e>
    }
    else
    {
      multiplier_value = static_cast<uint32_t>(
          desired_speed_in_mhz / static_cast<uint16_t>(input_frequency));
   11496:	883a      	ldrh	r2, [r7, #0]
   11498:	887b      	ldrh	r3, [r7, #2]
   1149a:	fbb2 f3f3 	udiv	r3, r2, r3
   1149e:	b29b      	uxth	r3, r3
      multiplier_value = static_cast<uint32_t>(
   114a0:	613b      	str	r3, [r7, #16]
    }
    uint16_t divider_value = 1;
   114a2:	2301      	movs	r3, #1
   114a4:	81fb      	strh	r3, [r7, #14]
    while (calculating)
   114a6:	7dfb      	ldrb	r3, [r7, #23]
   114a8:	2b00      	cmp	r3, #0
   114aa:	d026      	beq.n	114fa <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0xc6>
    {
      uint16_t current_controlled_oscillator_frequency;
      current_controlled_oscillator_frequency = static_cast<uint16_t>(
   114ac:	693b      	ldr	r3, [r7, #16]
   114ae:	b29b      	uxth	r3, r3
   114b0:	887a      	ldrh	r2, [r7, #2]
   114b2:	fb12 f303 	smulbb	r3, r2, r3
   114b6:	b29b      	uxth	r3, r3
   114b8:	89fa      	ldrh	r2, [r7, #14]
   114ba:	fb12 f303 	smulbb	r3, r2, r3
   114be:	b29b      	uxth	r3, r3
   114c0:	005b      	lsls	r3, r3, #1
   114c2:	81bb      	strh	r3, [r7, #12]
          (static_cast<uint16_t>(input_frequency) * multiplier_value * 2) *
          divider_value);
      if (current_controlled_oscillator_frequency >= 156)
   114c4:	89bb      	ldrh	r3, [r7, #12]
   114c6:	2b9b      	cmp	r3, #155	; 0x9b
   114c8:	d902      	bls.n	114d0 <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x9c>
      {
        calculating = false;
   114ca:	2300      	movs	r3, #0
   114cc:	75fb      	strb	r3, [r7, #23]
   114ce:	e7ea      	b.n	114a6 <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x72>
      }
      else
      {
        divider_value = static_cast<uint16_t>(divider_value * 2);
   114d0:	89fb      	ldrh	r3, [r7, #14]
   114d2:	005b      	lsls	r3, r3, #1
   114d4:	81fb      	strh	r3, [r7, #14]
        SJ2_ASSERT_FATAL(divider_value < 8,
   114d6:	89fb      	ldrh	r3, [r7, #14]
   114d8:	2b07      	cmp	r3, #7
   114da:	d9e4      	bls.n	114a6 <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x72>
   114dc:	f44f 738c 	mov.w	r3, #280	; 0x118
   114e0:	4a08      	ldr	r2, [pc, #32]	; (11504 <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0xd0>)
   114e2:	490c      	ldr	r1, [pc, #48]	; (11514 <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0xe0>)
   114e4:	480c      	ldr	r0, [pc, #48]	; (11518 <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0xe4>)
   114e6:	f001 ffe5 	bl	134b4 <printf>
   114ea:	4809      	ldr	r0, [pc, #36]	; (11510 <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0xdc>)
   114ec:	f000 fe12 	bl	12114 <puts>
   114f0:	2100      	movs	r1, #0
   114f2:	2001      	movs	r0, #1
   114f4:	f7ff f8c4 	bl	10680 <sjsu::debug::PrintBacktrace(bool, void*)>
   114f8:	e7fe      	b.n	114f8 <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0xc4>
                         "PLL divider value went out of bounds");
      }
    }

    return multiplier_value;
   114fa:	693b      	ldr	r3, [r7, #16]
  }
   114fc:	4618      	mov	r0, r3
   114fe:	3718      	adds	r7, #24
   11500:	46bd      	mov	sp, r7
   11502:	bd80      	pop	{r7, pc}
   11504:	00015908 	.word	0x00015908
   11508:	00015640 	.word	0x00015640
   1150c:	000150dc 	.word	0x000150dc
   11510:	000150c4 	.word	0x000150c4
   11514:	00015658 	.word	0x00015658
   11518:	000151cc 	.word	0x000151cc

0001151c <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const>:

  uint32_t SetMainPll(PllInput input_frequency,
   1151c:	b590      	push	{r4, r7, lr}
   1151e:	b08b      	sub	sp, #44	; 0x2c
   11520:	af00      	add	r7, sp, #0
   11522:	6078      	str	r0, [r7, #4]
   11524:	460b      	mov	r3, r1
   11526:	807b      	strh	r3, [r7, #2]
   11528:	4613      	mov	r3, r2
   1152a:	803b      	strh	r3, [r7, #0]
                      uint16_t desired_speed_in_mhz) const
  {
    uint16_t divider_value = 1;
   1152c:	2301      	movs	r3, #1
   1152e:	837b      	strh	r3, [r7, #26]
    uint64_t timeout_time  = Milliseconds() + kDefaultTimeout;
   11530:	f7ff f904 	bl	1073c <sjsu::Milliseconds()>
   11534:	460a      	mov	r2, r1
   11536:	4601      	mov	r1, r0
   11538:	f511 737a 	adds.w	r3, r1, #1000	; 0x3e8
   1153c:	f142 0400 	adc.w	r4, r2, #0
   11540:	e9c7 3404 	strd	r3, r4, [r7, #16]
    uint64_t current_time  = Milliseconds();
   11544:	f7ff f8fa 	bl	1073c <sjsu::Milliseconds()>
   11548:	e9c7 0108 	strd	r0, r1, [r7, #32]
    uint32_t multiplier_value =
        CalculatePll(input_frequency, desired_speed_in_mhz);
   1154c:	883a      	ldrh	r2, [r7, #0]
   1154e:	887b      	ldrh	r3, [r7, #2]
   11550:	4619      	mov	r1, r3
   11552:	6878      	ldr	r0, [r7, #4]
   11554:	f7ff ff6e 	bl	11434 <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const>
   11558:	60f8      	str	r0, [r7, #12]
    uint32_t actual_speed =
        static_cast<uint32_t>(input_frequency) * multiplier_value;
   1155a:	887a      	ldrh	r2, [r7, #2]
    uint32_t actual_speed =
   1155c:	68fb      	ldr	r3, [r7, #12]
   1155e:	fb02 f303 	mul.w	r3, r2, r3
   11562:	61fb      	str	r3, [r7, #28]
    // TO DO: use registers to retreive values
    SelectOscillatorSource(OscillatorSource::kIrc);
   11564:	2100      	movs	r1, #0
   11566:	6878      	ldr	r0, [r7, #4]
   11568:	f7ff fefa 	bl	11360 <sjsu::lpc40xx::SystemController::SelectOscillatorSource(sjsu::lpc40xx::SystemController::OscillatorSource) const>
    SelectMainClockSource(MainClockSource::kBaseClock);
   1156c:	2100      	movs	r1, #0
   1156e:	6878      	ldr	r0, [r7, #4]
   11570:	f7ff ff12 	bl	11398 <sjsu::lpc40xx::SystemController::SelectMainClockSource(sjsu::lpc40xx::SystemController::MainClockSource) const>
    SelectUsbClockSource(UsbSource::kBaseClock);
   11574:	2100      	movs	r1, #0
   11576:	6878      	ldr	r0, [r7, #4]
   11578:	f7ff ff28 	bl	113cc <sjsu::lpc40xx::SystemController::SelectUsbClockSource(sjsu::lpc40xx::SystemController::UsbSource) const>
    SelectSpifiClockSource(SpifiSource::kBaseClock);
   1157c:	2100      	movs	r1, #0
   1157e:	6878      	ldr	r0, [r7, #4]
   11580:	f7ff ff3e 	bl	11400 <sjsu::lpc40xx::SystemController::SelectSpifiClockSource(sjsu::lpc40xx::SystemController::SpifiSource) const>
    // must subtract 1 from multiplier value as specified in datasheet
    system_controller->PLL0CFG =
        (system_controller->PLL0CFG & ~kClearPllMultiplier) |
   11584:	4b39      	ldr	r3, [pc, #228]	; (1166c <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x150>)
   11586:	681b      	ldr	r3, [r3, #0]
   11588:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
   1158c:	f023 011f 	bic.w	r1, r3, #31
        (multiplier_value - 1);
   11590:	68fb      	ldr	r3, [r7, #12]
   11592:	1e5a      	subs	r2, r3, #1
    system_controller->PLL0CFG =
   11594:	4b35      	ldr	r3, [pc, #212]	; (1166c <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x150>)
   11596:	681b      	ldr	r3, [r3, #0]
        (system_controller->PLL0CFG & ~kClearPllMultiplier) |
   11598:	430a      	orrs	r2, r1
    system_controller->PLL0CFG =
   1159a:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    system_controller->PLL0CFG =
        (system_controller->PLL0CFG & ~kClearPllDivider) | (divider_value << 5);
   1159e:	4b33      	ldr	r3, [pc, #204]	; (1166c <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x150>)
   115a0:	681b      	ldr	r3, [r3, #0]
   115a2:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
   115a6:	f023 0260 	bic.w	r2, r3, #96	; 0x60
   115aa:	8b7b      	ldrh	r3, [r7, #26]
   115ac:	015b      	lsls	r3, r3, #5
   115ae:	4619      	mov	r1, r3
    system_controller->PLL0CFG =
   115b0:	4b2e      	ldr	r3, [pc, #184]	; (1166c <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x150>)
   115b2:	681b      	ldr	r3, [r3, #0]
        (system_controller->PLL0CFG & ~kClearPllDivider) | (divider_value << 5);
   115b4:	430a      	orrs	r2, r1
    system_controller->PLL0CFG =
   115b6:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    system_controller->PLL0CON |= kEnablePll;
   115ba:	4b2c      	ldr	r3, [pc, #176]	; (1166c <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x150>)
   115bc:	681b      	ldr	r3, [r3, #0]
   115be:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
   115c2:	4b2a      	ldr	r3, [pc, #168]	; (1166c <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x150>)
   115c4:	681b      	ldr	r3, [r3, #0]
   115c6:	f042 0201 	orr.w	r2, r2, #1
   115ca:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    // nessecary feed sequence to ensure the changes are intentional
    system_controller->PLL0FEED = 0xAA;
   115ce:	4b27      	ldr	r3, [pc, #156]	; (1166c <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x150>)
   115d0:	681b      	ldr	r3, [r3, #0]
   115d2:	22aa      	movs	r2, #170	; 0xaa
   115d4:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
    system_controller->PLL0FEED = 0x55;
   115d8:	4b24      	ldr	r3, [pc, #144]	; (1166c <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x150>)
   115da:	681b      	ldr	r3, [r3, #0]
   115dc:	2255      	movs	r2, #85	; 0x55
   115de:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
    while (!(system_controller->PLL0STAT >> kPlock & 1) &&
   115e2:	4b22      	ldr	r3, [pc, #136]	; (1166c <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x150>)
   115e4:	681b      	ldr	r3, [r3, #0]
   115e6:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   115ea:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   115ee:	2b00      	cmp	r3, #0
   115f0:	d109      	bne.n	11606 <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0xea>
   115f2:	e9d7 1208 	ldrd	r1, r2, [r7, #32]
   115f6:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
   115fa:	42a2      	cmp	r2, r4
   115fc:	bf08      	it	eq
   115fe:	4299      	cmpeq	r1, r3
   11600:	d201      	bcs.n	11606 <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0xea>
   11602:	2301      	movs	r3, #1
   11604:	e000      	b.n	11608 <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0xec>
   11606:	2300      	movs	r3, #0
   11608:	2b00      	cmp	r3, #0
   1160a:	d004      	beq.n	11616 <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0xfa>
           (current_time < timeout_time))
    {
      current_time = Milliseconds();
   1160c:	f7ff f896 	bl	1073c <sjsu::Milliseconds()>
   11610:	e9c7 0108 	strd	r0, r1, [r7, #32]
    while (!(system_controller->PLL0STAT >> kPlock & 1) &&
   11614:	e7e5      	b.n	115e2 <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0xc6>
    }
    if (!(system_controller->PLL0STAT >> kPlock & 1) &&
   11616:	4b15      	ldr	r3, [pc, #84]	; (1166c <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x150>)
   11618:	681b      	ldr	r3, [r3, #0]
   1161a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   1161e:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   11622:	2b00      	cmp	r3, #0
   11624:	d109      	bne.n	1163a <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x11e>
   11626:	e9d7 1208 	ldrd	r1, r2, [r7, #32]
   1162a:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
   1162e:	42a2      	cmp	r2, r4
   11630:	bf08      	it	eq
   11632:	4299      	cmpeq	r1, r3
   11634:	d301      	bcc.n	1163a <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x11e>
   11636:	2301      	movs	r3, #1
   11638:	e000      	b.n	1163c <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x120>
   1163a:	2300      	movs	r3, #0
   1163c:	2b00      	cmp	r3, #0
   1163e:	d00e      	beq.n	1165e <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x142>
        (current_time >= timeout_time))
    {
      SJ2_ASSERT_FATAL(false,
   11640:	f240 1341 	movw	r3, #321	; 0x141
   11644:	4a0a      	ldr	r2, [pc, #40]	; (11670 <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x154>)
   11646:	490b      	ldr	r1, [pc, #44]	; (11674 <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x158>)
   11648:	480b      	ldr	r0, [pc, #44]	; (11678 <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x15c>)
   1164a:	f001 ff33 	bl	134b4 <printf>
   1164e:	480b      	ldr	r0, [pc, #44]	; (1167c <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x160>)
   11650:	f000 fd60 	bl	12114 <puts>
   11654:	2100      	movs	r1, #0
   11656:	2001      	movs	r0, #1
   11658:	f7ff f812 	bl	10680 <sjsu::debug::PrintBacktrace(bool, void*)>
   1165c:	e7fe      	b.n	1165c <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x140>
                       "PLL lock could not be established before timeout");
      actual_speed = kDefaultIRCFrequency;
    }
    return (actual_speed - desired_speed_in_mhz);
   1165e:	883b      	ldrh	r3, [r7, #0]
   11660:	69fa      	ldr	r2, [r7, #28]
   11662:	1ad3      	subs	r3, r2, r3
  }
   11664:	4618      	mov	r0, r3
   11666:	372c      	adds	r7, #44	; 0x2c
   11668:	46bd      	mov	sp, r7
   1166a:	bd90      	pop	{r4, r7, pc}
   1166c:	10000088 	.word	0x10000088
   11670:	00015898 	.word	0x00015898
   11674:	00015670 	.word	0x00015670
   11678:	00015274 	.word	0x00015274
   1167c:	000150c4 	.word	0x000150c4

00011680 <sjsu::lpc40xx::SystemController::SetCpuClockDivider(unsigned char) const>:
                       "PLL lock could not be established before timeout");
    }
    return (actual_speed - desired_speed_in_mhz);
  }

  void SetCpuClockDivider(uint8_t cpu_divider) const
   11680:	b580      	push	{r7, lr}
   11682:	b082      	sub	sp, #8
   11684:	af00      	add	r7, sp, #0
   11686:	6078      	str	r0, [r7, #4]
   11688:	460b      	mov	r3, r1
   1168a:	70fb      	strb	r3, [r7, #3]
  {
    SJ2_ASSERT_FATAL(cpu_divider < 32, "Divider mustn't exceed 32");
   1168c:	78fb      	ldrb	r3, [r7, #3]
   1168e:	2b1f      	cmp	r3, #31
   11690:	d90e      	bls.n	116b0 <sjsu::lpc40xx::SystemController::SetCpuClockDivider(unsigned char) const+0x30>
   11692:	f240 136d 	movw	r3, #365	; 0x16d
   11696:	4a0e      	ldr	r2, [pc, #56]	; (116d0 <sjsu::lpc40xx::SystemController::SetCpuClockDivider(unsigned char) const+0x50>)
   11698:	490e      	ldr	r1, [pc, #56]	; (116d4 <sjsu::lpc40xx::SystemController::SetCpuClockDivider(unsigned char) const+0x54>)
   1169a:	480f      	ldr	r0, [pc, #60]	; (116d8 <sjsu::lpc40xx::SystemController::SetCpuClockDivider(unsigned char) const+0x58>)
   1169c:	f001 ff0a 	bl	134b4 <printf>
   116a0:	480e      	ldr	r0, [pc, #56]	; (116dc <sjsu::lpc40xx::SystemController::SetCpuClockDivider(unsigned char) const+0x5c>)
   116a2:	f000 fd37 	bl	12114 <puts>
   116a6:	2100      	movs	r1, #0
   116a8:	2001      	movs	r0, #1
   116aa:	f7fe ffe9 	bl	10680 <sjsu::debug::PrintBacktrace(bool, void*)>
   116ae:	e7fe      	b.n	116ae <sjsu::lpc40xx::SystemController::SetCpuClockDivider(unsigned char) const+0x2e>
    system_controller->CCLKSEL =
        (system_controller->CCLKSEL & ~kClearCpuDivider) | cpu_divider;
   116b0:	4b0b      	ldr	r3, [pc, #44]	; (116e0 <sjsu::lpc40xx::SystemController::SetCpuClockDivider(unsigned char) const+0x60>)
   116b2:	681b      	ldr	r3, [r3, #0]
   116b4:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
   116b8:	f023 011f 	bic.w	r1, r3, #31
   116bc:	78fa      	ldrb	r2, [r7, #3]
    system_controller->CCLKSEL =
   116be:	4b08      	ldr	r3, [pc, #32]	; (116e0 <sjsu::lpc40xx::SystemController::SetCpuClockDivider(unsigned char) const+0x60>)
   116c0:	681b      	ldr	r3, [r3, #0]
        (system_controller->CCLKSEL & ~kClearCpuDivider) | cpu_divider;
   116c2:	430a      	orrs	r2, r1
    system_controller->CCLKSEL =
   116c4:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
  }
   116c8:	bf00      	nop
   116ca:	3708      	adds	r7, #8
   116cc:	46bd      	mov	sp, r7
   116ce:	bd80      	pop	{r7, pc}
   116d0:	0001597c 	.word	0x0001597c
   116d4:	00015688 	.word	0x00015688
   116d8:	0001531c 	.word	0x0001531c
   116dc:	000150c4 	.word	0x000150c4
   116e0:	10000088 	.word	0x10000088

000116e4 <sjsu::lpc40xx::SystemController::SetEmcClockDivider(sjsu::lpc40xx::SystemController::EmcDivider) const>:

  void SetEmcClockDivider(EmcDivider emc_divider) const
   116e4:	b480      	push	{r7}
   116e6:	b083      	sub	sp, #12
   116e8:	af00      	add	r7, sp, #0
   116ea:	6078      	str	r0, [r7, #4]
   116ec:	460b      	mov	r3, r1
   116ee:	70fb      	strb	r3, [r7, #3]
  {
    system_controller->EMCCLKSEL =
        (system_controller->EMCCLKSEL & ~kClearEmcDivider) |
   116f0:	4b08      	ldr	r3, [pc, #32]	; (11714 <sjsu::lpc40xx::SystemController::SetEmcClockDivider(sjsu::lpc40xx::SystemController::EmcDivider) const+0x30>)
   116f2:	681b      	ldr	r3, [r3, #0]
   116f4:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
   116f8:	f023 0101 	bic.w	r1, r3, #1
        static_cast<uint8_t>(emc_divider);
   116fc:	78fa      	ldrb	r2, [r7, #3]
    system_controller->EMCCLKSEL =
   116fe:	4b05      	ldr	r3, [pc, #20]	; (11714 <sjsu::lpc40xx::SystemController::SetEmcClockDivider(sjsu::lpc40xx::SystemController::EmcDivider) const+0x30>)
   11700:	681b      	ldr	r3, [r3, #0]
        (system_controller->EMCCLKSEL & ~kClearEmcDivider) |
   11702:	430a      	orrs	r2, r1
    system_controller->EMCCLKSEL =
   11704:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
  }
   11708:	bf00      	nop
   1170a:	370c      	adds	r7, #12
   1170c:	46bd      	mov	sp, r7
   1170e:	f85d 7b04 	ldr.w	r7, [sp], #4
   11712:	4770      	bx	lr
   11714:	10000088 	.word	0x10000088

00011718 <sjsu::lpc40xx::Timer::TimerHandler(sjsu::lpc40xx::Timer::ChannelPartial_t const&)>:
      .channel = kTimerPartial3,
      .isr     = TimerHandler<kTimerPartial3>,
    };
  };

  static void TimerHandler(const ChannelPartial_t & channel)
   11718:	b580      	push	{r7, lr}
   1171a:	b082      	sub	sp, #8
   1171c:	af00      	add	r7, sp, #0
   1171e:	6078      	str	r0, [r7, #4]
  {
    if (*channel.user_callback != nullptr)
   11720:	687b      	ldr	r3, [r7, #4]
   11722:	68db      	ldr	r3, [r3, #12]
   11724:	681b      	ldr	r3, [r3, #0]
   11726:	2b00      	cmp	r3, #0
   11728:	d003      	beq.n	11732 <sjsu::lpc40xx::Timer::TimerHandler(sjsu::lpc40xx::Timer::ChannelPartial_t const&)+0x1a>
    {
      (*channel.user_callback)();
   1172a:	687b      	ldr	r3, [r7, #4]
   1172c:	68db      	ldr	r3, [r3, #12]
   1172e:	681b      	ldr	r3, [r3, #0]
   11730:	4798      	blx	r3
    }
    channel.timer_register->IR |=
   11732:	687b      	ldr	r3, [r7, #4]
   11734:	681b      	ldr	r3, [r3, #0]
   11736:	681a      	ldr	r2, [r3, #0]
   11738:	687b      	ldr	r3, [r7, #4]
   1173a:	681b      	ldr	r3, [r3, #0]
   1173c:	f042 020f 	orr.w	r2, r2, #15
   11740:	601a      	str	r2, [r3, #0]
        (1 << kRegMR0) | (1 << kRegMR1) | (1 << kRegMR2) | (1 << kRegMR3);
  }
   11742:	bf00      	nop
   11744:	3708      	adds	r7, #8
   11746:	46bd      	mov	sp, r7
   11748:	bd80      	pop	{r7, pc}
   1174a:	Address 0x000000000001174a is out of bounds.


0001174c <sjsu::Timer::Timer()>:
#include "L0_Platform/interrupt.hpp"
#include "utility/status.hpp"

namespace sjsu
{
class Timer
   1174c:	b480      	push	{r7}
   1174e:	b083      	sub	sp, #12
   11750:	af00      	add	r7, sp, #0
   11752:	6078      	str	r0, [r7, #4]
   11754:	4a04      	ldr	r2, [pc, #16]	; (11768 <sjsu::Timer::Timer()+0x1c>)
   11756:	687b      	ldr	r3, [r7, #4]
   11758:	601a      	str	r2, [r3, #0]
   1175a:	687b      	ldr	r3, [r7, #4]
   1175c:	4618      	mov	r0, r3
   1175e:	370c      	adds	r7, #12
   11760:	46bd      	mov	sp, r7
   11762:	f85d 7b04 	ldr.w	r7, [sp], #4
   11766:	4770      	bx	lr
   11768:	000157e4 	.word	0x000157e4

0001176c <sjsu::SystemController::SystemController()>:
#include <cstddef>
#include <cstdint>

namespace sjsu
{
class SystemController
   1176c:	b480      	push	{r7}
   1176e:	b083      	sub	sp, #12
   11770:	af00      	add	r7, sp, #0
   11772:	6078      	str	r0, [r7, #4]
   11774:	4a04      	ldr	r2, [pc, #16]	; (11788 <sjsu::SystemController::SystemController()+0x1c>)
   11776:	687b      	ldr	r3, [r7, #4]
   11778:	601a      	str	r2, [r3, #0]
   1177a:	687b      	ldr	r3, [r7, #4]
   1177c:	4618      	mov	r0, r3
   1177e:	370c      	adds	r7, #12
   11780:	46bd      	mov	sp, r7
   11782:	f85d 7b04 	ldr.w	r7, [sp], #4
   11786:	4770      	bx	lr
   11788:	00015820 	.word	0x00015820

0001178c <sjsu::lpc40xx::SystemController::SystemController()>:
class SystemController : public sjsu::SystemController
   1178c:	b580      	push	{r7, lr}
   1178e:	b082      	sub	sp, #8
   11790:	af00      	add	r7, sp, #0
   11792:	6078      	str	r0, [r7, #4]
   11794:	687b      	ldr	r3, [r7, #4]
   11796:	4618      	mov	r0, r3
   11798:	f7ff ffe8 	bl	1176c <sjsu::SystemController::SystemController()>
   1179c:	4a03      	ldr	r2, [pc, #12]	; (117ac <sjsu::lpc40xx::SystemController::SystemController()+0x20>)
   1179e:	687b      	ldr	r3, [r7, #4]
   117a0:	601a      	str	r2, [r3, #0]
   117a2:	687b      	ldr	r3, [r7, #4]
   117a4:	4618      	mov	r0, r3
   117a6:	3708      	adds	r7, #8
   117a8:	46bd      	mov	sp, r7
   117aa:	bd80      	pop	{r7, pc}
   117ac:	000157f8 	.word	0x000157f8

000117b0 <sjsu::lpc40xx::Timer::Timer(sjsu::lpc40xx::Timer::Channel_t)>:

  explicit constexpr Timer(Channel_t timer) : timer_(timer) {}
   117b0:	b580      	push	{r7, lr}
   117b2:	b084      	sub	sp, #16
   117b4:	af00      	add	r7, sp, #0
   117b6:	60f8      	str	r0, [r7, #12]
   117b8:	1d3b      	adds	r3, r7, #4
   117ba:	e883 0006 	stmia.w	r3, {r1, r2}
   117be:	68fb      	ldr	r3, [r7, #12]
   117c0:	4618      	mov	r0, r3
   117c2:	f7ff ffc3 	bl	1174c <sjsu::Timer::Timer()>
   117c6:	68fb      	ldr	r3, [r7, #12]
   117c8:	3304      	adds	r3, #4
   117ca:	4618      	mov	r0, r3
   117cc:	f7ff ffde 	bl	1178c <sjsu::lpc40xx::SystemController::SystemController()>
   117d0:	4a06      	ldr	r2, [pc, #24]	; (117ec <sjsu::lpc40xx::Timer::Timer(sjsu::lpc40xx::Timer::Channel_t)+0x3c>)
   117d2:	68fb      	ldr	r3, [r7, #12]
   117d4:	601a      	str	r2, [r3, #0]
   117d6:	4a06      	ldr	r2, [pc, #24]	; (117f0 <sjsu::lpc40xx::Timer::Timer(sjsu::lpc40xx::Timer::Channel_t)+0x40>)
   117d8:	68fb      	ldr	r3, [r7, #12]
   117da:	605a      	str	r2, [r3, #4]
   117dc:	68fb      	ldr	r3, [r7, #12]
   117de:	1d3a      	adds	r2, r7, #4
   117e0:	609a      	str	r2, [r3, #8]
   117e2:	68fb      	ldr	r3, [r7, #12]
   117e4:	4618      	mov	r0, r3
   117e6:	3710      	adds	r7, #16
   117e8:	46bd      	mov	sp, r7
   117ea:	bd80      	pop	{r7, pc}
   117ec:	000157a8 	.word	0x000157a8
   117f0:	000157bc 	.word	0x000157bc

000117f4 <sjsu::lpc40xx::Timer::Initialize(unsigned long, void (*)(), long) const>:
  ///        register will be 10 ms.
  /// @param isr - an ISR that will fire when the condition set by SetTimer
  ///        method is achieved.
  /// @param priority - sets the Timer interrupt's priority level, defaults to
  ///        -1 which uses the platforms default priority.
  Status Initialize(uint32_t frequency, IsrPointer isr = nullptr,
   117f4:	b580      	push	{r7, lr}
   117f6:	b086      	sub	sp, #24
   117f8:	af00      	add	r7, sp, #0
   117fa:	60f8      	str	r0, [r7, #12]
   117fc:	60b9      	str	r1, [r7, #8]
   117fe:	607a      	str	r2, [r7, #4]
   11800:	603b      	str	r3, [r7, #0]
                    int32_t priority = -1) const override
  {
    constexpr uint32_t kClear = std::numeric_limits<uint32_t>::max();
   11802:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   11806:	617b      	str	r3, [r7, #20]
    PowerUpPeripheral(timer_.channel.power_id);
   11808:	68fb      	ldr	r3, [r7, #12]
   1180a:	1d1a      	adds	r2, r3, #4
   1180c:	68fb      	ldr	r3, [r7, #12]
   1180e:	689b      	ldr	r3, [r3, #8]
   11810:	681b      	ldr	r3, [r3, #0]
   11812:	3304      	adds	r3, #4
   11814:	4619      	mov	r1, r3
   11816:	4610      	mov	r0, r2
   11818:	f7ff fd66 	bl	112e8 <sjsu::lpc40xx::SystemController::PowerUpPeripheral(sjsu::SystemController::PeripheralID const&) const>
    SJ2_ASSERT_FATAL(
   1181c:	68bb      	ldr	r3, [r7, #8]
   1181e:	2b00      	cmp	r3, #0
   11820:	d10d      	bne.n	1183e <sjsu::lpc40xx::Timer::Initialize(unsigned long, void (*)(), long) const+0x4a>
   11822:	2387      	movs	r3, #135	; 0x87
   11824:	4a29      	ldr	r2, [pc, #164]	; (118cc <sjsu::lpc40xx::Timer::Initialize(unsigned long, void (*)(), long) const+0xd8>)
   11826:	492a      	ldr	r1, [pc, #168]	; (118d0 <sjsu::lpc40xx::Timer::Initialize(unsigned long, void (*)(), long) const+0xdc>)
   11828:	482a      	ldr	r0, [pc, #168]	; (118d4 <sjsu::lpc40xx::Timer::Initialize(unsigned long, void (*)(), long) const+0xe0>)
   1182a:	f001 fe43 	bl	134b4 <printf>
   1182e:	482a      	ldr	r0, [pc, #168]	; (118d8 <sjsu::lpc40xx::Timer::Initialize(unsigned long, void (*)(), long) const+0xe4>)
   11830:	f000 fc70 	bl	12114 <puts>
   11834:	2100      	movs	r1, #0
   11836:	2001      	movs	r0, #1
   11838:	f7fe ff22 	bl	10680 <sjsu::debug::PrintBacktrace(bool, void*)>
   1183c:	e7fe      	b.n	1183c <sjsu::lpc40xx::Timer::Initialize(unsigned long, void (*)(), long) const+0x48>
        frequency != 0,
        "Cannot have zero ticks per microsecond, please choose 1 or more.");
    // Set Prescale register for Prescale Counter to milliseconds
    uint32_t prescaler = GetPeripheralFrequency() / frequency;
   1183e:	68fb      	ldr	r3, [r7, #12]
   11840:	3304      	adds	r3, #4
   11842:	4618      	mov	r0, r3
   11844:	f7ff fd18 	bl	11278 <sjsu::lpc40xx::SystemController::GetPeripheralFrequency() const>
   11848:	4602      	mov	r2, r0
   1184a:	68bb      	ldr	r3, [r7, #8]
   1184c:	fbb2 f3f3 	udiv	r3, r2, r3
   11850:	613b      	str	r3, [r7, #16]
    timer_.channel.timer_register->PR &= ~(kClear << 1);
   11852:	68fb      	ldr	r3, [r7, #12]
   11854:	689b      	ldr	r3, [r3, #8]
   11856:	681b      	ldr	r3, [r3, #0]
   11858:	681b      	ldr	r3, [r3, #0]
   1185a:	68da      	ldr	r2, [r3, #12]
   1185c:	68fb      	ldr	r3, [r7, #12]
   1185e:	689b      	ldr	r3, [r3, #8]
   11860:	681b      	ldr	r3, [r3, #0]
   11862:	681b      	ldr	r3, [r3, #0]
   11864:	f002 0201 	and.w	r2, r2, #1
   11868:	60da      	str	r2, [r3, #12]
    timer_.channel.timer_register->PR |= (prescaler << 1);
   1186a:	68fb      	ldr	r3, [r7, #12]
   1186c:	689b      	ldr	r3, [r3, #8]
   1186e:	681b      	ldr	r3, [r3, #0]
   11870:	681b      	ldr	r3, [r3, #0]
   11872:	68d9      	ldr	r1, [r3, #12]
   11874:	693b      	ldr	r3, [r7, #16]
   11876:	005a      	lsls	r2, r3, #1
   11878:	68fb      	ldr	r3, [r7, #12]
   1187a:	689b      	ldr	r3, [r3, #8]
   1187c:	681b      	ldr	r3, [r3, #0]
   1187e:	681b      	ldr	r3, [r3, #0]
   11880:	430a      	orrs	r2, r1
   11882:	60da      	str	r2, [r3, #12]
    timer_.channel.timer_register->TCR |= (1 << 0);
   11884:	68fb      	ldr	r3, [r7, #12]
   11886:	689b      	ldr	r3, [r3, #8]
   11888:	681b      	ldr	r3, [r3, #0]
   1188a:	681b      	ldr	r3, [r3, #0]
   1188c:	685a      	ldr	r2, [r3, #4]
   1188e:	68fb      	ldr	r3, [r7, #12]
   11890:	689b      	ldr	r3, [r3, #8]
   11892:	681b      	ldr	r3, [r3, #0]
   11894:	681b      	ldr	r3, [r3, #0]
   11896:	f042 0201 	orr.w	r2, r2, #1
   1189a:	605a      	str	r2, [r3, #4]
    *timer_.channel.user_callback = isr;
   1189c:	68fb      	ldr	r3, [r7, #12]
   1189e:	689b      	ldr	r3, [r3, #8]
   118a0:	681b      	ldr	r3, [r3, #0]
   118a2:	68db      	ldr	r3, [r3, #12]
   118a4:	687a      	ldr	r2, [r7, #4]
   118a6:	601a      	str	r2, [r3, #0]
    RegisterIsr(timer_.channel.irq, timer_.isr, true, priority);
   118a8:	68fb      	ldr	r3, [r7, #12]
   118aa:	689b      	ldr	r3, [r3, #8]
   118ac:	681b      	ldr	r3, [r3, #0]
   118ae:	f993 0008 	ldrsb.w	r0, [r3, #8]
   118b2:	68fb      	ldr	r3, [r7, #12]
   118b4:	689b      	ldr	r3, [r3, #8]
   118b6:	6859      	ldr	r1, [r3, #4]
   118b8:	683b      	ldr	r3, [r7, #0]
   118ba:	2201      	movs	r2, #1
   118bc:	f000 fb82 	bl	11fc4 <RegisterIsr(IRQn, void (*)(), bool, long)>

    return Status::kSuccess;
   118c0:	2300      	movs	r3, #0
  }
   118c2:	4618      	mov	r0, r3
   118c4:	3718      	adds	r7, #24
   118c6:	46bd      	mov	sp, r7
   118c8:	bd80      	pop	{r7, pc}
   118ca:	bf00      	nop
   118cc:	000159c4 	.word	0x000159c4
   118d0:	000156b8 	.word	0x000156b8
   118d4:	000153b8 	.word	0x000153b8
   118d8:	000150c4 	.word	0x000150c4

000118dc <sjsu::lpc40xx::Timer::SetTimer(unsigned long, sjsu::Timer::TimerIsrCondition, unsigned char) const>:
  /// @param ticks - the count of the timer register (TC) to have an ISR fire
  /// @param condition - the condition for which a timer interrupt will occur
  /// @param match_register - which match register (from 0 to 3) should be used
  ///        for holding the ticks for the condition. Only the two least
  ///        significant bits are used for the LPC40xx.
  void SetTimer(uint32_t ticks, TimerIsrCondition condition,
   118dc:	b580      	push	{r7, lr}
   118de:	b088      	sub	sp, #32
   118e0:	af02      	add	r7, sp, #8
   118e2:	60f8      	str	r0, [r7, #12]
   118e4:	60b9      	str	r1, [r7, #8]
   118e6:	4611      	mov	r1, r2
   118e8:	461a      	mov	r2, r3
   118ea:	460b      	mov	r3, r1
   118ec:	71fb      	strb	r3, [r7, #7]
   118ee:	4613      	mov	r3, r2
   118f0:	71bb      	strb	r3, [r7, #6]
                uint8_t match_register = 0) const override
  {
    SJ2_ASSERT_FATAL(match_register > 3,
   118f2:	79bb      	ldrb	r3, [r7, #6]
   118f4:	2b03      	cmp	r3, #3
   118f6:	d80f      	bhi.n	11918 <sjsu::lpc40xx::Timer::SetTimer(unsigned long, sjsu::Timer::TimerIsrCondition, unsigned char) const+0x3c>
   118f8:	79bb      	ldrb	r3, [r7, #6]
   118fa:	9300      	str	r3, [sp, #0]
   118fc:	23a2      	movs	r3, #162	; 0xa2
   118fe:	4a20      	ldr	r2, [pc, #128]	; (11980 <sjsu::lpc40xx::Timer::SetTimer(unsigned long, sjsu::Timer::TimerIsrCondition, unsigned char) const+0xa4>)
   11900:	4920      	ldr	r1, [pc, #128]	; (11984 <sjsu::lpc40xx::Timer::SetTimer(unsigned long, sjsu::Timer::TimerIsrCondition, unsigned char) const+0xa8>)
   11902:	4821      	ldr	r0, [pc, #132]	; (11988 <sjsu::lpc40xx::Timer::SetTimer(unsigned long, sjsu::Timer::TimerIsrCondition, unsigned char) const+0xac>)
   11904:	f001 fdd6 	bl	134b4 <printf>
   11908:	4820      	ldr	r0, [pc, #128]	; (1198c <sjsu::lpc40xx::Timer::SetTimer(unsigned long, sjsu::Timer::TimerIsrCondition, unsigned char) const+0xb0>)
   1190a:	f000 fc03 	bl	12114 <puts>
   1190e:	2100      	movs	r1, #0
   11910:	2001      	movs	r0, #1
   11912:	f7fe feb5 	bl	10680 <sjsu::debug::PrintBacktrace(bool, void*)>
   11916:	e7fe      	b.n	11916 <sjsu::lpc40xx::Timer::SetTimer(unsigned long, sjsu::Timer::TimerIsrCondition, unsigned char) const+0x3a>
                     "to set match register %d was attempted.",
                     match_register);

    static constexpr uint8_t kClearMode = 0b0111;

    timer_.channel.timer_register->MCR &= ~(kClearMode << match_register);
   11918:	68fb      	ldr	r3, [r7, #12]
   1191a:	689b      	ldr	r3, [r3, #8]
   1191c:	681b      	ldr	r3, [r3, #0]
   1191e:	681b      	ldr	r3, [r3, #0]
   11920:	695a      	ldr	r2, [r3, #20]
   11922:	79bb      	ldrb	r3, [r7, #6]
   11924:	2107      	movs	r1, #7
   11926:	fa01 f303 	lsl.w	r3, r1, r3
   1192a:	43db      	mvns	r3, r3
   1192c:	4619      	mov	r1, r3
   1192e:	68fb      	ldr	r3, [r7, #12]
   11930:	689b      	ldr	r3, [r3, #8]
   11932:	681b      	ldr	r3, [r3, #0]
   11934:	681b      	ldr	r3, [r3, #0]
   11936:	400a      	ands	r2, r1
   11938:	615a      	str	r2, [r3, #20]
    timer_.channel.timer_register->MCR |= condition << match_register;
   1193a:	68fb      	ldr	r3, [r7, #12]
   1193c:	689b      	ldr	r3, [r3, #8]
   1193e:	681b      	ldr	r3, [r3, #0]
   11940:	681b      	ldr	r3, [r3, #0]
   11942:	695a      	ldr	r2, [r3, #20]
   11944:	79f9      	ldrb	r1, [r7, #7]
   11946:	79bb      	ldrb	r3, [r7, #6]
   11948:	fa01 f303 	lsl.w	r3, r1, r3
   1194c:	4619      	mov	r1, r3
   1194e:	68fb      	ldr	r3, [r7, #12]
   11950:	689b      	ldr	r3, [r3, #8]
   11952:	681b      	ldr	r3, [r3, #0]
   11954:	681b      	ldr	r3, [r3, #0]
   11956:	430a      	orrs	r2, r1
   11958:	615a      	str	r2, [r3, #20]
    // MR0, MR1, MR2, and MR3 are contiguous, so we can point to the first
    // match register and index from there to get the other match registers.
    volatile uint32_t * match_register_ptr =
        &timer_.channel.timer_register->MR0;
   1195a:	68fb      	ldr	r3, [r7, #12]
   1195c:	689b      	ldr	r3, [r3, #8]
   1195e:	681b      	ldr	r3, [r3, #0]
   11960:	681b      	ldr	r3, [r3, #0]
    volatile uint32_t * match_register_ptr =
   11962:	3318      	adds	r3, #24
   11964:	617b      	str	r3, [r7, #20]

    match_register_ptr[match_register & 0b11] = ticks / 2;
   11966:	79bb      	ldrb	r3, [r7, #6]
   11968:	f003 0303 	and.w	r3, r3, #3
   1196c:	009b      	lsls	r3, r3, #2
   1196e:	697a      	ldr	r2, [r7, #20]
   11970:	4413      	add	r3, r2
   11972:	68ba      	ldr	r2, [r7, #8]
   11974:	0852      	lsrs	r2, r2, #1
   11976:	601a      	str	r2, [r3, #0]
  }
   11978:	bf00      	nop
   1197a:	3718      	adds	r7, #24
   1197c:	46bd      	mov	sp, r7
   1197e:	bd80      	pop	{r7, pc}
   11980:	00015a20 	.word	0x00015a20
   11984:	000156c4 	.word	0x000156c4
   11988:	00015478 	.word	0x00015478
   1198c:	000150c4 	.word	0x000150c4

00011990 <sjsu::lpc40xx::Timer::GetTimer() const>:

  uint32_t GetTimer() const override
   11990:	b480      	push	{r7}
   11992:	b083      	sub	sp, #12
   11994:	af00      	add	r7, sp, #0
   11996:	6078      	str	r0, [r7, #4]
  {
    return timer_.channel.timer_register->TC;
   11998:	687b      	ldr	r3, [r7, #4]
   1199a:	689b      	ldr	r3, [r3, #8]
   1199c:	681b      	ldr	r3, [r3, #0]
   1199e:	681b      	ldr	r3, [r3, #0]
   119a0:	689b      	ldr	r3, [r3, #8]
  }
   119a2:	4618      	mov	r0, r3
   119a4:	370c      	adds	r7, #12
   119a6:	46bd      	mov	sp, r7
   119a8:	f85d 7b04 	ldr.w	r7, [sp], #4
   119ac:	4770      	bx	lr
   119ae:	Address 0x00000000000119ae is out of bounds.


000119b0 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const>:

  explicit constexpr Uart(const Port_t & port) : port_(port) {}

  /// For LPC40xx only supports the following baud rates:
  ///   4800, 9600, 19200, 38400, 57600, 115200, 230400, 460800, 921600
  bool SetBaudRate(uint32_t baud_rate) const override
   119b0:	b480      	push	{r7}
   119b2:	b087      	sub	sp, #28
   119b4:	af00      	add	r7, sp, #0
   119b6:	6078      	str	r0, [r7, #4]
   119b8:	6039      	str	r1, [r7, #0]
  {
    uart::UartCalibration_t calibration;
   119ba:	2300      	movs	r3, #0
   119bc:	60bb      	str	r3, [r7, #8]
   119be:	2300      	movs	r3, #0
   119c0:	60fb      	str	r3, [r7, #12]
   119c2:	2301      	movs	r3, #1
   119c4:	613b      	str	r3, [r7, #16]
    switch (baud_rate)
   119c6:	683b      	ldr	r3, [r7, #0]
   119c8:	f5b3 4f61 	cmp.w	r3, #57600	; 0xe100
   119cc:	d043      	beq.n	11a56 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0xa6>
   119ce:	f5b3 4f61 	cmp.w	r3, #57600	; 0xe100
   119d2:	d810      	bhi.n	119f6 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0x46>
   119d4:	f5b3 5f16 	cmp.w	r3, #9600	; 0x2580
   119d8:	d025      	beq.n	11a26 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0x76>
   119da:	f5b3 5f16 	cmp.w	r3, #9600	; 0x2580
   119de:	d803      	bhi.n	119e8 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0x38>
   119e0:	f5b3 5f96 	cmp.w	r3, #4800	; 0x12c0
   119e4:	d018      	beq.n	11a18 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0x68>
   119e6:	e05e      	b.n	11aa6 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0xf6>
   119e8:	f5b3 4f96 	cmp.w	r3, #19200	; 0x4b00
   119ec:	d023      	beq.n	11a36 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0x86>
   119ee:	f5b3 4f16 	cmp.w	r3, #38400	; 0x9600
   119f2:	d028      	beq.n	11a46 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0x96>
   119f4:	e057      	b.n	11aa6 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0xf6>
   119f6:	f5b3 3f61 	cmp.w	r3, #230400	; 0x38400
   119fa:	d03c      	beq.n	11a76 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0xc6>
   119fc:	f5b3 3f61 	cmp.w	r3, #230400	; 0x38400
   11a00:	d803      	bhi.n	11a0a <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0x5a>
   11a02:	f5b3 3fe1 	cmp.w	r3, #115200	; 0x1c200
   11a06:	d02e      	beq.n	11a66 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0xb6>
   11a08:	e04d      	b.n	11aa6 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0xf6>
   11a0a:	f5b3 2fe1 	cmp.w	r3, #460800	; 0x70800
   11a0e:	d03a      	beq.n	11a86 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0xd6>
   11a10:	f5b3 2f61 	cmp.w	r3, #921600	; 0xe1000
   11a14:	d03f      	beq.n	11a96 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0xe6>
   11a16:	e046      	b.n	11aa6 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0xf6>
    {
      case 4800: calibration = kBaudRateLUT[0]; break;
   11a18:	4a3d      	ldr	r2, [pc, #244]	; (11b10 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0x160>)
   11a1a:	f107 0308 	add.w	r3, r7, #8
   11a1e:	ca07      	ldmia	r2, {r0, r1, r2}
   11a20:	e883 0007 	stmia.w	r3, {r0, r1, r2}
   11a24:	e041      	b.n	11aaa <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0xfa>
      case 9600: calibration = kBaudRateLUT[1]; break;
   11a26:	4a3a      	ldr	r2, [pc, #232]	; (11b10 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0x160>)
   11a28:	f107 0308 	add.w	r3, r7, #8
   11a2c:	320c      	adds	r2, #12
   11a2e:	ca07      	ldmia	r2, {r0, r1, r2}
   11a30:	e883 0007 	stmia.w	r3, {r0, r1, r2}
   11a34:	e039      	b.n	11aaa <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0xfa>
      case 19200: calibration = kBaudRateLUT[2]; break;
   11a36:	4a36      	ldr	r2, [pc, #216]	; (11b10 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0x160>)
   11a38:	f107 0308 	add.w	r3, r7, #8
   11a3c:	3218      	adds	r2, #24
   11a3e:	ca07      	ldmia	r2, {r0, r1, r2}
   11a40:	e883 0007 	stmia.w	r3, {r0, r1, r2}
   11a44:	e031      	b.n	11aaa <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0xfa>
      case 38400: calibration = kBaudRateLUT[3]; break;
   11a46:	4a32      	ldr	r2, [pc, #200]	; (11b10 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0x160>)
   11a48:	f107 0308 	add.w	r3, r7, #8
   11a4c:	3224      	adds	r2, #36	; 0x24
   11a4e:	ca07      	ldmia	r2, {r0, r1, r2}
   11a50:	e883 0007 	stmia.w	r3, {r0, r1, r2}
   11a54:	e029      	b.n	11aaa <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0xfa>
      case 57600: calibration = kBaudRateLUT[4]; break;
   11a56:	4a2e      	ldr	r2, [pc, #184]	; (11b10 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0x160>)
   11a58:	f107 0308 	add.w	r3, r7, #8
   11a5c:	3230      	adds	r2, #48	; 0x30
   11a5e:	ca07      	ldmia	r2, {r0, r1, r2}
   11a60:	e883 0007 	stmia.w	r3, {r0, r1, r2}
   11a64:	e021      	b.n	11aaa <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0xfa>
      case 115200: calibration = kBaudRateLUT[5]; break;
   11a66:	4a2a      	ldr	r2, [pc, #168]	; (11b10 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0x160>)
   11a68:	f107 0308 	add.w	r3, r7, #8
   11a6c:	323c      	adds	r2, #60	; 0x3c
   11a6e:	ca07      	ldmia	r2, {r0, r1, r2}
   11a70:	e883 0007 	stmia.w	r3, {r0, r1, r2}
   11a74:	e019      	b.n	11aaa <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0xfa>
      case 230400: calibration = kBaudRateLUT[6]; break;
   11a76:	4a26      	ldr	r2, [pc, #152]	; (11b10 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0x160>)
   11a78:	f107 0308 	add.w	r3, r7, #8
   11a7c:	3248      	adds	r2, #72	; 0x48
   11a7e:	ca07      	ldmia	r2, {r0, r1, r2}
   11a80:	e883 0007 	stmia.w	r3, {r0, r1, r2}
   11a84:	e011      	b.n	11aaa <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0xfa>
      case 460800: calibration = kBaudRateLUT[7]; break;
   11a86:	4a22      	ldr	r2, [pc, #136]	; (11b10 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0x160>)
   11a88:	f107 0308 	add.w	r3, r7, #8
   11a8c:	3254      	adds	r2, #84	; 0x54
   11a8e:	ca07      	ldmia	r2, {r0, r1, r2}
   11a90:	e883 0007 	stmia.w	r3, {r0, r1, r2}
   11a94:	e009      	b.n	11aaa <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0xfa>
      case 921600: calibration = kBaudRateLUT[8]; break;
   11a96:	4a1e      	ldr	r2, [pc, #120]	; (11b10 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0x160>)
   11a98:	f107 0308 	add.w	r3, r7, #8
   11a9c:	3260      	adds	r2, #96	; 0x60
   11a9e:	ca07      	ldmia	r2, {r0, r1, r2}
   11aa0:	e883 0007 	stmia.w	r3, {r0, r1, r2}
   11aa4:	e001      	b.n	11aaa <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0xfa>
      default: return false;
   11aa6:	2300      	movs	r3, #0
   11aa8:	e02c      	b.n	11b04 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0x154>
    }
    constexpr uint8_t kDlabBit = (1 << 7);
   11aaa:	2380      	movs	r3, #128	; 0x80
   11aac:	75fb      	strb	r3, [r7, #23]

    uint8_t dlm = static_cast<uint8_t>((calibration.divide_latch >> 8) & 0xFF);
   11aae:	68bb      	ldr	r3, [r7, #8]
   11ab0:	0a1b      	lsrs	r3, r3, #8
   11ab2:	75bb      	strb	r3, [r7, #22]
    uint8_t dll = static_cast<uint8_t>(calibration.divide_latch & 0xFF);
   11ab4:	68bb      	ldr	r3, [r7, #8]
   11ab6:	757b      	strb	r3, [r7, #21]
    uint8_t fdr = static_cast<uint8_t>((calibration.multiply & 0xF) << 4 |
   11ab8:	693b      	ldr	r3, [r7, #16]
   11aba:	b2db      	uxtb	r3, r3
   11abc:	011b      	lsls	r3, r3, #4
   11abe:	b2da      	uxtb	r2, r3
                                       (calibration.divide_add & 0xF));
   11ac0:	68fb      	ldr	r3, [r7, #12]
   11ac2:	b2db      	uxtb	r3, r3
   11ac4:	f003 030f 	and.w	r3, r3, #15
   11ac8:	b2db      	uxtb	r3, r3
    uint8_t fdr = static_cast<uint8_t>((calibration.multiply & 0xF) << 4 |
   11aca:	4313      	orrs	r3, r2
   11acc:	753b      	strb	r3, [r7, #20]

    port_.registers->LCR = kDlabBit;
   11ace:	687b      	ldr	r3, [r7, #4]
   11ad0:	689b      	ldr	r3, [r3, #8]
   11ad2:	681b      	ldr	r3, [r3, #0]
   11ad4:	2280      	movs	r2, #128	; 0x80
   11ad6:	731a      	strb	r2, [r3, #12]
    port_.registers->DLM = dlm;
   11ad8:	687b      	ldr	r3, [r7, #4]
   11ada:	689b      	ldr	r3, [r3, #8]
   11adc:	681b      	ldr	r3, [r3, #0]
   11ade:	7dba      	ldrb	r2, [r7, #22]
   11ae0:	711a      	strb	r2, [r3, #4]
    port_.registers->DLL = dll;
   11ae2:	687b      	ldr	r3, [r7, #4]
   11ae4:	689b      	ldr	r3, [r3, #8]
   11ae6:	681b      	ldr	r3, [r3, #0]
   11ae8:	7d7a      	ldrb	r2, [r7, #21]
   11aea:	701a      	strb	r2, [r3, #0]
    port_.registers->FDR = fdr;
   11aec:	687b      	ldr	r3, [r7, #4]
   11aee:	689b      	ldr	r3, [r3, #8]
   11af0:	681b      	ldr	r3, [r3, #0]
   11af2:	7d3a      	ldrb	r2, [r7, #20]
   11af4:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
    port_.registers->LCR = kStandardUart;
   11af8:	687b      	ldr	r3, [r7, #4]
   11afa:	689b      	ldr	r3, [r3, #8]
   11afc:	681b      	ldr	r3, [r3, #0]
   11afe:	2203      	movs	r2, #3
   11b00:	731a      	strb	r2, [r3, #12]
    return true;
   11b02:	2301      	movs	r3, #1
  }
   11b04:	4618      	mov	r0, r3
   11b06:	371c      	adds	r7, #28
   11b08:	46bd      	mov	sp, r7
   11b0a:	f85d 7b04 	ldr.w	r7, [sp], #4
   11b0e:	4770      	bx	lr
   11b10:	000156d0 	.word	0x000156d0

00011b14 <sjsu::lpc40xx::Uart::Initialize(unsigned long) const>:
    port_.registers->DLL = dll;
    port_.registers->FDR = fdr;
    port_.registers->LCR = kStandardUart;
  }

  Status Initialize(uint32_t baud_rate) const override
   11b14:	b580      	push	{r7, lr}
   11b16:	b084      	sub	sp, #16
   11b18:	af00      	add	r7, sp, #0
   11b1a:	6078      	str	r0, [r7, #4]
   11b1c:	6039      	str	r1, [r7, #0]
  {
    constexpr uint8_t kFIFOEnableAndReset = 0b111;
   11b1e:	2307      	movs	r3, #7
   11b20:	73fb      	strb	r3, [r7, #15]
    // Powering the port
    PowerUpPeripheral(port_.power_on_id);
   11b22:	687b      	ldr	r3, [r7, #4]
   11b24:	1d1a      	adds	r2, r3, #4
   11b26:	687b      	ldr	r3, [r7, #4]
   11b28:	689b      	ldr	r3, [r3, #8]
   11b2a:	3304      	adds	r3, #4
   11b2c:	4619      	mov	r1, r3
   11b2e:	4610      	mov	r0, r2
   11b30:	f7ff fbda 	bl	112e8 <sjsu::lpc40xx::SystemController::PowerUpPeripheral(sjsu::SystemController::PeripheralID const&) const>
    SetBaudRate(baud_rate);
   11b34:	6839      	ldr	r1, [r7, #0]
   11b36:	6878      	ldr	r0, [r7, #4]
   11b38:	f7ff ff3a 	bl	119b0 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const>
    // Setting the pin functions and modes
    port_.rx.SetPinFunction(port_.rx_function_id);
   11b3c:	687b      	ldr	r3, [r7, #4]
   11b3e:	689b      	ldr	r3, [r3, #8]
   11b40:	68d8      	ldr	r0, [r3, #12]
   11b42:	687b      	ldr	r3, [r7, #4]
   11b44:	689b      	ldr	r3, [r3, #8]
   11b46:	68db      	ldr	r3, [r3, #12]
   11b48:	681b      	ldr	r3, [r3, #0]
   11b4a:	681b      	ldr	r3, [r3, #0]
   11b4c:	687a      	ldr	r2, [r7, #4]
   11b4e:	6892      	ldr	r2, [r2, #8]
   11b50:	7c12      	ldrb	r2, [r2, #16]
   11b52:	f3c2 02c2 	ubfx	r2, r2, #3, #3
   11b56:	b2d2      	uxtb	r2, r2
   11b58:	4611      	mov	r1, r2
   11b5a:	4798      	blx	r3
    port_.tx.SetPinFunction(port_.tx_function_id);
   11b5c:	687b      	ldr	r3, [r7, #4]
   11b5e:	689b      	ldr	r3, [r3, #8]
   11b60:	6898      	ldr	r0, [r3, #8]
   11b62:	687b      	ldr	r3, [r7, #4]
   11b64:	689b      	ldr	r3, [r3, #8]
   11b66:	689b      	ldr	r3, [r3, #8]
   11b68:	681b      	ldr	r3, [r3, #0]
   11b6a:	681b      	ldr	r3, [r3, #0]
   11b6c:	687a      	ldr	r2, [r7, #4]
   11b6e:	6892      	ldr	r2, [r2, #8]
   11b70:	7c12      	ldrb	r2, [r2, #16]
   11b72:	f3c2 0202 	ubfx	r2, r2, #0, #3
   11b76:	b2d2      	uxtb	r2, r2
   11b78:	4611      	mov	r1, r2
   11b7a:	4798      	blx	r3
    port_.rx.SetMode(sjsu::Pin::Mode::kPullUp);
   11b7c:	687b      	ldr	r3, [r7, #4]
   11b7e:	689b      	ldr	r3, [r3, #8]
   11b80:	68da      	ldr	r2, [r3, #12]
   11b82:	687b      	ldr	r3, [r7, #4]
   11b84:	689b      	ldr	r3, [r3, #8]
   11b86:	68db      	ldr	r3, [r3, #12]
   11b88:	681b      	ldr	r3, [r3, #0]
   11b8a:	3304      	adds	r3, #4
   11b8c:	681b      	ldr	r3, [r3, #0]
   11b8e:	2102      	movs	r1, #2
   11b90:	4610      	mov	r0, r2
   11b92:	4798      	blx	r3
    port_.tx.SetMode(sjsu::Pin::Mode::kPullUp);
   11b94:	687b      	ldr	r3, [r7, #4]
   11b96:	689b      	ldr	r3, [r3, #8]
   11b98:	689a      	ldr	r2, [r3, #8]
   11b9a:	687b      	ldr	r3, [r7, #4]
   11b9c:	689b      	ldr	r3, [r3, #8]
   11b9e:	689b      	ldr	r3, [r3, #8]
   11ba0:	681b      	ldr	r3, [r3, #0]
   11ba2:	3304      	adds	r3, #4
   11ba4:	681b      	ldr	r3, [r3, #0]
   11ba6:	2102      	movs	r1, #2
   11ba8:	4610      	mov	r0, r2
   11baa:	4798      	blx	r3
    port_.registers->FCR |= kFIFOEnableAndReset;
   11bac:	687b      	ldr	r3, [r7, #4]
   11bae:	689b      	ldr	r3, [r3, #8]
   11bb0:	681b      	ldr	r3, [r3, #0]
   11bb2:	7a1b      	ldrb	r3, [r3, #8]
   11bb4:	b2da      	uxtb	r2, r3
   11bb6:	687b      	ldr	r3, [r7, #4]
   11bb8:	689b      	ldr	r3, [r3, #8]
   11bba:	681b      	ldr	r3, [r3, #0]
   11bbc:	f042 0207 	orr.w	r2, r2, #7
   11bc0:	b2d2      	uxtb	r2, r2
   11bc2:	721a      	strb	r2, [r3, #8]

    return Status::kSuccess;
   11bc4:	2300      	movs	r3, #0
  }
   11bc6:	4618      	mov	r0, r3
   11bc8:	3710      	adds	r7, #16
   11bca:	46bd      	mov	sp, r7
   11bcc:	bd80      	pop	{r7, pc}

00011bce <sjsu::lpc40xx::Uart::Send(unsigned char) const::{lambda()#1}::operator()() const>:

  void Send(uint8_t data) const override
  {
    port_.registers->THR             = data;
    auto wait_for_transfer_to_finish = [this]() -> bool {
   11bce:	b480      	push	{r7}
   11bd0:	b083      	sub	sp, #12
   11bd2:	af00      	add	r7, sp, #0
   11bd4:	6078      	str	r0, [r7, #4]
   11bd6:	687b      	ldr	r3, [r7, #4]
   11bd8:	681b      	ldr	r3, [r3, #0]
      return (port_.registers->LSR & (1 << 5));
   11bda:	689b      	ldr	r3, [r3, #8]
   11bdc:	681b      	ldr	r3, [r3, #0]
   11bde:	7d1b      	ldrb	r3, [r3, #20]
   11be0:	b2db      	uxtb	r3, r3
   11be2:	f003 0320 	and.w	r3, r3, #32
   11be6:	2b00      	cmp	r3, #0
   11be8:	bf14      	ite	ne
   11bea:	2301      	movne	r3, #1
   11bec:	2300      	moveq	r3, #0
   11bee:	b2db      	uxtb	r3, r3
    };
   11bf0:	4618      	mov	r0, r3
   11bf2:	370c      	adds	r7, #12
   11bf4:	46bd      	mov	sp, r7
   11bf6:	f85d 7b04 	ldr.w	r7, [sp], #4
   11bfa:	4770      	bx	lr

00011bfc <sjsu::lpc40xx::Uart::Send(unsigned char) const>:
  void Send(uint8_t data) const override
   11bfc:	b5f0      	push	{r4, r5, r6, r7, lr}
   11bfe:	b08b      	sub	sp, #44	; 0x2c
   11c00:	af00      	add	r7, sp, #0
   11c02:	6078      	str	r0, [r7, #4]
   11c04:	460b      	mov	r3, r1
   11c06:	70fb      	strb	r3, [r7, #3]
    port_.registers->THR             = data;
   11c08:	687b      	ldr	r3, [r7, #4]
   11c0a:	689b      	ldr	r3, [r3, #8]
   11c0c:	681b      	ldr	r3, [r3, #0]
   11c0e:	78fa      	ldrb	r2, [r7, #3]
   11c10:	701a      	strb	r2, [r3, #0]
    };
   11c12:	687b      	ldr	r3, [r7, #4]
   11c14:	613b      	str	r3, [r7, #16]
   11c16:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   11c1a:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   11c1e:	e9c7 3408 	strd	r3, r4, [r7, #32]
   11c22:	693b      	ldr	r3, [r7, #16]
   11c24:	60fb      	str	r3, [r7, #12]
  uint64_t timeout_time = 0;
   11c26:	f04f 0300 	mov.w	r3, #0
   11c2a:	f04f 0400 	mov.w	r4, #0
   11c2e:	e9c7 3406 	strd	r3, r4, [r7, #24]
  if (timeout == kMaxWait)
   11c32:	e9d7 3408 	ldrd	r3, r4, [r7, #32]
   11c36:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   11c3a:	bf08      	it	eq
   11c3c:	f1b3 3fff 	cmpeq.w	r3, #4294967295	; 0xffffffff
   11c40:	d106      	bne.n	11c50 <sjsu::lpc40xx::Uart::Send(unsigned char) const+0x54>
    timeout_time = kMaxWait;
   11c42:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   11c46:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   11c4a:	e9c7 3406 	strd	r3, r4, [r7, #24]
   11c4e:	e00a      	b.n	11c66 <sjsu::lpc40xx::Uart::Send(unsigned char) const+0x6a>
    timeout_time = Milliseconds() + timeout;
   11c50:	f7fe fd74 	bl	1073c <sjsu::Milliseconds()>
   11c54:	460a      	mov	r2, r1
   11c56:	4601      	mov	r1, r0
   11c58:	e9d7 3408 	ldrd	r3, r4, [r7, #32]
   11c5c:	185d      	adds	r5, r3, r1
   11c5e:	eb44 0602 	adc.w	r6, r4, r2
   11c62:	e9c7 5606 	strd	r5, r6, [r7, #24]
  Status status = Status::kTimedOut;
   11c66:	2301      	movs	r3, #1
   11c68:	617b      	str	r3, [r7, #20]
  while (Milliseconds() < timeout_time)
   11c6a:	f7fe fd67 	bl	1073c <sjsu::Milliseconds()>
   11c6e:	460a      	mov	r2, r1
   11c70:	4601      	mov	r1, r0
   11c72:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
   11c76:	42a2      	cmp	r2, r4
   11c78:	bf08      	it	eq
   11c7a:	4299      	cmpeq	r1, r3
   11c7c:	bf34      	ite	cc
   11c7e:	2301      	movcc	r3, #1
   11c80:	2300      	movcs	r3, #0
   11c82:	b2db      	uxtb	r3, r3
   11c84:	2b00      	cmp	r3, #0
   11c86:	d009      	beq.n	11c9c <sjsu::lpc40xx::Uart::Send(unsigned char) const+0xa0>
    if (is_done())
   11c88:	f107 030c 	add.w	r3, r7, #12
   11c8c:	4618      	mov	r0, r3
   11c8e:	f7ff ff9e 	bl	11bce <sjsu::lpc40xx::Uart::Send(unsigned char) const::{lambda()#1}::operator()() const>
   11c92:	4603      	mov	r3, r0
   11c94:	2b00      	cmp	r3, #0
   11c96:	d0e8      	beq.n	11c6a <sjsu::lpc40xx::Uart::Send(unsigned char) const+0x6e>
      status = Status::kSuccess;
   11c98:	2300      	movs	r3, #0
   11c9a:	617b      	str	r3, [r7, #20]
    Wait(kMaxWait, wait_for_transfer_to_finish);
  }
   11c9c:	bf00      	nop
   11c9e:	372c      	adds	r7, #44	; 0x2c
   11ca0:	46bd      	mov	sp, r7
   11ca2:	bdf0      	pop	{r4, r5, r6, r7, pc}

00011ca4 <sjsu::lpc40xx::Uart::Receive(unsigned long) const::{lambda()#1}::operator()() const>:

  uint8_t Receive([[maybe_unused]] uint32_t timeout = 0x7FFFFFFF) const override
  {
    uint8_t receiver   = '\xFF';
    auto byte_recieved = [this]() -> bool {
   11ca4:	b480      	push	{r7}
   11ca6:	b083      	sub	sp, #12
   11ca8:	af00      	add	r7, sp, #0
   11caa:	6078      	str	r0, [r7, #4]
   11cac:	687b      	ldr	r3, [r7, #4]
   11cae:	681b      	ldr	r3, [r3, #0]
      return (port_.registers->LSR & (1 << 0));
   11cb0:	689b      	ldr	r3, [r3, #8]
   11cb2:	681b      	ldr	r3, [r3, #0]
   11cb4:	7d1b      	ldrb	r3, [r3, #20]
   11cb6:	b2db      	uxtb	r3, r3
   11cb8:	f003 0301 	and.w	r3, r3, #1
   11cbc:	2b00      	cmp	r3, #0
   11cbe:	bf14      	ite	ne
   11cc0:	2301      	movne	r3, #1
   11cc2:	2300      	moveq	r3, #0
   11cc4:	b2db      	uxtb	r3, r3
    };
   11cc6:	4618      	mov	r0, r3
   11cc8:	370c      	adds	r7, #12
   11cca:	46bd      	mov	sp, r7
   11ccc:	f85d 7b04 	ldr.w	r7, [sp], #4
   11cd0:	4770      	bx	lr

00011cd2 <sjsu::lpc40xx::Uart::Receive(unsigned long) const>:
  uint8_t Receive([[maybe_unused]] uint32_t timeout = 0x7FFFFFFF) const override
   11cd2:	b5f0      	push	{r4, r5, r6, r7, lr}
   11cd4:	b08d      	sub	sp, #52	; 0x34
   11cd6:	af00      	add	r7, sp, #0
   11cd8:	6078      	str	r0, [r7, #4]
   11cda:	6039      	str	r1, [r7, #0]
    uint8_t receiver   = '\xFF';
   11cdc:	23ff      	movs	r3, #255	; 0xff
   11cde:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
    };
   11ce2:	687b      	ldr	r3, [r7, #4]
   11ce4:	613b      	str	r3, [r7, #16]

    Status status = Wait(timeout, byte_recieved);
   11ce6:	683b      	ldr	r3, [r7, #0]
   11ce8:	f04f 0400 	mov.w	r4, #0
   11cec:	e9c7 3408 	strd	r3, r4, [r7, #32]
   11cf0:	693b      	ldr	r3, [r7, #16]
   11cf2:	60fb      	str	r3, [r7, #12]
  uint64_t timeout_time = 0;
   11cf4:	f04f 0300 	mov.w	r3, #0
   11cf8:	f04f 0400 	mov.w	r4, #0
   11cfc:	e9c7 3406 	strd	r3, r4, [r7, #24]
  if (timeout == kMaxWait)
   11d00:	e9d7 3408 	ldrd	r3, r4, [r7, #32]
   11d04:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   11d08:	bf08      	it	eq
   11d0a:	f1b3 3fff 	cmpeq.w	r3, #4294967295	; 0xffffffff
   11d0e:	d106      	bne.n	11d1e <sjsu::lpc40xx::Uart::Receive(unsigned long) const+0x4c>
    timeout_time = kMaxWait;
   11d10:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   11d14:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   11d18:	e9c7 3406 	strd	r3, r4, [r7, #24]
   11d1c:	e00a      	b.n	11d34 <sjsu::lpc40xx::Uart::Receive(unsigned long) const+0x62>
    timeout_time = Milliseconds() + timeout;
   11d1e:	f7fe fd0d 	bl	1073c <sjsu::Milliseconds()>
   11d22:	460a      	mov	r2, r1
   11d24:	4601      	mov	r1, r0
   11d26:	e9d7 3408 	ldrd	r3, r4, [r7, #32]
   11d2a:	185d      	adds	r5, r3, r1
   11d2c:	eb44 0602 	adc.w	r6, r4, r2
   11d30:	e9c7 5606 	strd	r5, r6, [r7, #24]
  Status status = Status::kTimedOut;
   11d34:	2301      	movs	r3, #1
   11d36:	617b      	str	r3, [r7, #20]
  while (Milliseconds() < timeout_time)
   11d38:	f7fe fd00 	bl	1073c <sjsu::Milliseconds()>
   11d3c:	460a      	mov	r2, r1
   11d3e:	4601      	mov	r1, r0
   11d40:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
   11d44:	42a2      	cmp	r2, r4
   11d46:	bf08      	it	eq
   11d48:	4299      	cmpeq	r1, r3
   11d4a:	bf34      	ite	cc
   11d4c:	2301      	movcc	r3, #1
   11d4e:	2300      	movcs	r3, #0
   11d50:	b2db      	uxtb	r3, r3
   11d52:	2b00      	cmp	r3, #0
   11d54:	d009      	beq.n	11d6a <sjsu::lpc40xx::Uart::Receive(unsigned long) const+0x98>
    if (is_done())
   11d56:	f107 030c 	add.w	r3, r7, #12
   11d5a:	4618      	mov	r0, r3
   11d5c:	f7ff ffa2 	bl	11ca4 <sjsu::lpc40xx::Uart::Receive(unsigned long) const::{lambda()#1}::operator()() const>
   11d60:	4603      	mov	r3, r0
   11d62:	2b00      	cmp	r3, #0
   11d64:	d0e8      	beq.n	11d38 <sjsu::lpc40xx::Uart::Receive(unsigned long) const+0x66>
      status = Status::kSuccess;
   11d66:	2300      	movs	r3, #0
   11d68:	617b      	str	r3, [r7, #20]
  return status;
   11d6a:	697b      	ldr	r3, [r7, #20]
   11d6c:	62bb      	str	r3, [r7, #40]	; 0x28

    if (status == Status::kSuccess)
   11d6e:	6abb      	ldr	r3, [r7, #40]	; 0x28
   11d70:	2b00      	cmp	r3, #0
   11d72:	d105      	bne.n	11d80 <sjsu::lpc40xx::Uart::Receive(unsigned long) const+0xae>
    {
      receiver = static_cast<uint8_t>(port_.registers->RBR);
   11d74:	687b      	ldr	r3, [r7, #4]
   11d76:	689b      	ldr	r3, [r3, #8]
   11d78:	681b      	ldr	r3, [r3, #0]
   11d7a:	781b      	ldrb	r3, [r3, #0]
   11d7c:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
    }
    return receiver;
   11d80:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  }
   11d84:	4618      	mov	r0, r3
   11d86:	3734      	adds	r7, #52	; 0x34
   11d88:	46bd      	mov	sp, r7
   11d8a:	bdf0      	pop	{r4, r5, r6, r7, pc}

00011d8c <(anonymous namespace)::Lpc40xxUptime()>:
{
   11d8c:	b598      	push	{r3, r4, r7, lr}
   11d8e:	af00      	add	r7, sp, #0
  return timer0.GetTimer();
   11d90:	4804      	ldr	r0, [pc, #16]	; (11da4 <(anonymous namespace)::Lpc40xxUptime()+0x18>)
   11d92:	f7ff fdfd 	bl	11990 <sjsu::lpc40xx::Timer::GetTimer() const>
   11d96:	4603      	mov	r3, r0
   11d98:	f04f 0400 	mov.w	r4, #0
}
   11d9c:	4618      	mov	r0, r3
   11d9e:	4621      	mov	r1, r4
   11da0:	bd98      	pop	{r3, r4, r7, pc}
   11da2:	bf00      	nop
   11da4:	10000324 	.word	0x10000324

00011da8 <UptimeRTOS>:
{
   11da8:	b598      	push	{r3, r4, r7, lr}
   11daa:	af00      	add	r7, sp, #0
  return timer0.GetTimer();
   11dac:	4804      	ldr	r0, [pc, #16]	; (11dc0 <UptimeRTOS+0x18>)
   11dae:	f7ff fdef 	bl	11990 <sjsu::lpc40xx::Timer::GetTimer() const>
   11db2:	4603      	mov	r3, r0
   11db4:	f04f 0400 	mov.w	r4, #0
}
   11db8:	4618      	mov	r0, r3
   11dba:	4621      	mov	r1, r4
   11dbc:	bd98      	pop	{r3, r4, r7, pc}
   11dbe:	bf00      	nop
   11dc0:	10000324 	.word	0x10000324

00011dc4 <InitializePlatform()>:

void InitializePlatform()
{
   11dc4:	b580      	push	{r7, lr}
   11dc6:	af00      	add	r7, sp, #0
  // Set Clock Speed
  // SetClockFrequency will timeout return the offset between desire clockspeed
  // and actual clockspeed if the PLL doesn't get a frequency fix within a
  // defined timeout (see L1/system_clock.hpp:kDefaultTimeout)
  while (system_controller.SetClockFrequency(config::kSystemClockRateMhz) != 0)
   11dc8:	2130      	movs	r1, #48	; 0x30
   11dca:	4811      	ldr	r0, [pc, #68]	; (11e10 <InitializePlatform()+0x4c>)
   11dcc:	f7ff f9ca 	bl	11164 <sjsu::lpc40xx::SystemController::SetClockFrequency(unsigned char) const>
   11dd0:	4603      	mov	r3, r0
   11dd2:	2b00      	cmp	r3, #0
   11dd4:	bf14      	ite	ne
   11dd6:	2301      	movne	r3, #1
   11dd8:	2300      	moveq	r3, #0
   11dda:	b2db      	uxtb	r3, r3
   11ddc:	2b00      	cmp	r3, #0
   11dde:	d001      	beq.n	11de4 <InitializePlatform()+0x20>
  {
    // Continually attempt to set the clock frequency to the desired until the
    // delta between desired and actual are 0.
    continue;
   11de0:	bf00      	nop
  while (system_controller.SetClockFrequency(config::kSystemClockRateMhz) != 0)
   11de2:	e7f1      	b.n	11dc8 <InitializePlatform()+0x4>
  }
  // Enable Peripheral Clock and set its divider to 1 meaning the clock speed
  // fed to all peripherals will be 48Mhz.
  system_controller.SetPeripheralClockDivider(1);
   11de4:	2101      	movs	r1, #1
   11de6:	480a      	ldr	r0, [pc, #40]	; (11e10 <InitializePlatform()+0x4c>)
   11de8:	f7ff f9fe 	bl	111e8 <sjsu::lpc40xx::SystemController::SetPeripheralClockDivider(unsigned char) const>
  // Set timer0 to 1 MHz (1,000,000 Hz) so that the timer increments every 1
  // micro second.
  timer0.Initialize(1'000'000UL);
   11dec:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   11df0:	2200      	movs	r2, #0
   11df2:	4908      	ldr	r1, [pc, #32]	; (11e14 <InitializePlatform()+0x50>)
   11df4:	4808      	ldr	r0, [pc, #32]	; (11e18 <InitializePlatform()+0x54>)
   11df6:	f7ff fcfd 	bl	117f4 <sjsu::lpc40xx::Timer::Initialize(unsigned long, void (*)(), long) const>
  sjsu::SetUptimeFunction(Lpc40xxUptime);
   11dfa:	4808      	ldr	r0, [pc, #32]	; (11e1c <InitializePlatform()+0x58>)
   11dfc:	f7ff f9a2 	bl	11144 <sjsu::SetUptimeFunction(unsigned long long (*)())>
  // Set UART0 baudrate, which is required for printf and scanf to work properly
  sjsu::lpc40xx::uart0.Initialize(config::kBaudRate);
   11e00:	f44f 4116 	mov.w	r1, #38400	; 0x9600
   11e04:	4806      	ldr	r0, [pc, #24]	; (11e20 <InitializePlatform()+0x5c>)
   11e06:	f7ff fe85 	bl	11b14 <sjsu::lpc40xx::Uart::Initialize(unsigned long) const>
}
   11e0a:	bf00      	nop
   11e0c:	bd80      	pop	{r7, pc}
   11e0e:	bf00      	nop
   11e10:	1000009c 	.word	0x1000009c
   11e14:	000f4240 	.word	0x000f4240
   11e18:	10000324 	.word	0x10000324
   11e1c:	00011d8d 	.word	0x00011d8d
   11e20:	10000090 	.word	0x10000090

00011e24 <SystemInitialize()>:

void SystemInitialize()
{
   11e24:	b580      	push	{r7, lr}
   11e26:	af00      	add	r7, sp, #0
  // Transfer data section values from flash to RAM
  InitializeDataSection();
   11e28:	f7fe f970 	bl	1010c <InitializeDataSection()>
  // Clear BSS section of RAM
  // This is required because the nano implementation of the standard C/C++
  // libraries assumes that the BSS section is initialized to 0.
  InitializeBssSection();
   11e2c:	f7fe f9bc 	bl	101a8 <InitializeBssSection()>
  // Enable FPU (F.loating P.oint U.nit)
  // System will crash if floating point instruction is executed before
  // Initializing the FPU first.
  InitializeFloatingPointUnit();
   11e30:	f7fe f9f0 	bl	10214 <InitializeFloatingPointUnit()>
  // Initialisation C++ libraries
  __libc_init_array();
   11e34:	f002 fcce 	bl	147d4 <__libc_init_array>
  // Run Low Level Platform Initialization
  InitializePlatform();
   11e38:	f7ff ffc4 	bl	11dc4 <InitializePlatform()>
}
   11e3c:	bf00      	nop
   11e3e:	bd80      	pop	{r7, pc}

00011e40 <ResetIsr>:
SJ2_SECTION(".crp") const uint32_t kCrpWord = 0xFFFFFFFF;
// Reset entry point for your code.
// Sets up a simple runtime environment and initializes the C/C++ library.

extern "C" void ResetIsr()
{
   11e40:	b580      	push	{r7, lr}
   11e42:	b084      	sub	sp, #16
   11e44:	af00      	add	r7, sp, #0
  // The Hyperload bootloader takes up stack space to execute. The Hyperload
  // bootloader function launches this ISR manually, but it never returns thus
  // it never cleans up the memory it uses. To get that memory back, we have
  // to manually move the stack pointers back to the top of stack.
  const uint32_t kTopOfStack = reinterpret_cast<intptr_t>(&StackTop);
   11e46:	4b09      	ldr	r3, [pc, #36]	; (11e6c <ResetIsr+0x2c>)
   11e48:	60fb      	str	r3, [r7, #12]
   11e4a:	68fb      	ldr	r3, [r7, #12]
   11e4c:	603b      	str	r3, [r7, #0]
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
   11e4e:	683b      	ldr	r3, [r7, #0]
   11e50:	f383 8809 	msr	PSP, r3
   11e54:	68fb      	ldr	r3, [r7, #12]
   11e56:	607b      	str	r3, [r7, #4]

    \param [in]    topOfMainStack  Main Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
{
  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
   11e58:	687b      	ldr	r3, [r7, #4]
   11e5a:	f383 8808 	msr	MSP, r3
  __set_PSP(kTopOfStack);
  __set_MSP(kTopOfStack);

  SystemInitialize();
   11e5e:	f7ff ffe1 	bl	11e24 <SystemInitialize()>
// #pragma ignored "-Wpedantic" to suppress main function call warning
#pragma GCC diagnostic push ignored "-Wpedantic"
  [[maybe_unused]] int32_t result = main();
   11e62:	f7ff f859 	bl	10f18 <main>
   11e66:	60b8      	str	r0, [r7, #8]
   11e68:	e7fe      	b.n	11e68 <ResetIsr+0x28>
   11e6a:	bf00      	nop
   11e6c:	10010000 	.word	0x10010000

00011e70 <void sjsu::lpc40xx::Timer::TimerHandler<sjsu::lpc40xx::Timer::Channel::kTimerPartial0>()>:
  static void TimerHandler()
   11e70:	b580      	push	{r7, lr}
   11e72:	af00      	add	r7, sp, #0
    TimerHandler(port);
   11e74:	4802      	ldr	r0, [pc, #8]	; (11e80 <void sjsu::lpc40xx::Timer::TimerHandler<sjsu::lpc40xx::Timer::Channel::kTimerPartial0>()+0x10>)
   11e76:	f7ff fc4f 	bl	11718 <sjsu::lpc40xx::Timer::TimerHandler(sjsu::lpc40xx::Timer::ChannelPartial_t const&)>
  }
   11e7a:	bf00      	nop
   11e7c:	bd80      	pop	{r7, pc}
   11e7e:	bf00      	nop
   11e80:	000156a0 	.word	0x000156a0

00011e84 <__static_initialization_and_destruction_0(int, int)>:
// Enforce the warning after this point
#pragma GCC diagnostic pop
  // main() shouldn't return, but if it does, we'll just enter an infinite
  // loop
  sjsu::Halt();
}
   11e84:	b580      	push	{r7, lr}
   11e86:	b082      	sub	sp, #8
   11e88:	af00      	add	r7, sp, #0
   11e8a:	6078      	str	r0, [r7, #4]
   11e8c:	6039      	str	r1, [r7, #0]
   11e8e:	687b      	ldr	r3, [r7, #4]
   11e90:	2b01      	cmp	r3, #1
   11e92:	d10a      	bne.n	11eaa <__static_initialization_and_destruction_0(int, int)+0x26>
   11e94:	683b      	ldr	r3, [r7, #0]
   11e96:	f64f 72ff 	movw	r2, #65535	; 0xffff
   11e9a:	4293      	cmp	r3, r2
   11e9c:	d105      	bne.n	11eaa <__static_initialization_and_destruction_0(int, int)+0x26>
sjsu::lpc40xx::Timer timer0(sjsu::lpc40xx::Timer::Channel::kTimer0);
   11e9e:	4b05      	ldr	r3, [pc, #20]	; (11eb4 <__static_initialization_and_destruction_0(int, int)+0x30>)
   11ea0:	e893 0006 	ldmia.w	r3, {r1, r2}
   11ea4:	4804      	ldr	r0, [pc, #16]	; (11eb8 <__static_initialization_and_destruction_0(int, int)+0x34>)
   11ea6:	f7ff fc83 	bl	117b0 <sjsu::lpc40xx::Timer::Timer(sjsu::lpc40xx::Timer::Channel_t)>
}
   11eaa:	bf00      	nop
   11eac:	3708      	adds	r7, #8
   11eae:	46bd      	mov	sp, r7
   11eb0:	bd80      	pop	{r7, pc}
   11eb2:	bf00      	nop
   11eb4:	000156b0 	.word	0x000156b0
   11eb8:	10000324 	.word	0x10000324

00011ebc <_GLOBAL__sub_I_UptimeRTOS>:
   11ebc:	b580      	push	{r7, lr}
   11ebe:	af00      	add	r7, sp, #0
   11ec0:	f64f 71ff 	movw	r1, #65535	; 0xffff
   11ec4:	2001      	movs	r0, #1
   11ec6:	f7ff ffdd 	bl	11e84 <__static_initialization_and_destruction_0(int, int)>
   11eca:	bd80      	pop	{r7, pc}

00011ecc <NVIC_EnableIRQ>:
  \brief   Enable External Interrupt
  \details Enables a device-specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
   11ecc:	b480      	push	{r7}
   11ece:	b083      	sub	sp, #12
   11ed0:	af00      	add	r7, sp, #0
   11ed2:	4603      	mov	r3, r0
   11ed4:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
   11ed6:	f997 3007 	ldrsb.w	r3, [r7, #7]
   11eda:	f003 021f 	and.w	r2, r3, #31
   11ede:	4907      	ldr	r1, [pc, #28]	; (11efc <NVIC_EnableIRQ+0x30>)
   11ee0:	f997 3007 	ldrsb.w	r3, [r7, #7]
   11ee4:	095b      	lsrs	r3, r3, #5
   11ee6:	2001      	movs	r0, #1
   11ee8:	fa00 f202 	lsl.w	r2, r0, r2
   11eec:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   11ef0:	bf00      	nop
   11ef2:	370c      	adds	r7, #12
   11ef4:	46bd      	mov	sp, r7
   11ef6:	f85d 7b04 	ldr.w	r7, [sp], #4
   11efa:	4770      	bx	lr
   11efc:	e000e100 	.word	0xe000e100

00011f00 <NVIC_SetPriority>:
  \note    The priority cannot be set for every core interrupt.
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
   11f00:	b480      	push	{r7}
   11f02:	b083      	sub	sp, #12
   11f04:	af00      	add	r7, sp, #0
   11f06:	4603      	mov	r3, r0
   11f08:	6039      	str	r1, [r7, #0]
   11f0a:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) < 0)
   11f0c:	f997 3007 	ldrsb.w	r3, [r7, #7]
   11f10:	2b00      	cmp	r3, #0
   11f12:	da0c      	bge.n	11f2e <NVIC_SetPriority+0x2e>
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   11f14:	683b      	ldr	r3, [r7, #0]
   11f16:	b2da      	uxtb	r2, r3
   11f18:	490e      	ldr	r1, [pc, #56]	; (11f54 <NVIC_SetPriority+0x54>)
   11f1a:	f997 3007 	ldrsb.w	r3, [r7, #7]
   11f1e:	f003 030f 	and.w	r3, r3, #15
   11f22:	3b04      	subs	r3, #4
   11f24:	0152      	lsls	r2, r2, #5
   11f26:	b2d2      	uxtb	r2, r2
   11f28:	440b      	add	r3, r1
   11f2a:	761a      	strb	r2, [r3, #24]
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
   11f2c:	e00b      	b.n	11f46 <NVIC_SetPriority+0x46>
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   11f2e:	683b      	ldr	r3, [r7, #0]
   11f30:	b2db      	uxtb	r3, r3
   11f32:	4a09      	ldr	r2, [pc, #36]	; (11f58 <NVIC_SetPriority+0x58>)
   11f34:	f997 1007 	ldrsb.w	r1, [r7, #7]
   11f38:	4608      	mov	r0, r1
   11f3a:	015b      	lsls	r3, r3, #5
   11f3c:	b2d9      	uxtb	r1, r3
   11f3e:	1813      	adds	r3, r2, r0
   11f40:	460a      	mov	r2, r1
   11f42:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
   11f46:	bf00      	nop
   11f48:	370c      	adds	r7, #12
   11f4a:	46bd      	mov	sp, r7
   11f4c:	f85d 7b04 	ldr.w	r7, [sp], #4
   11f50:	4770      	bx	lr
   11f52:	bf00      	nop
   11f54:	e000ed00 	.word	0xe000ed00
   11f58:	e000e100 	.word	0xe000e100

00011f5c <InterruptLookupHandler>:
{
   11f5c:	b580      	push	{r7, lr}
   11f5e:	b084      	sub	sp, #16
   11f60:	af02      	add	r7, sp, #8
  uint8_t active_isr = (SCB->ICSR & 0xFF);
   11f62:	4b11      	ldr	r3, [pc, #68]	; (11fa8 <InterruptLookupHandler+0x4c>)
   11f64:	685b      	ldr	r3, [r3, #4]
   11f66:	71fb      	strb	r3, [r7, #7]
  IsrPointer isr     = dynamic_isr_vector_table[active_isr];
   11f68:	79fb      	ldrb	r3, [r7, #7]
   11f6a:	4a10      	ldr	r2, [pc, #64]	; (11fac <InterruptLookupHandler+0x50>)
   11f6c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11f70:	603b      	str	r3, [r7, #0]
  SJ2_ASSERT_FATAL(isr != InterruptLookupHandler,
   11f72:	683b      	ldr	r3, [r7, #0]
   11f74:	4a0e      	ldr	r2, [pc, #56]	; (11fb0 <InterruptLookupHandler+0x54>)
   11f76:	4293      	cmp	r3, r2
   11f78:	d10f      	bne.n	11f9a <InterruptLookupHandler+0x3e>
   11f7a:	79fb      	ldrb	r3, [r7, #7]
   11f7c:	9300      	str	r3, [sp, #0]
   11f7e:	23dd      	movs	r3, #221	; 0xdd
   11f80:	4a0c      	ldr	r2, [pc, #48]	; (11fb4 <InterruptLookupHandler+0x58>)
   11f82:	490d      	ldr	r1, [pc, #52]	; (11fb8 <InterruptLookupHandler+0x5c>)
   11f84:	480d      	ldr	r0, [pc, #52]	; (11fbc <InterruptLookupHandler+0x60>)
   11f86:	f001 fa95 	bl	134b4 <printf>
   11f8a:	480d      	ldr	r0, [pc, #52]	; (11fc0 <InterruptLookupHandler+0x64>)
   11f8c:	f000 f8c2 	bl	12114 <puts>
   11f90:	2100      	movs	r1, #0
   11f92:	2001      	movs	r0, #1
   11f94:	f7fe fb74 	bl	10680 <sjsu::debug::PrintBacktrace(bool, void*)>
   11f98:	e7fe      	b.n	11f98 <InterruptLookupHandler+0x3c>
  isr();
   11f9a:	683b      	ldr	r3, [r7, #0]
   11f9c:	4798      	blx	r3
}
   11f9e:	bf00      	nop
   11fa0:	3708      	adds	r7, #8
   11fa2:	46bd      	mov	sp, r7
   11fa4:	bd80      	pop	{r7, pc}
   11fa6:	bf00      	nop
   11fa8:	e000ed00 	.word	0xe000ed00
   11fac:	100000a0 	.word	0x100000a0
   11fb0:	00011f5d 	.word	0x00011f5d
   11fb4:	00015d04 	.word	0x00015d04
   11fb8:	00015cf4 	.word	0x00015cf4
   11fbc:	00015b98 	.word	0x00015b98
   11fc0:	00015c44 	.word	0x00015c44

00011fc4 <RegisterIsr(IRQn, void (*)(), bool, long)>:
{
   11fc4:	b580      	push	{r7, lr}
   11fc6:	b084      	sub	sp, #16
   11fc8:	af00      	add	r7, sp, #0
   11fca:	60b9      	str	r1, [r7, #8]
   11fcc:	607b      	str	r3, [r7, #4]
   11fce:	4603      	mov	r3, r0
   11fd0:	73fb      	strb	r3, [r7, #15]
   11fd2:	4613      	mov	r3, r2
   11fd4:	73bb      	strb	r3, [r7, #14]
  dynamic_isr_vector_table[irq + kIrqOffset] = isr;
   11fd6:	f997 300f 	ldrsb.w	r3, [r7, #15]
   11fda:	3310      	adds	r3, #16
   11fdc:	490e      	ldr	r1, [pc, #56]	; (12018 <RegisterIsr(IRQn, void (*)(), bool, long)+0x54>)
   11fde:	68ba      	ldr	r2, [r7, #8]
   11fe0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  if (enable_interrupt && irq >= 0)
   11fe4:	7bbb      	ldrb	r3, [r7, #14]
   11fe6:	2b00      	cmp	r3, #0
   11fe8:	d008      	beq.n	11ffc <RegisterIsr(IRQn, void (*)(), bool, long)+0x38>
   11fea:	f997 300f 	ldrsb.w	r3, [r7, #15]
   11fee:	2b00      	cmp	r3, #0
   11ff0:	db04      	blt.n	11ffc <RegisterIsr(IRQn, void (*)(), bool, long)+0x38>
    NVIC_EnableIRQ(irq);
   11ff2:	f997 300f 	ldrsb.w	r3, [r7, #15]
   11ff6:	4618      	mov	r0, r3
   11ff8:	f7ff ff68 	bl	11ecc <NVIC_EnableIRQ>
  if (priority > -1)
   11ffc:	687b      	ldr	r3, [r7, #4]
   11ffe:	2b00      	cmp	r3, #0
   12000:	db06      	blt.n	12010 <RegisterIsr(IRQn, void (*)(), bool, long)+0x4c>
    NVIC_SetPriority(irq, priority);
   12002:	687a      	ldr	r2, [r7, #4]
   12004:	f997 300f 	ldrsb.w	r3, [r7, #15]
   12008:	4611      	mov	r1, r2
   1200a:	4618      	mov	r0, r3
   1200c:	f7ff ff78 	bl	11f00 <NVIC_SetPriority>
}
   12010:	bf00      	nop
   12012:	3710      	adds	r7, #16
   12014:	46bd      	mov	sp, r7
   12016:	bd80      	pop	{r7, pc}
   12018:	100000a0 	.word	0x100000a0

0001201c <GetRegistersFromStack>:
{
   1201c:	b580      	push	{r7, lr}
   1201e:	b08c      	sub	sp, #48	; 0x30
   12020:	af02      	add	r7, sp, #8
   12022:	6078      	str	r0, [r7, #4]
  volatile uint32_t r0  = fault_stack_address[0];
   12024:	687b      	ldr	r3, [r7, #4]
   12026:	681b      	ldr	r3, [r3, #0]
   12028:	627b      	str	r3, [r7, #36]	; 0x24
  volatile uint32_t r1  = fault_stack_address[1];
   1202a:	687b      	ldr	r3, [r7, #4]
   1202c:	685b      	ldr	r3, [r3, #4]
   1202e:	623b      	str	r3, [r7, #32]
  volatile uint32_t r2  = fault_stack_address[2];
   12030:	687b      	ldr	r3, [r7, #4]
   12032:	689b      	ldr	r3, [r3, #8]
   12034:	61fb      	str	r3, [r7, #28]
  volatile uint32_t r3  = fault_stack_address[3];
   12036:	687b      	ldr	r3, [r7, #4]
   12038:	68db      	ldr	r3, [r3, #12]
   1203a:	61bb      	str	r3, [r7, #24]
  volatile uint32_t r12 = fault_stack_address[4];
   1203c:	687b      	ldr	r3, [r7, #4]
   1203e:	691b      	ldr	r3, [r3, #16]
   12040:	617b      	str	r3, [r7, #20]
  volatile uint32_t lr = fault_stack_address[5];
   12042:	687b      	ldr	r3, [r7, #4]
   12044:	695b      	ldr	r3, [r3, #20]
   12046:	613b      	str	r3, [r7, #16]
  volatile uint32_t pc = fault_stack_address[6];
   12048:	687b      	ldr	r3, [r7, #4]
   1204a:	699b      	ldr	r3, [r3, #24]
   1204c:	60fb      	str	r3, [r7, #12]
  volatile uint32_t psr = fault_stack_address[7];
   1204e:	687b      	ldr	r3, [r7, #4]
   12050:	69db      	ldr	r3, [r3, #28]
   12052:	60bb      	str	r3, [r7, #8]
  printf(SJ2_BACKGROUND_RED "Hard Fault Exception Occurred!\n" SJ2_COLOR_RESET);
   12054:	480d      	ldr	r0, [pc, #52]	; (1208c <GetRegistersFromStack+0x70>)
   12056:	f001 fa2d 	bl	134b4 <printf>
  printf("r0: 0x%08" PRIX32 ", r1: 0x%08" PRIX32
   1205a:	6a79      	ldr	r1, [r7, #36]	; 0x24
   1205c:	6a3a      	ldr	r2, [r7, #32]
   1205e:	69f8      	ldr	r0, [r7, #28]
   12060:	69bb      	ldr	r3, [r7, #24]
   12062:	9300      	str	r3, [sp, #0]
   12064:	4603      	mov	r3, r0
   12066:	480a      	ldr	r0, [pc, #40]	; (12090 <GetRegistersFromStack+0x74>)
   12068:	f001 fa24 	bl	134b4 <printf>
  printf("r12: 0x%08" PRIX32 ", lr: 0x%08" PRIX32
   1206c:	6979      	ldr	r1, [r7, #20]
   1206e:	693a      	ldr	r2, [r7, #16]
   12070:	68f8      	ldr	r0, [r7, #12]
   12072:	68bb      	ldr	r3, [r7, #8]
   12074:	9300      	str	r3, [sp, #0]
   12076:	4603      	mov	r3, r0
   12078:	4806      	ldr	r0, [pc, #24]	; (12094 <GetRegistersFromStack+0x78>)
   1207a:	f001 fa1b 	bl	134b4 <printf>
  sjsu::debug::PrintBacktrace(true, reinterpret_cast<void *>(pc));
   1207e:	68fb      	ldr	r3, [r7, #12]
   12080:	4619      	mov	r1, r3
   12082:	2001      	movs	r0, #1
   12084:	f7fe fafc 	bl	10680 <sjsu::debug::PrintBacktrace(bool, void*)>
   12088:	e7fe      	b.n	12088 <GetRegistersFromStack+0x6c>
   1208a:	bf00      	nop
   1208c:	00015c5c 	.word	0x00015c5c
   12090:	00015c88 	.word	0x00015c88
   12094:	00015cbc 	.word	0x00015cbc

00012098 <FirmwareStdOut(int)>:
}
Stdout out = HostWrite;
Stdin in   = HostRead;
#else
int FirmwareStdOut(int data)
{
   12098:	b580      	push	{r7, lr}
   1209a:	b082      	sub	sp, #8
   1209c:	af00      	add	r7, sp, #0
   1209e:	6078      	str	r0, [r7, #4]
  sjsu::lpc40xx::uart0.Send(static_cast<uint8_t>(data));
   120a0:	687b      	ldr	r3, [r7, #4]
   120a2:	b2db      	uxtb	r3, r3
   120a4:	4619      	mov	r1, r3
   120a6:	4804      	ldr	r0, [pc, #16]	; (120b8 <FirmwareStdOut(int)+0x20>)
   120a8:	f7ff fda8 	bl	11bfc <sjsu::lpc40xx::Uart::Send(unsigned char) const>
  return 1;
   120ac:	2301      	movs	r3, #1
}
   120ae:	4618      	mov	r0, r3
   120b0:	3708      	adds	r7, #8
   120b2:	46bd      	mov	sp, r7
   120b4:	bd80      	pop	{r7, pc}
   120b6:	bf00      	nop
   120b8:	10000090 	.word	0x10000090

000120bc <_exit>:
  }
  // Dummy implementation of exit with return code placed into
  // Arm register r3
  // NOLINTNEXTLINE(readability-identifier-naming)
  void _exit([[maybe_unused]] int rc)
  {
   120bc:	b480      	push	{r7}
   120be:	b083      	sub	sp, #12
   120c0:	af00      	add	r7, sp, #0
   120c2:	6078      	str	r0, [r7, #4]
    while (1)
    {
      continue;
   120c4:	bf00      	nop
    while (1)
   120c6:	e7fd      	b.n	120c4 <_exit+0x8>

000120c8 <_getpid>:
    }
  }
  // Dummy implementation of getpid
  // NOLINTNEXTLINE(readability-identifier-naming)
  int _getpid()
  {
   120c8:	b480      	push	{r7}
   120ca:	af00      	add	r7, sp, #0
    return 1;
   120cc:	2301      	movs	r3, #1
  }
   120ce:	4618      	mov	r0, r3
   120d0:	46bd      	mov	sp, r7
   120d2:	f85d 7b04 	ldr.w	r7, [sp], #4
   120d6:	4770      	bx	lr

000120d8 <_kill>:
  // Dummy implementation of kill
  // NOLINTNEXTLINE(readability-identifier-naming)
  int _kill(int, int)
  {
   120d8:	b480      	push	{r7}
   120da:	b083      	sub	sp, #12
   120dc:	af00      	add	r7, sp, #0
   120de:	6078      	str	r0, [r7, #4]
   120e0:	6039      	str	r1, [r7, #0]
    return -1;
   120e2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  }
   120e6:	4618      	mov	r0, r3
   120e8:	370c      	adds	r7, #12
   120ea:	46bd      	mov	sp, r7
   120ec:	f85d 7b04 	ldr.w	r7, [sp], #4
   120f0:	4770      	bx	lr
   120f2:	Address 0x00000000000120f2 is out of bounds.


000120f4 <_putchar>:
    }
    return length;
  }
  // Needed by third party printf library
  void _putchar(char character)  // NOLINT
  {
   120f4:	b580      	push	{r7, lr}
   120f6:	b082      	sub	sp, #8
   120f8:	af00      	add	r7, sp, #0
   120fa:	4603      	mov	r3, r0
   120fc:	71fb      	strb	r3, [r7, #7]
    out(character);
   120fe:	4b04      	ldr	r3, [pc, #16]	; (12110 <_putchar+0x1c>)
   12100:	681b      	ldr	r3, [r3, #0]
   12102:	79fa      	ldrb	r2, [r7, #7]
   12104:	4610      	mov	r0, r2
   12106:	4798      	blx	r3
  }
   12108:	bf00      	nop
   1210a:	3708      	adds	r7, #8
   1210c:	46bd      	mov	sp, r7
   1210e:	bd80      	pop	{r7, pc}
   12110:	10000184 	.word	0x10000184

00012114 <puts>:
  }

  // Overload default libnano puts() with a more optimal version that does
  // not use dynamic memory
  int puts(const char * str)  // NOLINT
  {
   12114:	b580      	push	{r7, lr}
   12116:	b084      	sub	sp, #16
   12118:	af00      	add	r7, sp, #0
   1211a:	6078      	str	r0, [r7, #4]
    int i;
    for (i = 0; str[i] != '\0'; i++)
   1211c:	2300      	movs	r3, #0
   1211e:	60fb      	str	r3, [r7, #12]
   12120:	68fb      	ldr	r3, [r7, #12]
   12122:	687a      	ldr	r2, [r7, #4]
   12124:	4413      	add	r3, r2
   12126:	781b      	ldrb	r3, [r3, #0]
   12128:	2b00      	cmp	r3, #0
   1212a:	d00b      	beq.n	12144 <puts+0x30>
    {
      out(str[i]);
   1212c:	4b0a      	ldr	r3, [pc, #40]	; (12158 <puts+0x44>)
   1212e:	681b      	ldr	r3, [r3, #0]
   12130:	68fa      	ldr	r2, [r7, #12]
   12132:	6879      	ldr	r1, [r7, #4]
   12134:	440a      	add	r2, r1
   12136:	7812      	ldrb	r2, [r2, #0]
   12138:	4610      	mov	r0, r2
   1213a:	4798      	blx	r3
    for (i = 0; str[i] != '\0'; i++)
   1213c:	68fb      	ldr	r3, [r7, #12]
   1213e:	3301      	adds	r3, #1
   12140:	60fb      	str	r3, [r7, #12]
   12142:	e7ed      	b.n	12120 <puts+0xc>
    }
    out('\n');
   12144:	4b04      	ldr	r3, [pc, #16]	; (12158 <puts+0x44>)
   12146:	681b      	ldr	r3, [r3, #0]
   12148:	200a      	movs	r0, #10
   1214a:	4798      	blx	r3
    return i;
   1214c:	68fb      	ldr	r3, [r7, #12]
  }
   1214e:	4618      	mov	r0, r3
   12150:	3710      	adds	r7, #16
   12152:	46bd      	mov	sp, r7
   12154:	bd80      	pop	{r7, pc}
   12156:	bf00      	nop
   12158:	10000184 	.word	0x10000184

0001215c <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
   1215c:	b590      	push	{r4, r7, lr}
   1215e:	b085      	sub	sp, #20
   12160:	af00      	add	r7, sp, #0
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
   12162:	4b29      	ldr	r3, [pc, #164]	; (12208 <vTaskSwitchContext+0xac>)
   12164:	681b      	ldr	r3, [r3, #0]
   12166:	2b00      	cmp	r3, #0
   12168:	d003      	beq.n	12172 <vTaskSwitchContext+0x16>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
   1216a:	4b28      	ldr	r3, [pc, #160]	; (1220c <vTaskSwitchContext+0xb0>)
   1216c:	2201      	movs	r2, #1
   1216e:	601a      	str	r2, [r3, #0]
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
   12170:	e045      	b.n	121fe <vTaskSwitchContext+0xa2>
		xYieldPending = pdFALSE;
   12172:	4b26      	ldr	r3, [pc, #152]	; (1220c <vTaskSwitchContext+0xb0>)
   12174:	2200      	movs	r2, #0
   12176:	601a      	str	r2, [r3, #0]
					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
   12178:	f7ff fe16 	bl	11da8 <UptimeRTOS>
   1217c:	4603      	mov	r3, r0
   1217e:	460c      	mov	r4, r1
   12180:	461a      	mov	r2, r3
   12182:	4b23      	ldr	r3, [pc, #140]	; (12210 <vTaskSwitchContext+0xb4>)
   12184:	601a      	str	r2, [r3, #0]
				if( ulTotalRunTime > ulTaskSwitchedInTime )
   12186:	4b22      	ldr	r3, [pc, #136]	; (12210 <vTaskSwitchContext+0xb4>)
   12188:	681a      	ldr	r2, [r3, #0]
   1218a:	4b22      	ldr	r3, [pc, #136]	; (12214 <vTaskSwitchContext+0xb8>)
   1218c:	681b      	ldr	r3, [r3, #0]
   1218e:	429a      	cmp	r2, r3
   12190:	d909      	bls.n	121a6 <vTaskSwitchContext+0x4a>
					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
   12192:	4b21      	ldr	r3, [pc, #132]	; (12218 <vTaskSwitchContext+0xbc>)
   12194:	681b      	ldr	r3, [r3, #0]
   12196:	6d59      	ldr	r1, [r3, #84]	; 0x54
   12198:	4a1d      	ldr	r2, [pc, #116]	; (12210 <vTaskSwitchContext+0xb4>)
   1219a:	6810      	ldr	r0, [r2, #0]
   1219c:	4a1d      	ldr	r2, [pc, #116]	; (12214 <vTaskSwitchContext+0xb8>)
   1219e:	6812      	ldr	r2, [r2, #0]
   121a0:	1a82      	subs	r2, r0, r2
   121a2:	440a      	add	r2, r1
   121a4:	655a      	str	r2, [r3, #84]	; 0x54
				ulTaskSwitchedInTime = ulTotalRunTime;
   121a6:	4b1a      	ldr	r3, [pc, #104]	; (12210 <vTaskSwitchContext+0xb4>)
   121a8:	681b      	ldr	r3, [r3, #0]
   121aa:	4a1a      	ldr	r2, [pc, #104]	; (12214 <vTaskSwitchContext+0xb8>)
   121ac:	6013      	str	r3, [r2, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK();
   121ae:	4b1b      	ldr	r3, [pc, #108]	; (1221c <vTaskSwitchContext+0xc0>)
   121b0:	681b      	ldr	r3, [r3, #0]
   121b2:	607b      	str	r3, [r7, #4]
	/* Generic helper function. */
	__attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitmap )
	{
	uint8_t ucReturn;

		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
   121b4:	687b      	ldr	r3, [r7, #4]
   121b6:	fab3 f383 	clz	r3, r3
   121ba:	70fb      	strb	r3, [r7, #3]
		return ucReturn;
   121bc:	78fb      	ldrb	r3, [r7, #3]
   121be:	f1c3 031f 	rsb	r3, r3, #31
   121c2:	60fb      	str	r3, [r7, #12]
   121c4:	68fa      	ldr	r2, [r7, #12]
   121c6:	4613      	mov	r3, r2
   121c8:	009b      	lsls	r3, r3, #2
   121ca:	4413      	add	r3, r2
   121cc:	009b      	lsls	r3, r3, #2
   121ce:	4a14      	ldr	r2, [pc, #80]	; (12220 <vTaskSwitchContext+0xc4>)
   121d0:	4413      	add	r3, r2
   121d2:	60bb      	str	r3, [r7, #8]
   121d4:	68bb      	ldr	r3, [r7, #8]
   121d6:	685b      	ldr	r3, [r3, #4]
   121d8:	685a      	ldr	r2, [r3, #4]
   121da:	68bb      	ldr	r3, [r7, #8]
   121dc:	605a      	str	r2, [r3, #4]
   121de:	68bb      	ldr	r3, [r7, #8]
   121e0:	685a      	ldr	r2, [r3, #4]
   121e2:	68bb      	ldr	r3, [r7, #8]
   121e4:	3308      	adds	r3, #8
   121e6:	429a      	cmp	r2, r3
   121e8:	d104      	bne.n	121f4 <vTaskSwitchContext+0x98>
   121ea:	68bb      	ldr	r3, [r7, #8]
   121ec:	685b      	ldr	r3, [r3, #4]
   121ee:	685a      	ldr	r2, [r3, #4]
   121f0:	68bb      	ldr	r3, [r7, #8]
   121f2:	605a      	str	r2, [r3, #4]
   121f4:	68bb      	ldr	r3, [r7, #8]
   121f6:	685b      	ldr	r3, [r3, #4]
   121f8:	68db      	ldr	r3, [r3, #12]
   121fa:	4a07      	ldr	r2, [pc, #28]	; (12218 <vTaskSwitchContext+0xbc>)
   121fc:	6013      	str	r3, [r2, #0]
}
   121fe:	bf00      	nop
   12200:	3714      	adds	r7, #20
   12202:	46bd      	mov	sp, r7
   12204:	bd90      	pop	{r4, r7, pc}
   12206:	bf00      	nop
   12208:	100003a0 	.word	0x100003a0
   1220c:	1000039c 	.word	0x1000039c
   12210:	100003a8 	.word	0x100003a8
   12214:	100003a4 	.word	0x100003a4
   12218:	10000330 	.word	0x10000330
   1221c:	10000398 	.word	0x10000398
   12220:	10000334 	.word	0x10000334
   12224:	ffffffff 	.word	0xffffffff
   12228:	ffffffff 	.word	0xffffffff
   1222c:	ffffffff 	.word	0xffffffff

00012230 <vPortSVCHandler>:
}
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
   12230:	4b07      	ldr	r3, [pc, #28]	; (12250 <pxCurrentTCBConst2>)
   12232:	6819      	ldr	r1, [r3, #0]
   12234:	6808      	ldr	r0, [r1, #0]
   12236:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1223a:	f380 8809 	msr	PSP, r0
   1223e:	f3bf 8f6f 	isb	sy
   12242:	f04f 0000 	mov.w	r0, #0
   12246:	f380 8811 	msr	BASEPRI, r0
   1224a:	4770      	bx	lr
   1224c:	f3af 8000 	nop.w

00012250 <pxCurrentTCBConst2>:
   12250:	10000330 	.word	0x10000330
					"	bx r14							\n"
					"									\n"
					"	.align 4						\n"
					"pxCurrentTCBConst2: .word pxCurrentTCB				\n"
				);
}
   12254:	bf00      	nop
   12256:	bf00      	nop
   12258:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1225c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff

00012260 <xPortPendSVHandler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
   12260:	f3ef 8009 	mrs	r0, PSP
   12264:	f3bf 8f6f 	isb	sy
   12268:	4b15      	ldr	r3, [pc, #84]	; (122c0 <pxCurrentTCBConst>)
   1226a:	681a      	ldr	r2, [r3, #0]
   1226c:	f01e 0f10 	tst.w	lr, #16
   12270:	bf08      	it	eq
   12272:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
   12276:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1227a:	6010      	str	r0, [r2, #0]
   1227c:	e92d 0009 	stmdb	sp!, {r0, r3}
   12280:	f04f 0028 	mov.w	r0, #40	; 0x28
   12284:	f380 8811 	msr	BASEPRI, r0
   12288:	f3bf 8f4f 	dsb	sy
   1228c:	f3bf 8f6f 	isb	sy
   12290:	f7ff ff64 	bl	1215c <vTaskSwitchContext>
   12294:	f04f 0000 	mov.w	r0, #0
   12298:	f380 8811 	msr	BASEPRI, r0
   1229c:	bc09      	pop	{r0, r3}
   1229e:	6819      	ldr	r1, [r3, #0]
   122a0:	6808      	ldr	r0, [r1, #0]
   122a2:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   122a6:	f01e 0f10 	tst.w	lr, #16
   122aa:	bf08      	it	eq
   122ac:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
   122b0:	f380 8809 	msr	PSP, r0
   122b4:	f3bf 8f6f 	isb	sy
   122b8:	4770      	bx	lr
   122ba:	bf00      	nop
   122bc:	f3af 8000 	nop.w

000122c0 <pxCurrentTCBConst>:
   122c0:	10000330 	.word	0x10000330
	"										\n"
	"	.align 4							\n"
	"pxCurrentTCBConst: .word pxCurrentTCB	\n"
	::"i"(configMAX_SYSCALL_INTERRUPT_PRIORITY)
	);
}
   122c4:	bf00      	nop
   122c6:	bf00      	nop

000122c8 <_out_null(char, void*, unsigned int, unsigned int)>:
}


// internal null output
static inline void _out_null(char character, void* buffer, size_t idx, size_t maxlen)
{
   122c8:	b480      	push	{r7}
   122ca:	b085      	sub	sp, #20
   122cc:	af00      	add	r7, sp, #0
   122ce:	60b9      	str	r1, [r7, #8]
   122d0:	607a      	str	r2, [r7, #4]
   122d2:	603b      	str	r3, [r7, #0]
   122d4:	4603      	mov	r3, r0
   122d6:	73fb      	strb	r3, [r7, #15]
  (void)character; (void)buffer; (void)idx; (void)maxlen;
}
   122d8:	bf00      	nop
   122da:	3714      	adds	r7, #20
   122dc:	46bd      	mov	sp, r7
   122de:	f85d 7b04 	ldr.w	r7, [sp], #4
   122e2:	4770      	bx	lr

000122e4 <_out_char(char, void*, unsigned int, unsigned int)>:


// internal _putchar wrapper
static inline void _out_char(char character, void* buffer, size_t idx, size_t maxlen)
{
   122e4:	b580      	push	{r7, lr}
   122e6:	b084      	sub	sp, #16
   122e8:	af00      	add	r7, sp, #0
   122ea:	60b9      	str	r1, [r7, #8]
   122ec:	607a      	str	r2, [r7, #4]
   122ee:	603b      	str	r3, [r7, #0]
   122f0:	4603      	mov	r3, r0
   122f2:	73fb      	strb	r3, [r7, #15]
  (void)buffer; (void)idx; (void)maxlen;
  if (character) {
   122f4:	7bfb      	ldrb	r3, [r7, #15]
   122f6:	2b00      	cmp	r3, #0
   122f8:	d003      	beq.n	12302 <_out_char(char, void*, unsigned int, unsigned int)+0x1e>
    _putchar(character);
   122fa:	7bfb      	ldrb	r3, [r7, #15]
   122fc:	4618      	mov	r0, r3
   122fe:	f7ff fef9 	bl	120f4 <_putchar>
  }
}
   12302:	bf00      	nop
   12304:	3710      	adds	r7, #16
   12306:	46bd      	mov	sp, r7
   12308:	bd80      	pop	{r7, pc}

0001230a <_strlen(char const*)>:


// internal strlen
// \return The length of the string (excluding the terminating 0)
static inline unsigned int _strlen(const char* str)
{
   1230a:	b480      	push	{r7}
   1230c:	b085      	sub	sp, #20
   1230e:	af00      	add	r7, sp, #0
   12310:	6078      	str	r0, [r7, #4]
  const char* s;
  for (s = str; *s; ++s);
   12312:	687b      	ldr	r3, [r7, #4]
   12314:	60fb      	str	r3, [r7, #12]
   12316:	68fb      	ldr	r3, [r7, #12]
   12318:	781b      	ldrb	r3, [r3, #0]
   1231a:	2b00      	cmp	r3, #0
   1231c:	d003      	beq.n	12326 <_strlen(char const*)+0x1c>
   1231e:	68fb      	ldr	r3, [r7, #12]
   12320:	3301      	adds	r3, #1
   12322:	60fb      	str	r3, [r7, #12]
   12324:	e7f7      	b.n	12316 <_strlen(char const*)+0xc>
  return (unsigned int)(s - str);
   12326:	68fa      	ldr	r2, [r7, #12]
   12328:	687b      	ldr	r3, [r7, #4]
   1232a:	1ad3      	subs	r3, r2, r3
}
   1232c:	4618      	mov	r0, r3
   1232e:	3714      	adds	r7, #20
   12330:	46bd      	mov	sp, r7
   12332:	f85d 7b04 	ldr.w	r7, [sp], #4
   12336:	4770      	bx	lr

00012338 <_is_digit(char)>:


// internal test if char is a digit (0-9)
// \return true if char is a digit
static inline bool _is_digit(char ch)
{
   12338:	b480      	push	{r7}
   1233a:	b083      	sub	sp, #12
   1233c:	af00      	add	r7, sp, #0
   1233e:	4603      	mov	r3, r0
   12340:	71fb      	strb	r3, [r7, #7]
  return (ch >= '0') && (ch <= '9');
   12342:	79fb      	ldrb	r3, [r7, #7]
   12344:	2b2f      	cmp	r3, #47	; 0x2f
   12346:	d904      	bls.n	12352 <_is_digit(char)+0x1a>
   12348:	79fb      	ldrb	r3, [r7, #7]
   1234a:	2b39      	cmp	r3, #57	; 0x39
   1234c:	d801      	bhi.n	12352 <_is_digit(char)+0x1a>
   1234e:	2301      	movs	r3, #1
   12350:	e000      	b.n	12354 <_is_digit(char)+0x1c>
   12352:	2300      	movs	r3, #0
}
   12354:	4618      	mov	r0, r3
   12356:	370c      	adds	r7, #12
   12358:	46bd      	mov	sp, r7
   1235a:	f85d 7b04 	ldr.w	r7, [sp], #4
   1235e:	4770      	bx	lr

00012360 <_atoi(char const**)>:


// internal ASCII string to unsigned int conversion
static unsigned int _atoi(const char** str)
{
   12360:	b580      	push	{r7, lr}
   12362:	b084      	sub	sp, #16
   12364:	af00      	add	r7, sp, #0
   12366:	6078      	str	r0, [r7, #4]
  unsigned int i = 0U;
   12368:	2300      	movs	r3, #0
   1236a:	60fb      	str	r3, [r7, #12]
  while (_is_digit(**str)) {
   1236c:	687b      	ldr	r3, [r7, #4]
   1236e:	681b      	ldr	r3, [r3, #0]
   12370:	781b      	ldrb	r3, [r3, #0]
   12372:	4618      	mov	r0, r3
   12374:	f7ff ffe0 	bl	12338 <_is_digit(char)>
   12378:	4603      	mov	r3, r0
   1237a:	2b00      	cmp	r3, #0
   1237c:	d00f      	beq.n	1239e <_atoi(char const**)+0x3e>
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
   1237e:	68fa      	ldr	r2, [r7, #12]
   12380:	4613      	mov	r3, r2
   12382:	009b      	lsls	r3, r3, #2
   12384:	4413      	add	r3, r2
   12386:	005b      	lsls	r3, r3, #1
   12388:	4618      	mov	r0, r3
   1238a:	687b      	ldr	r3, [r7, #4]
   1238c:	681b      	ldr	r3, [r3, #0]
   1238e:	1c59      	adds	r1, r3, #1
   12390:	687a      	ldr	r2, [r7, #4]
   12392:	6011      	str	r1, [r2, #0]
   12394:	781b      	ldrb	r3, [r3, #0]
   12396:	4403      	add	r3, r0
   12398:	3b30      	subs	r3, #48	; 0x30
   1239a:	60fb      	str	r3, [r7, #12]
  while (_is_digit(**str)) {
   1239c:	e7e6      	b.n	1236c <_atoi(char const**)+0xc>
  }
  return i;
   1239e:	68fb      	ldr	r3, [r7, #12]
}
   123a0:	4618      	mov	r0, r3
   123a2:	3710      	adds	r7, #16
   123a4:	46bd      	mov	sp, r7
   123a6:	bd80      	pop	{r7, pc}

000123a8 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)>:


// internal itoa format
static size_t _ntoa_format(out_fct_type out, char* buffer, size_t idx, size_t maxlen, char* buf, size_t len, bool negative, unsigned int base, unsigned int prec, unsigned int width, unsigned int flags)
{
   123a8:	b590      	push	{r4, r7, lr}
   123aa:	b089      	sub	sp, #36	; 0x24
   123ac:	af00      	add	r7, sp, #0
   123ae:	60f8      	str	r0, [r7, #12]
   123b0:	60b9      	str	r1, [r7, #8]
   123b2:	607a      	str	r2, [r7, #4]
   123b4:	603b      	str	r3, [r7, #0]
  const size_t start_idx = idx;
   123b6:	687b      	ldr	r3, [r7, #4]
   123b8:	617b      	str	r3, [r7, #20]

  // pad leading zeros
  while (!(flags & FLAGS_LEFT) && (len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   123ba:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   123bc:	f003 0302 	and.w	r3, r3, #2
   123c0:	2b00      	cmp	r3, #0
   123c2:	d10e      	bne.n	123e2 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x3a>
   123c4:	6b7a      	ldr	r2, [r7, #52]	; 0x34
   123c6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   123c8:	429a      	cmp	r2, r3
   123ca:	d20a      	bcs.n	123e2 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x3a>
   123cc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   123ce:	2b1f      	cmp	r3, #31
   123d0:	d807      	bhi.n	123e2 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x3a>
    buf[len++] = '0';
   123d2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   123d4:	1c5a      	adds	r2, r3, #1
   123d6:	637a      	str	r2, [r7, #52]	; 0x34
   123d8:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   123da:	4413      	add	r3, r2
   123dc:	2230      	movs	r2, #48	; 0x30
   123de:	701a      	strb	r2, [r3, #0]
  while (!(flags & FLAGS_LEFT) && (len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   123e0:	e7eb      	b.n	123ba <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x12>
  }
  while (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   123e2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   123e4:	f003 0302 	and.w	r3, r3, #2
   123e8:	2b00      	cmp	r3, #0
   123ea:	d113      	bne.n	12414 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x6c>
   123ec:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   123ee:	f003 0301 	and.w	r3, r3, #1
   123f2:	2b00      	cmp	r3, #0
   123f4:	d00e      	beq.n	12414 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x6c>
   123f6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
   123f8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   123fa:	429a      	cmp	r2, r3
   123fc:	d20a      	bcs.n	12414 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x6c>
   123fe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   12400:	2b1f      	cmp	r3, #31
   12402:	d807      	bhi.n	12414 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x6c>
    buf[len++] = '0';
   12404:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   12406:	1c5a      	adds	r2, r3, #1
   12408:	637a      	str	r2, [r7, #52]	; 0x34
   1240a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   1240c:	4413      	add	r3, r2
   1240e:	2230      	movs	r2, #48	; 0x30
   12410:	701a      	strb	r2, [r3, #0]
  while (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   12412:	e7e6      	b.n	123e2 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x3a>
  }

  // handle hash
  if (flags & FLAGS_HASH) {
   12414:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   12416:	f003 0310 	and.w	r3, r3, #16
   1241a:	2b00      	cmp	r3, #0
   1241c:	d058      	beq.n	124d0 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x128>
    if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
   1241e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   12420:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   12424:	2b00      	cmp	r3, #0
   12426:	d116      	bne.n	12456 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xae>
   12428:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   1242a:	2b00      	cmp	r3, #0
   1242c:	d013      	beq.n	12456 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xae>
   1242e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
   12430:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   12432:	429a      	cmp	r2, r3
   12434:	d003      	beq.n	1243e <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x96>
   12436:	6b7a      	ldr	r2, [r7, #52]	; 0x34
   12438:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   1243a:	429a      	cmp	r2, r3
   1243c:	d10b      	bne.n	12456 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xae>
      len--;
   1243e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   12440:	3b01      	subs	r3, #1
   12442:	637b      	str	r3, [r7, #52]	; 0x34
      if (len && (base == 16U)) {
   12444:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   12446:	2b00      	cmp	r3, #0
   12448:	d005      	beq.n	12456 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xae>
   1244a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   1244c:	2b10      	cmp	r3, #16
   1244e:	d102      	bne.n	12456 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xae>
        len--;
   12450:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   12452:	3b01      	subs	r3, #1
   12454:	637b      	str	r3, [r7, #52]	; 0x34
      }
    }
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   12456:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   12458:	2b10      	cmp	r3, #16
   1245a:	d10f      	bne.n	1247c <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xd4>
   1245c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   1245e:	f003 0320 	and.w	r3, r3, #32
   12462:	2b00      	cmp	r3, #0
   12464:	d10a      	bne.n	1247c <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xd4>
   12466:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   12468:	2b1f      	cmp	r3, #31
   1246a:	d807      	bhi.n	1247c <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xd4>
      buf[len++] = 'x';
   1246c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   1246e:	1c5a      	adds	r2, r3, #1
   12470:	637a      	str	r2, [r7, #52]	; 0x34
   12472:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   12474:	4413      	add	r3, r2
   12476:	2278      	movs	r2, #120	; 0x78
   12478:	701a      	strb	r2, [r3, #0]
   1247a:	e01f      	b.n	124bc <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x114>
    }
    else if ((base == 16U) && (flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   1247c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   1247e:	2b10      	cmp	r3, #16
   12480:	d10f      	bne.n	124a2 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xfa>
   12482:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   12484:	f003 0320 	and.w	r3, r3, #32
   12488:	2b00      	cmp	r3, #0
   1248a:	d00a      	beq.n	124a2 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xfa>
   1248c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   1248e:	2b1f      	cmp	r3, #31
   12490:	d807      	bhi.n	124a2 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xfa>
      buf[len++] = 'X';
   12492:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   12494:	1c5a      	adds	r2, r3, #1
   12496:	637a      	str	r2, [r7, #52]	; 0x34
   12498:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   1249a:	4413      	add	r3, r2
   1249c:	2258      	movs	r2, #88	; 0x58
   1249e:	701a      	strb	r2, [r3, #0]
   124a0:	e00c      	b.n	124bc <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x114>
    }
    else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   124a2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   124a4:	2b02      	cmp	r3, #2
   124a6:	d109      	bne.n	124bc <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x114>
   124a8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   124aa:	2b1f      	cmp	r3, #31
   124ac:	d806      	bhi.n	124bc <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x114>
      buf[len++] = 'b';
   124ae:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   124b0:	1c5a      	adds	r2, r3, #1
   124b2:	637a      	str	r2, [r7, #52]	; 0x34
   124b4:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   124b6:	4413      	add	r3, r2
   124b8:	2262      	movs	r2, #98	; 0x62
   124ba:	701a      	strb	r2, [r3, #0]
    }
    if (len < PRINTF_NTOA_BUFFER_SIZE) {
   124bc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   124be:	2b1f      	cmp	r3, #31
   124c0:	d806      	bhi.n	124d0 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x128>
      buf[len++] = '0';
   124c2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   124c4:	1c5a      	adds	r2, r3, #1
   124c6:	637a      	str	r2, [r7, #52]	; 0x34
   124c8:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   124ca:	4413      	add	r3, r2
   124cc:	2230      	movs	r2, #48	; 0x30
   124ce:	701a      	strb	r2, [r3, #0]
    }
  }

  // handle sign
  if (len && (len == width) && (negative || (flags & FLAGS_PLUS) || (flags & FLAGS_SPACE))) {
   124d0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   124d2:	2b00      	cmp	r3, #0
   124d4:	d014      	beq.n	12500 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x158>
   124d6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
   124d8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   124da:	429a      	cmp	r2, r3
   124dc:	d110      	bne.n	12500 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x158>
   124de:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
   124e2:	2b00      	cmp	r3, #0
   124e4:	d109      	bne.n	124fa <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x152>
   124e6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   124e8:	f003 0304 	and.w	r3, r3, #4
   124ec:	2b00      	cmp	r3, #0
   124ee:	d104      	bne.n	124fa <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x152>
   124f0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   124f2:	f003 0308 	and.w	r3, r3, #8
   124f6:	2b00      	cmp	r3, #0
   124f8:	d002      	beq.n	12500 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x158>
    len--;
   124fa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   124fc:	3b01      	subs	r3, #1
   124fe:	637b      	str	r3, [r7, #52]	; 0x34
  }
  if (len < PRINTF_NTOA_BUFFER_SIZE) {
   12500:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   12502:	2b1f      	cmp	r3, #31
   12504:	d824      	bhi.n	12550 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1a8>
    if (negative) {
   12506:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
   1250a:	2b00      	cmp	r3, #0
   1250c:	d007      	beq.n	1251e <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x176>
      buf[len++] = '-';
   1250e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   12510:	1c5a      	adds	r2, r3, #1
   12512:	637a      	str	r2, [r7, #52]	; 0x34
   12514:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   12516:	4413      	add	r3, r2
   12518:	222d      	movs	r2, #45	; 0x2d
   1251a:	701a      	strb	r2, [r3, #0]
   1251c:	e018      	b.n	12550 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1a8>
    }
    else if (flags & FLAGS_PLUS) {
   1251e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   12520:	f003 0304 	and.w	r3, r3, #4
   12524:	2b00      	cmp	r3, #0
   12526:	d007      	beq.n	12538 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x190>
      buf[len++] = '+';  // ignore the space if the '+' exists
   12528:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   1252a:	1c5a      	adds	r2, r3, #1
   1252c:	637a      	str	r2, [r7, #52]	; 0x34
   1252e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   12530:	4413      	add	r3, r2
   12532:	222b      	movs	r2, #43	; 0x2b
   12534:	701a      	strb	r2, [r3, #0]
   12536:	e00b      	b.n	12550 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1a8>
    }
    else if (flags & FLAGS_SPACE) {
   12538:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   1253a:	f003 0308 	and.w	r3, r3, #8
   1253e:	2b00      	cmp	r3, #0
   12540:	d006      	beq.n	12550 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1a8>
      buf[len++] = ' ';
   12542:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   12544:	1c5a      	adds	r2, r3, #1
   12546:	637a      	str	r2, [r7, #52]	; 0x34
   12548:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   1254a:	4413      	add	r3, r2
   1254c:	2220      	movs	r2, #32
   1254e:	701a      	strb	r2, [r3, #0]
    }
  }

  // pad spaces up to given width
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
   12550:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   12552:	f003 0302 	and.w	r3, r3, #2
   12556:	2b00      	cmp	r3, #0
   12558:	d116      	bne.n	12588 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1e0>
   1255a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   1255c:	f003 0301 	and.w	r3, r3, #1
   12560:	2b00      	cmp	r3, #0
   12562:	d111      	bne.n	12588 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1e0>
    for (size_t i = len; i < width; i++) {
   12564:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   12566:	61fb      	str	r3, [r7, #28]
   12568:	69fa      	ldr	r2, [r7, #28]
   1256a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   1256c:	429a      	cmp	r2, r3
   1256e:	d20b      	bcs.n	12588 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1e0>
      out(' ', buffer, idx++, maxlen);
   12570:	687a      	ldr	r2, [r7, #4]
   12572:	1c53      	adds	r3, r2, #1
   12574:	607b      	str	r3, [r7, #4]
   12576:	68fc      	ldr	r4, [r7, #12]
   12578:	683b      	ldr	r3, [r7, #0]
   1257a:	68b9      	ldr	r1, [r7, #8]
   1257c:	2020      	movs	r0, #32
   1257e:	47a0      	blx	r4
    for (size_t i = len; i < width; i++) {
   12580:	69fb      	ldr	r3, [r7, #28]
   12582:	3301      	adds	r3, #1
   12584:	61fb      	str	r3, [r7, #28]
   12586:	e7ef      	b.n	12568 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1c0>
    }
  }

  // reverse string
  for (size_t i = 0U; i < len; i++) {
   12588:	2300      	movs	r3, #0
   1258a:	61bb      	str	r3, [r7, #24]
   1258c:	69ba      	ldr	r2, [r7, #24]
   1258e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   12590:	429a      	cmp	r2, r3
   12592:	d211      	bcs.n	125b8 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x210>
    out(buf[len - i - 1U], buffer, idx++, maxlen);
   12594:	6b7a      	ldr	r2, [r7, #52]	; 0x34
   12596:	69bb      	ldr	r3, [r7, #24]
   12598:	1ad3      	subs	r3, r2, r3
   1259a:	3b01      	subs	r3, #1
   1259c:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   1259e:	4413      	add	r3, r2
   125a0:	7818      	ldrb	r0, [r3, #0]
   125a2:	687a      	ldr	r2, [r7, #4]
   125a4:	1c53      	adds	r3, r2, #1
   125a6:	607b      	str	r3, [r7, #4]
   125a8:	68fc      	ldr	r4, [r7, #12]
   125aa:	683b      	ldr	r3, [r7, #0]
   125ac:	68b9      	ldr	r1, [r7, #8]
   125ae:	47a0      	blx	r4
  for (size_t i = 0U; i < len; i++) {
   125b0:	69bb      	ldr	r3, [r7, #24]
   125b2:	3301      	adds	r3, #1
   125b4:	61bb      	str	r3, [r7, #24]
   125b6:	e7e9      	b.n	1258c <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1e4>
  }

  // append pad spaces up to given width
  if (flags & FLAGS_LEFT) {
   125b8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   125ba:	f003 0302 	and.w	r3, r3, #2
   125be:	2b00      	cmp	r3, #0
   125c0:	d00e      	beq.n	125e0 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x238>
    while (idx - start_idx < width) {
   125c2:	687a      	ldr	r2, [r7, #4]
   125c4:	697b      	ldr	r3, [r7, #20]
   125c6:	1ad3      	subs	r3, r2, r3
   125c8:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   125ca:	429a      	cmp	r2, r3
   125cc:	d908      	bls.n	125e0 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x238>
      out(' ', buffer, idx++, maxlen);
   125ce:	687a      	ldr	r2, [r7, #4]
   125d0:	1c53      	adds	r3, r2, #1
   125d2:	607b      	str	r3, [r7, #4]
   125d4:	68fc      	ldr	r4, [r7, #12]
   125d6:	683b      	ldr	r3, [r7, #0]
   125d8:	68b9      	ldr	r1, [r7, #8]
   125da:	2020      	movs	r0, #32
   125dc:	47a0      	blx	r4
    while (idx - start_idx < width) {
   125de:	e7f0      	b.n	125c2 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x21a>
    }
  }

  return idx;
   125e0:	687b      	ldr	r3, [r7, #4]
}
   125e2:	4618      	mov	r0, r3
   125e4:	3724      	adds	r7, #36	; 0x24
   125e6:	46bd      	mov	sp, r7
   125e8:	bd90      	pop	{r4, r7, pc}

000125ea <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)>:


// internal itoa for 'long' type
static size_t _ntoa_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long value, bool negative, unsigned long base, unsigned int prec, unsigned int width, unsigned int flags)
{
   125ea:	b580      	push	{r7, lr}
   125ec:	b096      	sub	sp, #88	; 0x58
   125ee:	af08      	add	r7, sp, #32
   125f0:	60f8      	str	r0, [r7, #12]
   125f2:	60b9      	str	r1, [r7, #8]
   125f4:	607a      	str	r2, [r7, #4]
   125f6:	603b      	str	r3, [r7, #0]
  char buf[PRINTF_NTOA_BUFFER_SIZE];
  size_t len = 0U;
   125f8:	2300      	movs	r3, #0
   125fa:	637b      	str	r3, [r7, #52]	; 0x34

  // no hash for 0 values
  if (!value) {
   125fc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   125fe:	2b00      	cmp	r3, #0
   12600:	d103      	bne.n	1260a <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x20>
    flags &= ~FLAGS_HASH;
   12602:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   12604:	f023 0310 	bic.w	r3, r3, #16
   12608:	657b      	str	r3, [r7, #84]	; 0x54
  }

  // write if precision != 0 and value is != 0
  if (!(flags & FLAGS_PRECISION) || value) {
   1260a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   1260c:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   12610:	2b00      	cmp	r3, #0
   12612:	d002      	beq.n	1261a <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x30>
   12614:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   12616:	2b00      	cmp	r3, #0
   12618:	d034      	beq.n	12684 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x9a>
    do {
      const char digit = (char)(value % base);
   1261a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   1261c:	6cba      	ldr	r2, [r7, #72]	; 0x48
   1261e:	fbb3 f2f2 	udiv	r2, r3, r2
   12622:	6cb9      	ldr	r1, [r7, #72]	; 0x48
   12624:	fb01 f202 	mul.w	r2, r1, r2
   12628:	1a9b      	subs	r3, r3, r2
   1262a:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
   1262e:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
   12632:	2b09      	cmp	r3, #9
   12634:	d804      	bhi.n	12640 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x56>
   12636:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
   1263a:	3330      	adds	r3, #48	; 0x30
   1263c:	b2da      	uxtb	r2, r3
   1263e:	e00d      	b.n	1265c <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x72>
   12640:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   12642:	f003 0320 	and.w	r3, r3, #32
   12646:	2b00      	cmp	r3, #0
   12648:	d001      	beq.n	1264e <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x64>
   1264a:	2241      	movs	r2, #65	; 0x41
   1264c:	e000      	b.n	12650 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x66>
   1264e:	2261      	movs	r2, #97	; 0x61
   12650:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
   12654:	4413      	add	r3, r2
   12656:	b2db      	uxtb	r3, r3
   12658:	3b0a      	subs	r3, #10
   1265a:	b2da      	uxtb	r2, r3
   1265c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   1265e:	1c59      	adds	r1, r3, #1
   12660:	6379      	str	r1, [r7, #52]	; 0x34
   12662:	f107 0138 	add.w	r1, r7, #56	; 0x38
   12666:	440b      	add	r3, r1
   12668:	f803 2c28 	strb.w	r2, [r3, #-40]
      value /= base;
   1266c:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   1266e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   12670:	fbb2 f3f3 	udiv	r3, r2, r3
   12674:	643b      	str	r3, [r7, #64]	; 0x40
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
   12676:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   12678:	2b00      	cmp	r3, #0
   1267a:	d003      	beq.n	12684 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x9a>
   1267c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   1267e:	2b1f      	cmp	r3, #31
   12680:	d800      	bhi.n	12684 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x9a>
    do {
   12682:	e7ca      	b.n	1261a <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x30>
  }

  return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
   12684:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   12686:	9306      	str	r3, [sp, #24]
   12688:	6d3b      	ldr	r3, [r7, #80]	; 0x50
   1268a:	9305      	str	r3, [sp, #20]
   1268c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   1268e:	9304      	str	r3, [sp, #16]
   12690:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   12692:	9303      	str	r3, [sp, #12]
   12694:	f897 3044 	ldrb.w	r3, [r7, #68]	; 0x44
   12698:	9302      	str	r3, [sp, #8]
   1269a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   1269c:	9301      	str	r3, [sp, #4]
   1269e:	f107 0310 	add.w	r3, r7, #16
   126a2:	9300      	str	r3, [sp, #0]
   126a4:	683b      	ldr	r3, [r7, #0]
   126a6:	687a      	ldr	r2, [r7, #4]
   126a8:	68b9      	ldr	r1, [r7, #8]
   126aa:	68f8      	ldr	r0, [r7, #12]
   126ac:	f7ff fe7c 	bl	123a8 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)>
   126b0:	4603      	mov	r3, r0
}
   126b2:	4618      	mov	r0, r3
   126b4:	3738      	adds	r7, #56	; 0x38
   126b6:	46bd      	mov	sp, r7
   126b8:	bd80      	pop	{r7, pc}

000126ba <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)>:


// internal itoa for 'long long' type
#if defined(PRINTF_SUPPORT_LONG_LONG)
static size_t _ntoa_long_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long long value, bool negative, unsigned long long base, unsigned int prec, unsigned int width, unsigned int flags)
{
   126ba:	b590      	push	{r4, r7, lr}
   126bc:	b097      	sub	sp, #92	; 0x5c
   126be:	af08      	add	r7, sp, #32
   126c0:	60f8      	str	r0, [r7, #12]
   126c2:	60b9      	str	r1, [r7, #8]
   126c4:	607a      	str	r2, [r7, #4]
   126c6:	603b      	str	r3, [r7, #0]
  char buf[PRINTF_NTOA_BUFFER_SIZE];
  size_t len = 0U;
   126c8:	2300      	movs	r3, #0
   126ca:	637b      	str	r3, [r7, #52]	; 0x34

  // no hash for 0 values
  if (!value) {
   126cc:	e9d7 3412 	ldrd	r3, r4, [r7, #72]	; 0x48
   126d0:	4323      	orrs	r3, r4
   126d2:	d103      	bne.n	126dc <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x22>
    flags &= ~FLAGS_HASH;
   126d4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   126d6:	f023 0310 	bic.w	r3, r3, #16
   126da:	66bb      	str	r3, [r7, #104]	; 0x68
  }

  // write if precision != 0 and value is != 0
  if (!(flags & FLAGS_PRECISION) || value) {
   126dc:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   126de:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   126e2:	2b00      	cmp	r3, #0
   126e4:	d003      	beq.n	126ee <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x34>
   126e6:	e9d7 3412 	ldrd	r3, r4, [r7, #72]	; 0x48
   126ea:	4323      	orrs	r3, r4
   126ec:	d03a      	beq.n	12764 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0xaa>
    do {
      const char digit = (char)(value % base);
   126ee:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	; 0x48
   126f2:	e9d7 2316 	ldrd	r2, r3, [r7, #88]	; 0x58
   126f6:	f000 ff5f 	bl	135b8 <__aeabi_uldivmod>
   126fa:	461c      	mov	r4, r3
   126fc:	4613      	mov	r3, r2
   126fe:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
   12702:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
   12706:	2b09      	cmp	r3, #9
   12708:	d804      	bhi.n	12714 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x5a>
   1270a:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
   1270e:	3330      	adds	r3, #48	; 0x30
   12710:	b2da      	uxtb	r2, r3
   12712:	e00d      	b.n	12730 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x76>
   12714:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   12716:	f003 0320 	and.w	r3, r3, #32
   1271a:	2b00      	cmp	r3, #0
   1271c:	d001      	beq.n	12722 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x68>
   1271e:	2241      	movs	r2, #65	; 0x41
   12720:	e000      	b.n	12724 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x6a>
   12722:	2261      	movs	r2, #97	; 0x61
   12724:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
   12728:	4413      	add	r3, r2
   1272a:	b2db      	uxtb	r3, r3
   1272c:	3b0a      	subs	r3, #10
   1272e:	b2da      	uxtb	r2, r3
   12730:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   12732:	1c59      	adds	r1, r3, #1
   12734:	6379      	str	r1, [r7, #52]	; 0x34
   12736:	f107 0138 	add.w	r1, r7, #56	; 0x38
   1273a:	440b      	add	r3, r1
   1273c:	f803 2c28 	strb.w	r2, [r3, #-40]
      value /= base;
   12740:	e9d7 2316 	ldrd	r2, r3, [r7, #88]	; 0x58
   12744:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	; 0x48
   12748:	f000 ff36 	bl	135b8 <__aeabi_uldivmod>
   1274c:	4603      	mov	r3, r0
   1274e:	460c      	mov	r4, r1
   12750:	e9c7 3412 	strd	r3, r4, [r7, #72]	; 0x48
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
   12754:	e9d7 3412 	ldrd	r3, r4, [r7, #72]	; 0x48
   12758:	4323      	orrs	r3, r4
   1275a:	d003      	beq.n	12764 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0xaa>
   1275c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   1275e:	2b1f      	cmp	r3, #31
   12760:	d800      	bhi.n	12764 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0xaa>
    do {
   12762:	e7c4      	b.n	126ee <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x34>
  }

  return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
   12764:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   12766:	6eba      	ldr	r2, [r7, #104]	; 0x68
   12768:	9206      	str	r2, [sp, #24]
   1276a:	6e7a      	ldr	r2, [r7, #100]	; 0x64
   1276c:	9205      	str	r2, [sp, #20]
   1276e:	6e3a      	ldr	r2, [r7, #96]	; 0x60
   12770:	9204      	str	r2, [sp, #16]
   12772:	9303      	str	r3, [sp, #12]
   12774:	f897 3050 	ldrb.w	r3, [r7, #80]	; 0x50
   12778:	9302      	str	r3, [sp, #8]
   1277a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   1277c:	9301      	str	r3, [sp, #4]
   1277e:	f107 0310 	add.w	r3, r7, #16
   12782:	9300      	str	r3, [sp, #0]
   12784:	683b      	ldr	r3, [r7, #0]
   12786:	687a      	ldr	r2, [r7, #4]
   12788:	68b9      	ldr	r1, [r7, #8]
   1278a:	68f8      	ldr	r0, [r7, #12]
   1278c:	f7ff fe0c 	bl	123a8 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)>
   12790:	4603      	mov	r3, r0
}
   12792:	4618      	mov	r0, r3
   12794:	373c      	adds	r7, #60	; 0x3c
   12796:	46bd      	mov	sp, r7
   12798:	bd90      	pop	{r4, r7, pc}
   1279a:	Address 0x000000000001279a is out of bounds.


0001279c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)>:
#endif  // PRINTF_SUPPORT_LONG_LONG


#if defined(PRINTF_SUPPORT_FLOAT)
static size_t _ftoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value_param, unsigned int prec, unsigned int width, unsigned int flags)
{
   1279c:	b590      	push	{r4, r7, lr}
   1279e:	b09b      	sub	sp, #108	; 0x6c
   127a0:	af00      	add	r7, sp, #0
   127a2:	6178      	str	r0, [r7, #20]
   127a4:	6139      	str	r1, [r7, #16]
   127a6:	60fa      	str	r2, [r7, #12]
   127a8:	60bb      	str	r3, [r7, #8]
   127aa:	ed87 0b00 	vstr	d0, [r7]
  const size_t start_idx = idx;
   127ae:	68fb      	ldr	r3, [r7, #12]
   127b0:	647b      	str	r3, [r7, #68]	; 0x44

  float value = static_cast<float>(value_param);
   127b2:	e9d7 0100 	ldrd	r0, r1, [r7]
   127b6:	f000 feaf 	bl	13518 <__aeabi_d2f>
   127ba:	4603      	mov	r3, r0
   127bc:	667b      	str	r3, [r7, #100]	; 0x64

  char buf[PRINTF_FTOA_BUFFER_SIZE];
  size_t len  = 0U;
   127be:	2300      	movs	r3, #0
   127c0:	663b      	str	r3, [r7, #96]	; 0x60
  float diff = 0.0;
   127c2:	f04f 0300 	mov.w	r3, #0
   127c6:	643b      	str	r3, [r7, #64]	; 0x40

  // if input is larger than thres_max, revert to exponential
  const float thres_max = (float)0x7FFFFFFF;
   127c8:	f04f 439e 	mov.w	r3, #1325400064	; 0x4f000000
   127cc:	63fb      	str	r3, [r7, #60]	; 0x3c

  // powers of 10
  static const float pow10[] = { 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000 };

  // test for negative
  bool negative = false;
   127ce:	2300      	movs	r3, #0
   127d0:	f887 305f 	strb.w	r3, [r7, #95]	; 0x5f
  if (value < 0) {
   127d4:	edd7 7a19 	vldr	s15, [r7, #100]	; 0x64
   127d8:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   127dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   127e0:	d50a      	bpl.n	127f8 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x5c>
    negative = true;
   127e2:	2301      	movs	r3, #1
   127e4:	f887 305f 	strb.w	r3, [r7, #95]	; 0x5f
    value = 0 - value;
   127e8:	ed9f 7aab 	vldr	s14, [pc, #684]	; 12a98 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x2fc>
   127ec:	edd7 7a19 	vldr	s15, [r7, #100]	; 0x64
   127f0:	ee77 7a67 	vsub.f32	s15, s14, s15
   127f4:	edc7 7a19 	vstr	s15, [r7, #100]	; 0x64
  }

  // set default precision to 6, if not set explicitly
  if (!(flags & FLAGS_PRECISION)) {
   127f8:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
   127fc:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   12800:	2b00      	cmp	r3, #0
   12802:	d101      	bne.n	12808 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x6c>
    prec = 6U;
   12804:	2306      	movs	r3, #6
   12806:	67bb      	str	r3, [r7, #120]	; 0x78
  }
  // limit precision to 9, cause a prec >= 10 can lead to overflow errors
  while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
   12808:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   1280a:	2b1f      	cmp	r3, #31
   1280c:	d80f      	bhi.n	1282e <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x92>
   1280e:	6fbb      	ldr	r3, [r7, #120]	; 0x78
   12810:	2b09      	cmp	r3, #9
   12812:	d90c      	bls.n	1282e <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x92>
    buf[len++] = '0';
   12814:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   12816:	1c5a      	adds	r2, r3, #1
   12818:	663a      	str	r2, [r7, #96]	; 0x60
   1281a:	f107 0268 	add.w	r2, r7, #104	; 0x68
   1281e:	4413      	add	r3, r2
   12820:	2230      	movs	r2, #48	; 0x30
   12822:	f803 2c50 	strb.w	r2, [r3, #-80]
    prec--;
   12826:	6fbb      	ldr	r3, [r7, #120]	; 0x78
   12828:	3b01      	subs	r3, #1
   1282a:	67bb      	str	r3, [r7, #120]	; 0x78
  while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
   1282c:	e7ec      	b.n	12808 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x6c>
  }

  int whole = (int)value;
   1282e:	edd7 7a19 	vldr	s15, [r7, #100]	; 0x64
   12832:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   12836:	ee17 3a90 	vmov	r3, s15
   1283a:	65bb      	str	r3, [r7, #88]	; 0x58
  float tmp = (value - whole) * pow10[prec];
   1283c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   1283e:	ee07 3a90 	vmov	s15, r3
   12842:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   12846:	ed97 7a19 	vldr	s14, [r7, #100]	; 0x64
   1284a:	ee37 7a67 	vsub.f32	s14, s14, s15
   1284e:	4a93      	ldr	r2, [pc, #588]	; (12a9c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x300>)
   12850:	6fbb      	ldr	r3, [r7, #120]	; 0x78
   12852:	009b      	lsls	r3, r3, #2
   12854:	4413      	add	r3, r2
   12856:	edd3 7a00 	vldr	s15, [r3]
   1285a:	ee67 7a27 	vmul.f32	s15, s14, s15
   1285e:	edc7 7a0e 	vstr	s15, [r7, #56]	; 0x38
  unsigned long frac = (unsigned long)tmp;
   12862:	edd7 7a0e 	vldr	s15, [r7, #56]	; 0x38
   12866:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   1286a:	ee17 3a90 	vmov	r3, s15
   1286e:	657b      	str	r3, [r7, #84]	; 0x54
  diff = tmp - frac;
   12870:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   12872:	ee07 3a90 	vmov	s15, r3
   12876:	eef8 7a67 	vcvt.f32.u32	s15, s15
   1287a:	ed97 7a0e 	vldr	s14, [r7, #56]	; 0x38
   1287e:	ee77 7a67 	vsub.f32	s15, s14, s15
   12882:	edc7 7a10 	vstr	s15, [r7, #64]	; 0x40

  if (diff > 0.5) {
   12886:	edd7 7a10 	vldr	s15, [r7, #64]	; 0x40
   1288a:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
   1288e:	eef4 7ac7 	vcmpe.f32	s15, s14
   12892:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   12896:	dd18      	ble.n	128ca <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x12e>
    ++frac;
   12898:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   1289a:	3301      	adds	r3, #1
   1289c:	657b      	str	r3, [r7, #84]	; 0x54
    // handle rollover, e.g. case 0.99 with prec 1 is 1.0
    if (frac >= pow10[prec]) {
   1289e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   128a0:	ee07 3a90 	vmov	s15, r3
   128a4:	eeb8 7a67 	vcvt.f32.u32	s14, s15
   128a8:	4a7c      	ldr	r2, [pc, #496]	; (12a9c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x300>)
   128aa:	6fbb      	ldr	r3, [r7, #120]	; 0x78
   128ac:	009b      	lsls	r3, r3, #2
   128ae:	4413      	add	r3, r2
   128b0:	edd3 7a00 	vldr	s15, [r3]
   128b4:	eeb4 7ae7 	vcmpe.f32	s14, s15
   128b8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   128bc:	db19      	blt.n	128f2 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x156>
      frac = 0;
   128be:	2300      	movs	r3, #0
   128c0:	657b      	str	r3, [r7, #84]	; 0x54
      ++whole;
   128c2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   128c4:	3301      	adds	r3, #1
   128c6:	65bb      	str	r3, [r7, #88]	; 0x58
   128c8:	e013      	b.n	128f2 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x156>
    }
  }
  else if ((diff == 0.5) && ((frac == 0U) || (frac & 1U))) {
   128ca:	edd7 7a10 	vldr	s15, [r7, #64]	; 0x40
   128ce:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
   128d2:	eef4 7a47 	vcmp.f32	s15, s14
   128d6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   128da:	d10a      	bne.n	128f2 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x156>
   128dc:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   128de:	2b00      	cmp	r3, #0
   128e0:	d004      	beq.n	128ec <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x150>
   128e2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   128e4:	f003 0301 	and.w	r3, r3, #1
   128e8:	2b00      	cmp	r3, #0
   128ea:	d002      	beq.n	128f2 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x156>
    // if halfway, round up if odd, OR if last digit is 0
    ++frac;
   128ec:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   128ee:	3301      	adds	r3, #1
   128f0:	657b      	str	r3, [r7, #84]	; 0x54
  }

  // TBD: for very large numbers switch back to native sprintf for exponentials. Anyone want to write code to replace this?
  // Normal printf behavior is to print EVERY whole number digit which can be 100s of characters overflowing your buffers == bad
  if (value > thres_max) {
   128f2:	edd7 7a19 	vldr	s15, [r7, #100]	; 0x64
   128f6:	ed9f 7a6a 	vldr	s14, [pc, #424]	; 12aa0 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x304>
   128fa:	eef4 7ac7 	vcmpe.f32	s15, s14
   128fe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   12902:	dd01      	ble.n	12908 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x16c>
    return 0U;
   12904:	2300      	movs	r3, #0
   12906:	e166      	b.n	12bd6 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x43a>
  }

  if (prec == 0U) {
   12908:	6fbb      	ldr	r3, [r7, #120]	; 0x78
   1290a:	2b00      	cmp	r3, #0
   1290c:	d129      	bne.n	12962 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x1c6>
    diff = value - (float)whole;
   1290e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   12910:	ee07 3a90 	vmov	s15, r3
   12914:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   12918:	ed97 7a19 	vldr	s14, [r7, #100]	; 0x64
   1291c:	ee77 7a67 	vsub.f32	s15, s14, s15
   12920:	edc7 7a10 	vstr	s15, [r7, #64]	; 0x40
    if (diff > 0.5) {
   12924:	edd7 7a10 	vldr	s15, [r7, #64]	; 0x40
   12928:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
   1292c:	eef4 7ac7 	vcmpe.f32	s15, s14
   12930:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   12934:	dd03      	ble.n	1293e <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x1a2>
      // greater than 0.5, round up, e.g. 1.6 -> 2
      ++whole;
   12936:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   12938:	3301      	adds	r3, #1
   1293a:	65bb      	str	r3, [r7, #88]	; 0x58
   1293c:	e062      	b.n	12a04 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x268>
    }
    else if ((diff == 0.5) && (whole & 1)) {
   1293e:	edd7 7a10 	vldr	s15, [r7, #64]	; 0x40
   12942:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
   12946:	eef4 7a47 	vcmp.f32	s15, s14
   1294a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1294e:	d159      	bne.n	12a04 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x268>
   12950:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   12952:	f003 0301 	and.w	r3, r3, #1
   12956:	2b00      	cmp	r3, #0
   12958:	d054      	beq.n	12a04 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x268>
      // exactly 0.5 and ODD, then round up
      // 1.5 -> 2, but 2.5 -> 2
      ++whole;
   1295a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   1295c:	3301      	adds	r3, #1
   1295e:	65bb      	str	r3, [r7, #88]	; 0x58
   12960:	e050      	b.n	12a04 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x268>
    }
  }
  else {
    unsigned int count = prec;
   12962:	6fbb      	ldr	r3, [r7, #120]	; 0x78
   12964:	653b      	str	r3, [r7, #80]	; 0x50
    // now do fractional part, as an unsigned number
    while (len < PRINTF_FTOA_BUFFER_SIZE) {
   12966:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   12968:	2b1f      	cmp	r3, #31
   1296a:	d828      	bhi.n	129be <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x222>
      --count;
   1296c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
   1296e:	3b01      	subs	r3, #1
   12970:	653b      	str	r3, [r7, #80]	; 0x50
      buf[len++] = (char)(48U + (frac % 10U));
   12972:	6d79      	ldr	r1, [r7, #84]	; 0x54
   12974:	4b4b      	ldr	r3, [pc, #300]	; (12aa4 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x308>)
   12976:	fba3 2301 	umull	r2, r3, r3, r1
   1297a:	08da      	lsrs	r2, r3, #3
   1297c:	4613      	mov	r3, r2
   1297e:	009b      	lsls	r3, r3, #2
   12980:	4413      	add	r3, r2
   12982:	005b      	lsls	r3, r3, #1
   12984:	1aca      	subs	r2, r1, r3
   12986:	b2d3      	uxtb	r3, r2
   12988:	3330      	adds	r3, #48	; 0x30
   1298a:	b2d9      	uxtb	r1, r3
   1298c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   1298e:	1c5a      	adds	r2, r3, #1
   12990:	663a      	str	r2, [r7, #96]	; 0x60
   12992:	f107 0268 	add.w	r2, r7, #104	; 0x68
   12996:	4413      	add	r3, r2
   12998:	460a      	mov	r2, r1
   1299a:	f803 2c50 	strb.w	r2, [r3, #-80]
      if (!(frac /= 10U)) {
   1299e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   129a0:	4a40      	ldr	r2, [pc, #256]	; (12aa4 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x308>)
   129a2:	fba2 2303 	umull	r2, r3, r2, r3
   129a6:	08db      	lsrs	r3, r3, #3
   129a8:	657b      	str	r3, [r7, #84]	; 0x54
   129aa:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   129ac:	2b00      	cmp	r3, #0
   129ae:	bf0c      	ite	eq
   129b0:	2301      	moveq	r3, #1
   129b2:	2300      	movne	r3, #0
   129b4:	b2db      	uxtb	r3, r3
   129b6:	2b00      	cmp	r3, #0
   129b8:	d100      	bne.n	129bc <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x220>
    while (len < PRINTF_FTOA_BUFFER_SIZE) {
   129ba:	e7d4      	b.n	12966 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x1ca>
        break;
   129bc:	bf00      	nop
      }
    }
    // add extra 0s
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
   129be:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   129c0:	2b1f      	cmp	r3, #31
   129c2:	d806      	bhi.n	129d2 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x236>
   129c4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
   129c6:	1e5a      	subs	r2, r3, #1
   129c8:	653a      	str	r2, [r7, #80]	; 0x50
   129ca:	2b00      	cmp	r3, #0
   129cc:	d001      	beq.n	129d2 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x236>
   129ce:	2301      	movs	r3, #1
   129d0:	e000      	b.n	129d4 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x238>
   129d2:	2300      	movs	r3, #0
   129d4:	2b00      	cmp	r3, #0
   129d6:	d009      	beq.n	129ec <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x250>
      buf[len++] = '0';
   129d8:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   129da:	1c5a      	adds	r2, r3, #1
   129dc:	663a      	str	r2, [r7, #96]	; 0x60
   129de:	f107 0268 	add.w	r2, r7, #104	; 0x68
   129e2:	4413      	add	r3, r2
   129e4:	2230      	movs	r2, #48	; 0x30
   129e6:	f803 2c50 	strb.w	r2, [r3, #-80]
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
   129ea:	e7e8      	b.n	129be <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x222>
    }
    if (len < PRINTF_FTOA_BUFFER_SIZE) {
   129ec:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   129ee:	2b1f      	cmp	r3, #31
   129f0:	d808      	bhi.n	12a04 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x268>
      // add decimal
      buf[len++] = '.';
   129f2:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   129f4:	1c5a      	adds	r2, r3, #1
   129f6:	663a      	str	r2, [r7, #96]	; 0x60
   129f8:	f107 0268 	add.w	r2, r7, #104	; 0x68
   129fc:	4413      	add	r3, r2
   129fe:	222e      	movs	r2, #46	; 0x2e
   12a00:	f803 2c50 	strb.w	r2, [r3, #-80]
    }
  }

  // do whole part, number is reversed
  while (len < PRINTF_FTOA_BUFFER_SIZE) {
   12a04:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   12a06:	2b1f      	cmp	r3, #31
   12a08:	d829      	bhi.n	12a5e <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x2c2>
    buf[len++] = (char)(48 + (whole % 10));
   12a0a:	6dba      	ldr	r2, [r7, #88]	; 0x58
   12a0c:	4b26      	ldr	r3, [pc, #152]	; (12aa8 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x30c>)
   12a0e:	fb83 1302 	smull	r1, r3, r3, r2
   12a12:	1099      	asrs	r1, r3, #2
   12a14:	17d3      	asrs	r3, r2, #31
   12a16:	1ac9      	subs	r1, r1, r3
   12a18:	460b      	mov	r3, r1
   12a1a:	009b      	lsls	r3, r3, #2
   12a1c:	440b      	add	r3, r1
   12a1e:	005b      	lsls	r3, r3, #1
   12a20:	1ad1      	subs	r1, r2, r3
   12a22:	b2cb      	uxtb	r3, r1
   12a24:	3330      	adds	r3, #48	; 0x30
   12a26:	b2d9      	uxtb	r1, r3
   12a28:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   12a2a:	1c5a      	adds	r2, r3, #1
   12a2c:	663a      	str	r2, [r7, #96]	; 0x60
   12a2e:	f107 0268 	add.w	r2, r7, #104	; 0x68
   12a32:	4413      	add	r3, r2
   12a34:	460a      	mov	r2, r1
   12a36:	f803 2c50 	strb.w	r2, [r3, #-80]
    if (!(whole /= 10)) {
   12a3a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   12a3c:	4a1a      	ldr	r2, [pc, #104]	; (12aa8 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x30c>)
   12a3e:	fb82 1203 	smull	r1, r2, r2, r3
   12a42:	1092      	asrs	r2, r2, #2
   12a44:	17db      	asrs	r3, r3, #31
   12a46:	1ad3      	subs	r3, r2, r3
   12a48:	65bb      	str	r3, [r7, #88]	; 0x58
   12a4a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   12a4c:	2b00      	cmp	r3, #0
   12a4e:	bf0c      	ite	eq
   12a50:	2301      	moveq	r3, #1
   12a52:	2300      	movne	r3, #0
   12a54:	b2db      	uxtb	r3, r3
   12a56:	2b00      	cmp	r3, #0
   12a58:	d100      	bne.n	12a5c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x2c0>
  while (len < PRINTF_FTOA_BUFFER_SIZE) {
   12a5a:	e7d3      	b.n	12a04 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x268>
      break;
   12a5c:	bf00      	nop
    }
  }

  // pad leading zeros
  while (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
   12a5e:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
   12a62:	f003 0302 	and.w	r3, r3, #2
   12a66:	2b00      	cmp	r3, #0
   12a68:	d120      	bne.n	12aac <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x310>
   12a6a:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
   12a6e:	f003 0301 	and.w	r3, r3, #1
   12a72:	2b00      	cmp	r3, #0
   12a74:	d01a      	beq.n	12aac <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x310>
   12a76:	6e3a      	ldr	r2, [r7, #96]	; 0x60
   12a78:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
   12a7a:	429a      	cmp	r2, r3
   12a7c:	d216      	bcs.n	12aac <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x310>
   12a7e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   12a80:	2b1f      	cmp	r3, #31
   12a82:	d813      	bhi.n	12aac <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x310>
    buf[len++] = '0';
   12a84:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   12a86:	1c5a      	adds	r2, r3, #1
   12a88:	663a      	str	r2, [r7, #96]	; 0x60
   12a8a:	f107 0268 	add.w	r2, r7, #104	; 0x68
   12a8e:	4413      	add	r3, r2
   12a90:	2230      	movs	r2, #48	; 0x30
   12a92:	f803 2c50 	strb.w	r2, [r3, #-80]
  while (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
   12a96:	e7e2      	b.n	12a5e <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x2c2>
   12a98:	00000000 	.word	0x00000000
   12a9c:	00015d24 	.word	0x00015d24
   12aa0:	4f000000 	.word	0x4f000000
   12aa4:	cccccccd 	.word	0xcccccccd
   12aa8:	66666667 	.word	0x66666667
  }

  // handle sign
  if ((len == width) && (negative || (flags & FLAGS_PLUS) || (flags & FLAGS_SPACE))) {
   12aac:	6e3a      	ldr	r2, [r7, #96]	; 0x60
   12aae:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
   12ab0:	429a      	cmp	r2, r3
   12ab2:	d112      	bne.n	12ada <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x33e>
   12ab4:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
   12ab8:	2b00      	cmp	r3, #0
   12aba:	d10b      	bne.n	12ad4 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x338>
   12abc:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
   12ac0:	f003 0304 	and.w	r3, r3, #4
   12ac4:	2b00      	cmp	r3, #0
   12ac6:	d105      	bne.n	12ad4 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x338>
   12ac8:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
   12acc:	f003 0308 	and.w	r3, r3, #8
   12ad0:	2b00      	cmp	r3, #0
   12ad2:	d002      	beq.n	12ada <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x33e>
    len--;
   12ad4:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   12ad6:	3b01      	subs	r3, #1
   12ad8:	663b      	str	r3, [r7, #96]	; 0x60
  }
  if (len < PRINTF_FTOA_BUFFER_SIZE) {
   12ada:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   12adc:	2b1f      	cmp	r3, #31
   12ade:	d82c      	bhi.n	12b3a <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x39e>
    if (negative) {
   12ae0:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
   12ae4:	2b00      	cmp	r3, #0
   12ae6:	d009      	beq.n	12afc <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x360>
      buf[len++] = '-';
   12ae8:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   12aea:	1c5a      	adds	r2, r3, #1
   12aec:	663a      	str	r2, [r7, #96]	; 0x60
   12aee:	f107 0268 	add.w	r2, r7, #104	; 0x68
   12af2:	4413      	add	r3, r2
   12af4:	222d      	movs	r2, #45	; 0x2d
   12af6:	f803 2c50 	strb.w	r2, [r3, #-80]
   12afa:	e01e      	b.n	12b3a <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x39e>
    }
    else if (flags & FLAGS_PLUS) {
   12afc:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
   12b00:	f003 0304 	and.w	r3, r3, #4
   12b04:	2b00      	cmp	r3, #0
   12b06:	d009      	beq.n	12b1c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x380>
      buf[len++] = '+';  // ignore the space if the '+' exists
   12b08:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   12b0a:	1c5a      	adds	r2, r3, #1
   12b0c:	663a      	str	r2, [r7, #96]	; 0x60
   12b0e:	f107 0268 	add.w	r2, r7, #104	; 0x68
   12b12:	4413      	add	r3, r2
   12b14:	222b      	movs	r2, #43	; 0x2b
   12b16:	f803 2c50 	strb.w	r2, [r3, #-80]
   12b1a:	e00e      	b.n	12b3a <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x39e>
    }
    else if (flags & FLAGS_SPACE) {
   12b1c:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
   12b20:	f003 0308 	and.w	r3, r3, #8
   12b24:	2b00      	cmp	r3, #0
   12b26:	d008      	beq.n	12b3a <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x39e>
      buf[len++] = ' ';
   12b28:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   12b2a:	1c5a      	adds	r2, r3, #1
   12b2c:	663a      	str	r2, [r7, #96]	; 0x60
   12b2e:	f107 0268 	add.w	r2, r7, #104	; 0x68
   12b32:	4413      	add	r3, r2
   12b34:	2220      	movs	r2, #32
   12b36:	f803 2c50 	strb.w	r2, [r3, #-80]
    }
  }

  // pad spaces up to given width
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
   12b3a:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
   12b3e:	f003 0302 	and.w	r3, r3, #2
   12b42:	2b00      	cmp	r3, #0
   12b44:	d117      	bne.n	12b76 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x3da>
   12b46:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
   12b4a:	f003 0301 	and.w	r3, r3, #1
   12b4e:	2b00      	cmp	r3, #0
   12b50:	d111      	bne.n	12b76 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x3da>
    for (size_t i = len; i < width; i++) {
   12b52:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   12b54:	64fb      	str	r3, [r7, #76]	; 0x4c
   12b56:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
   12b58:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
   12b5a:	429a      	cmp	r2, r3
   12b5c:	d20b      	bcs.n	12b76 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x3da>
      out(' ', buffer, idx++, maxlen);
   12b5e:	68fa      	ldr	r2, [r7, #12]
   12b60:	1c53      	adds	r3, r2, #1
   12b62:	60fb      	str	r3, [r7, #12]
   12b64:	697c      	ldr	r4, [r7, #20]
   12b66:	68bb      	ldr	r3, [r7, #8]
   12b68:	6939      	ldr	r1, [r7, #16]
   12b6a:	2020      	movs	r0, #32
   12b6c:	47a0      	blx	r4
    for (size_t i = len; i < width; i++) {
   12b6e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   12b70:	3301      	adds	r3, #1
   12b72:	64fb      	str	r3, [r7, #76]	; 0x4c
   12b74:	e7ef      	b.n	12b56 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x3ba>
    }
  }

  // reverse string
  for (size_t i = 0U; i < len; i++) {
   12b76:	2300      	movs	r3, #0
   12b78:	64bb      	str	r3, [r7, #72]	; 0x48
   12b7a:	6cba      	ldr	r2, [r7, #72]	; 0x48
   12b7c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   12b7e:	429a      	cmp	r2, r3
   12b80:	d213      	bcs.n	12baa <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x40e>
    out(buf[len - i - 1U], buffer, idx++, maxlen);
   12b82:	6e3a      	ldr	r2, [r7, #96]	; 0x60
   12b84:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   12b86:	1ad3      	subs	r3, r2, r3
   12b88:	3b01      	subs	r3, #1
   12b8a:	f107 0268 	add.w	r2, r7, #104	; 0x68
   12b8e:	4413      	add	r3, r2
   12b90:	f813 0c50 	ldrb.w	r0, [r3, #-80]
   12b94:	68fa      	ldr	r2, [r7, #12]
   12b96:	1c53      	adds	r3, r2, #1
   12b98:	60fb      	str	r3, [r7, #12]
   12b9a:	697c      	ldr	r4, [r7, #20]
   12b9c:	68bb      	ldr	r3, [r7, #8]
   12b9e:	6939      	ldr	r1, [r7, #16]
   12ba0:	47a0      	blx	r4
  for (size_t i = 0U; i < len; i++) {
   12ba2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   12ba4:	3301      	adds	r3, #1
   12ba6:	64bb      	str	r3, [r7, #72]	; 0x48
   12ba8:	e7e7      	b.n	12b7a <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x3de>
  }

  // append pad spaces up to given width
  if (flags & FLAGS_LEFT) {
   12baa:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
   12bae:	f003 0302 	and.w	r3, r3, #2
   12bb2:	2b00      	cmp	r3, #0
   12bb4:	d00e      	beq.n	12bd4 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x438>
    while (idx - start_idx < width) {
   12bb6:	68fa      	ldr	r2, [r7, #12]
   12bb8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   12bba:	1ad3      	subs	r3, r2, r3
   12bbc:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
   12bbe:	429a      	cmp	r2, r3
   12bc0:	d908      	bls.n	12bd4 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x438>
      out(' ', buffer, idx++, maxlen);
   12bc2:	68fa      	ldr	r2, [r7, #12]
   12bc4:	1c53      	adds	r3, r2, #1
   12bc6:	60fb      	str	r3, [r7, #12]
   12bc8:	697c      	ldr	r4, [r7, #20]
   12bca:	68bb      	ldr	r3, [r7, #8]
   12bcc:	6939      	ldr	r1, [r7, #16]
   12bce:	2020      	movs	r0, #32
   12bd0:	47a0      	blx	r4
    while (idx - start_idx < width) {
   12bd2:	e7f0      	b.n	12bb6 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x41a>
    }
  }

  return idx;
   12bd4:	68fb      	ldr	r3, [r7, #12]
}
   12bd6:	4618      	mov	r0, r3
   12bd8:	376c      	adds	r7, #108	; 0x6c
   12bda:	46bd      	mov	sp, r7
   12bdc:	bd90      	pop	{r4, r7, pc}
   12bde:	bf00      	nop

00012be0 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)>:
#endif  // PRINTF_SUPPORT_FLOAT


// internal vsnprintf
static int _vsnprintf(out_fct_type out, char* buffer, const size_t maxlen, const char* format, va_list va)
{
   12be0:	b5b0      	push	{r4, r5, r7, lr}
   12be2:	b0a0      	sub	sp, #128	; 0x80
   12be4:	af0a      	add	r7, sp, #40	; 0x28
   12be6:	60f8      	str	r0, [r7, #12]
   12be8:	60b9      	str	r1, [r7, #8]
   12bea:	607a      	str	r2, [r7, #4]
   12bec:	603b      	str	r3, [r7, #0]
  unsigned int flags, width, precision, n;
  size_t idx = 0U;
   12bee:	2300      	movs	r3, #0
   12bf0:	647b      	str	r3, [r7, #68]	; 0x44

  if (!buffer) {
   12bf2:	68bb      	ldr	r3, [r7, #8]
   12bf4:	2b00      	cmp	r3, #0
   12bf6:	d101      	bne.n	12bfc <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x1c>
    // use null output function
    out = _out_null;
   12bf8:	4ba2      	ldr	r3, [pc, #648]	; (12e84 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2a4>)
   12bfa:	60fb      	str	r3, [r7, #12]
  }

  while (*format)
   12bfc:	683b      	ldr	r3, [r7, #0]
   12bfe:	781b      	ldrb	r3, [r3, #0]
   12c00:	2b00      	cmp	r3, #0
   12c02:	f000 8445 	beq.w	13490 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8b0>
  {
    // format specifier?  %[flags][width][.precision][length]
    if (*format != '%') {
   12c06:	683b      	ldr	r3, [r7, #0]
   12c08:	781b      	ldrb	r3, [r3, #0]
   12c0a:	2b25      	cmp	r3, #37	; 0x25
   12c0c:	d00d      	beq.n	12c2a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x4a>
      // no
      out(*format, buffer, idx++, maxlen);
   12c0e:	683b      	ldr	r3, [r7, #0]
   12c10:	7818      	ldrb	r0, [r3, #0]
   12c12:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   12c14:	1c53      	adds	r3, r2, #1
   12c16:	647b      	str	r3, [r7, #68]	; 0x44
   12c18:	68fc      	ldr	r4, [r7, #12]
   12c1a:	687b      	ldr	r3, [r7, #4]
   12c1c:	68b9      	ldr	r1, [r7, #8]
   12c1e:	47a0      	blx	r4
      format++;
   12c20:	683b      	ldr	r3, [r7, #0]
   12c22:	3301      	adds	r3, #1
   12c24:	603b      	str	r3, [r7, #0]
      continue;
   12c26:	f000 bc31 	b.w	1348c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8ac>
    }
    else {
      // yes, evaluate it
      format++;
   12c2a:	683b      	ldr	r3, [r7, #0]
   12c2c:	3301      	adds	r3, #1
   12c2e:	603b      	str	r3, [r7, #0]
    }

    // evaluate flags
    flags = 0U;
   12c30:	2300      	movs	r3, #0
   12c32:	657b      	str	r3, [r7, #84]	; 0x54
    do {
      switch (*format) {
   12c34:	683b      	ldr	r3, [r7, #0]
   12c36:	781b      	ldrb	r3, [r3, #0]
   12c38:	3b20      	subs	r3, #32
   12c3a:	2b10      	cmp	r3, #16
   12c3c:	d856      	bhi.n	12cec <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x10c>
   12c3e:	a201      	add	r2, pc, #4	; (adr r2, 12c44 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x64>)
   12c40:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   12c44:	00012cc5 	.word	0x00012cc5
   12c48:	00012ced 	.word	0x00012ced
   12c4c:	00012ced 	.word	0x00012ced
   12c50:	00012cd9 	.word	0x00012cd9
   12c54:	00012ced 	.word	0x00012ced
   12c58:	00012ced 	.word	0x00012ced
   12c5c:	00012ced 	.word	0x00012ced
   12c60:	00012ced 	.word	0x00012ced
   12c64:	00012ced 	.word	0x00012ced
   12c68:	00012ced 	.word	0x00012ced
   12c6c:	00012ced 	.word	0x00012ced
   12c70:	00012cb1 	.word	0x00012cb1
   12c74:	00012ced 	.word	0x00012ced
   12c78:	00012c9d 	.word	0x00012c9d
   12c7c:	00012ced 	.word	0x00012ced
   12c80:	00012ced 	.word	0x00012ced
   12c84:	00012c89 	.word	0x00012c89
        case '0': flags |= FLAGS_ZEROPAD; format++; n = 1U; break;
   12c88:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   12c8a:	f043 0301 	orr.w	r3, r3, #1
   12c8e:	657b      	str	r3, [r7, #84]	; 0x54
   12c90:	683b      	ldr	r3, [r7, #0]
   12c92:	3301      	adds	r3, #1
   12c94:	603b      	str	r3, [r7, #0]
   12c96:	2301      	movs	r3, #1
   12c98:	64bb      	str	r3, [r7, #72]	; 0x48
   12c9a:	e02a      	b.n	12cf2 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x112>
        case '-': flags |= FLAGS_LEFT;    format++; n = 1U; break;
   12c9c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   12c9e:	f043 0302 	orr.w	r3, r3, #2
   12ca2:	657b      	str	r3, [r7, #84]	; 0x54
   12ca4:	683b      	ldr	r3, [r7, #0]
   12ca6:	3301      	adds	r3, #1
   12ca8:	603b      	str	r3, [r7, #0]
   12caa:	2301      	movs	r3, #1
   12cac:	64bb      	str	r3, [r7, #72]	; 0x48
   12cae:	e020      	b.n	12cf2 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x112>
        case '+': flags |= FLAGS_PLUS;    format++; n = 1U; break;
   12cb0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   12cb2:	f043 0304 	orr.w	r3, r3, #4
   12cb6:	657b      	str	r3, [r7, #84]	; 0x54
   12cb8:	683b      	ldr	r3, [r7, #0]
   12cba:	3301      	adds	r3, #1
   12cbc:	603b      	str	r3, [r7, #0]
   12cbe:	2301      	movs	r3, #1
   12cc0:	64bb      	str	r3, [r7, #72]	; 0x48
   12cc2:	e016      	b.n	12cf2 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x112>
        case ' ': flags |= FLAGS_SPACE;   format++; n = 1U; break;
   12cc4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   12cc6:	f043 0308 	orr.w	r3, r3, #8
   12cca:	657b      	str	r3, [r7, #84]	; 0x54
   12ccc:	683b      	ldr	r3, [r7, #0]
   12cce:	3301      	adds	r3, #1
   12cd0:	603b      	str	r3, [r7, #0]
   12cd2:	2301      	movs	r3, #1
   12cd4:	64bb      	str	r3, [r7, #72]	; 0x48
   12cd6:	e00c      	b.n	12cf2 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x112>
        case '#': flags |= FLAGS_HASH;    format++; n = 1U; break;
   12cd8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   12cda:	f043 0310 	orr.w	r3, r3, #16
   12cde:	657b      	str	r3, [r7, #84]	; 0x54
   12ce0:	683b      	ldr	r3, [r7, #0]
   12ce2:	3301      	adds	r3, #1
   12ce4:	603b      	str	r3, [r7, #0]
   12ce6:	2301      	movs	r3, #1
   12ce8:	64bb      	str	r3, [r7, #72]	; 0x48
   12cea:	e002      	b.n	12cf2 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x112>
        default :                                   n = 0U; break;
   12cec:	2300      	movs	r3, #0
   12cee:	64bb      	str	r3, [r7, #72]	; 0x48
   12cf0:	bf00      	nop
      }
    } while (n);
   12cf2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   12cf4:	2b00      	cmp	r3, #0
   12cf6:	d000      	beq.n	12cfa <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x11a>
    do {
   12cf8:	e79c      	b.n	12c34 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x54>

    // evaluate width field
    width = 0U;
   12cfa:	2300      	movs	r3, #0
   12cfc:	653b      	str	r3, [r7, #80]	; 0x50
    if (_is_digit(*format)) {
   12cfe:	683b      	ldr	r3, [r7, #0]
   12d00:	781b      	ldrb	r3, [r3, #0]
   12d02:	4618      	mov	r0, r3
   12d04:	f7ff fb18 	bl	12338 <_is_digit(char)>
   12d08:	4603      	mov	r3, r0
   12d0a:	2b00      	cmp	r3, #0
   12d0c:	d005      	beq.n	12d1a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x13a>
      width = _atoi(&format);
   12d0e:	463b      	mov	r3, r7
   12d10:	4618      	mov	r0, r3
   12d12:	f7ff fb25 	bl	12360 <_atoi(char const**)>
   12d16:	6538      	str	r0, [r7, #80]	; 0x50
   12d18:	e018      	b.n	12d4c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x16c>
    }
    else if (*format == '*') {
   12d1a:	683b      	ldr	r3, [r7, #0]
   12d1c:	781b      	ldrb	r3, [r3, #0]
   12d1e:	2b2a      	cmp	r3, #42	; 0x2a
   12d20:	d114      	bne.n	12d4c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x16c>
      const int w = va_arg(va, int);
   12d22:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   12d24:	1d1a      	adds	r2, r3, #4
   12d26:	66ba      	str	r2, [r7, #104]	; 0x68
   12d28:	681b      	ldr	r3, [r3, #0]
   12d2a:	633b      	str	r3, [r7, #48]	; 0x30
      if (w < 0) {
   12d2c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   12d2e:	2b00      	cmp	r3, #0
   12d30:	da07      	bge.n	12d42 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x162>
        flags |= FLAGS_LEFT;    // reverse padding
   12d32:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   12d34:	f043 0302 	orr.w	r3, r3, #2
   12d38:	657b      	str	r3, [r7, #84]	; 0x54
        width = (unsigned int)-w;
   12d3a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   12d3c:	425b      	negs	r3, r3
   12d3e:	653b      	str	r3, [r7, #80]	; 0x50
   12d40:	e001      	b.n	12d46 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x166>
      }
      else {
        width = (unsigned int)w;
   12d42:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   12d44:	653b      	str	r3, [r7, #80]	; 0x50
      }
      format++;
   12d46:	683b      	ldr	r3, [r7, #0]
   12d48:	3301      	adds	r3, #1
   12d4a:	603b      	str	r3, [r7, #0]
    }

    // evaluate precision field
    precision = 0U;
   12d4c:	2300      	movs	r3, #0
   12d4e:	64fb      	str	r3, [r7, #76]	; 0x4c
    if (*format == '.') {
   12d50:	683b      	ldr	r3, [r7, #0]
   12d52:	781b      	ldrb	r3, [r3, #0]
   12d54:	2b2e      	cmp	r3, #46	; 0x2e
   12d56:	d124      	bne.n	12da2 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x1c2>
      flags |= FLAGS_PRECISION;
   12d58:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   12d5a:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
   12d5e:	657b      	str	r3, [r7, #84]	; 0x54
      format++;
   12d60:	683b      	ldr	r3, [r7, #0]
   12d62:	3301      	adds	r3, #1
   12d64:	603b      	str	r3, [r7, #0]
      if (_is_digit(*format)) {
   12d66:	683b      	ldr	r3, [r7, #0]
   12d68:	781b      	ldrb	r3, [r3, #0]
   12d6a:	4618      	mov	r0, r3
   12d6c:	f7ff fae4 	bl	12338 <_is_digit(char)>
   12d70:	4603      	mov	r3, r0
   12d72:	2b00      	cmp	r3, #0
   12d74:	d005      	beq.n	12d82 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x1a2>
        precision = _atoi(&format);
   12d76:	463b      	mov	r3, r7
   12d78:	4618      	mov	r0, r3
   12d7a:	f7ff faf1 	bl	12360 <_atoi(char const**)>
   12d7e:	64f8      	str	r0, [r7, #76]	; 0x4c
   12d80:	e00f      	b.n	12da2 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x1c2>
      }
      else if (*format == '*') {
   12d82:	683b      	ldr	r3, [r7, #0]
   12d84:	781b      	ldrb	r3, [r3, #0]
   12d86:	2b2a      	cmp	r3, #42	; 0x2a
   12d88:	d10b      	bne.n	12da2 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x1c2>
        const int prec = (int)va_arg(va, int);
   12d8a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   12d8c:	1d1a      	adds	r2, r3, #4
   12d8e:	66ba      	str	r2, [r7, #104]	; 0x68
   12d90:	681b      	ldr	r3, [r3, #0]
   12d92:	62fb      	str	r3, [r7, #44]	; 0x2c
        precision = prec > 0 ? (unsigned int)prec : 0U;
   12d94:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   12d96:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   12d9a:	64fb      	str	r3, [r7, #76]	; 0x4c
        format++;
   12d9c:	683b      	ldr	r3, [r7, #0]
   12d9e:	3301      	adds	r3, #1
   12da0:	603b      	str	r3, [r7, #0]
      }
    }

    // evaluate length field
    switch (*format) {
   12da2:	683b      	ldr	r3, [r7, #0]
   12da4:	781b      	ldrb	r3, [r3, #0]
   12da6:	3b68      	subs	r3, #104	; 0x68
   12da8:	2b12      	cmp	r3, #18
   12daa:	d867      	bhi.n	12e7c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x29c>
   12dac:	a201      	add	r2, pc, #4	; (adr r2, 12db4 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x1d4>)
   12dae:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   12db2:	bf00      	nop
   12db4:	00012e27 	.word	0x00012e27
   12db8:	00012e7d 	.word	0x00012e7d
   12dbc:	00012e5d 	.word	0x00012e5d
   12dc0:	00012e7d 	.word	0x00012e7d
   12dc4:	00012e01 	.word	0x00012e01
   12dc8:	00012e7d 	.word	0x00012e7d
   12dcc:	00012e7d 	.word	0x00012e7d
   12dd0:	00012e7d 	.word	0x00012e7d
   12dd4:	00012e7d 	.word	0x00012e7d
   12dd8:	00012e7d 	.word	0x00012e7d
   12ddc:	00012e7d 	.word	0x00012e7d
   12de0:	00012e7d 	.word	0x00012e7d
   12de4:	00012e4d 	.word	0x00012e4d
   12de8:	00012e7d 	.word	0x00012e7d
   12dec:	00012e7d 	.word	0x00012e7d
   12df0:	00012e7d 	.word	0x00012e7d
   12df4:	00012e7d 	.word	0x00012e7d
   12df8:	00012e7d 	.word	0x00012e7d
   12dfc:	00012e6d 	.word	0x00012e6d
      case 'l' :
        flags |= FLAGS_LONG;
   12e00:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   12e02:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   12e06:	657b      	str	r3, [r7, #84]	; 0x54
        format++;
   12e08:	683b      	ldr	r3, [r7, #0]
   12e0a:	3301      	adds	r3, #1
   12e0c:	603b      	str	r3, [r7, #0]
        if (*format == 'l') {
   12e0e:	683b      	ldr	r3, [r7, #0]
   12e10:	781b      	ldrb	r3, [r3, #0]
   12e12:	2b6c      	cmp	r3, #108	; 0x6c
   12e14:	d134      	bne.n	12e80 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2a0>
          flags |= FLAGS_LONG_LONG;
   12e16:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   12e18:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   12e1c:	657b      	str	r3, [r7, #84]	; 0x54
          format++;
   12e1e:	683b      	ldr	r3, [r7, #0]
   12e20:	3301      	adds	r3, #1
   12e22:	603b      	str	r3, [r7, #0]
        }
        break;
   12e24:	e02c      	b.n	12e80 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2a0>
      case 'h' :
        flags |= FLAGS_SHORT;
   12e26:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   12e28:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   12e2c:	657b      	str	r3, [r7, #84]	; 0x54
        format++;
   12e2e:	683b      	ldr	r3, [r7, #0]
   12e30:	3301      	adds	r3, #1
   12e32:	603b      	str	r3, [r7, #0]
        if (*format == 'h') {
   12e34:	683b      	ldr	r3, [r7, #0]
   12e36:	781b      	ldrb	r3, [r3, #0]
   12e38:	2b68      	cmp	r3, #104	; 0x68
   12e3a:	d125      	bne.n	12e88 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2a8>
          flags |= FLAGS_CHAR;
   12e3c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   12e3e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   12e42:	657b      	str	r3, [r7, #84]	; 0x54
          format++;
   12e44:	683b      	ldr	r3, [r7, #0]
   12e46:	3301      	adds	r3, #1
   12e48:	603b      	str	r3, [r7, #0]
        }
        break;
   12e4a:	e01d      	b.n	12e88 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2a8>
#if defined(PRINTF_SUPPORT_PTRDIFF_T)
      case 't' :
        flags |= (sizeof(ptrdiff_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
   12e4c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   12e4e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   12e52:	657b      	str	r3, [r7, #84]	; 0x54
        format++;
   12e54:	683b      	ldr	r3, [r7, #0]
   12e56:	3301      	adds	r3, #1
   12e58:	603b      	str	r3, [r7, #0]
        break;
   12e5a:	e016      	b.n	12e8a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2aa>
#endif
      case 'j' :
        flags |= (sizeof(intmax_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
   12e5c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   12e5e:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   12e62:	657b      	str	r3, [r7, #84]	; 0x54
        format++;
   12e64:	683b      	ldr	r3, [r7, #0]
   12e66:	3301      	adds	r3, #1
   12e68:	603b      	str	r3, [r7, #0]
        break;
   12e6a:	e00e      	b.n	12e8a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2aa>
      case 'z' :
        flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
   12e6c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   12e6e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   12e72:	657b      	str	r3, [r7, #84]	; 0x54
        format++;
   12e74:	683b      	ldr	r3, [r7, #0]
   12e76:	3301      	adds	r3, #1
   12e78:	603b      	str	r3, [r7, #0]
        break;
   12e7a:	e006      	b.n	12e8a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2aa>
      default :
        break;
   12e7c:	bf00      	nop
   12e7e:	e004      	b.n	12e8a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2aa>
        break;
   12e80:	bf00      	nop
   12e82:	e002      	b.n	12e8a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2aa>
   12e84:	000122c9 	.word	0x000122c9
        break;
   12e88:	bf00      	nop
    }

    // evaluate specifier
    switch (*format) {
   12e8a:	683b      	ldr	r3, [r7, #0]
   12e8c:	781b      	ldrb	r3, [r3, #0]
   12e8e:	3b25      	subs	r3, #37	; 0x25
   12e90:	2b53      	cmp	r3, #83	; 0x53
   12e92:	f200 82ee 	bhi.w	13472 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x892>
   12e96:	a201      	add	r2, pc, #4	; (adr r2, 12e9c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2bc>)
   12e98:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   12e9c:	0001345b 	.word	0x0001345b
   12ea0:	00013473 	.word	0x00013473
   12ea4:	00013473 	.word	0x00013473
   12ea8:	00013473 	.word	0x00013473
   12eac:	00013473 	.word	0x00013473
   12eb0:	00013473 	.word	0x00013473
   12eb4:	00013473 	.word	0x00013473
   12eb8:	00013473 	.word	0x00013473
   12ebc:	00013473 	.word	0x00013473
   12ec0:	00013473 	.word	0x00013473
   12ec4:	00013473 	.word	0x00013473
   12ec8:	00013473 	.word	0x00013473
   12ecc:	00013473 	.word	0x00013473
   12ed0:	00013473 	.word	0x00013473
   12ed4:	00013473 	.word	0x00013473
   12ed8:	00013473 	.word	0x00013473
   12edc:	00013473 	.word	0x00013473
   12ee0:	00013473 	.word	0x00013473
   12ee4:	00013473 	.word	0x00013473
   12ee8:	00013473 	.word	0x00013473
   12eec:	00013473 	.word	0x00013473
   12ef0:	00013473 	.word	0x00013473
   12ef4:	00013473 	.word	0x00013473
   12ef8:	00013473 	.word	0x00013473
   12efc:	00013473 	.word	0x00013473
   12f00:	00013473 	.word	0x00013473
   12f04:	00013473 	.word	0x00013473
   12f08:	00013473 	.word	0x00013473
   12f0c:	00013473 	.word	0x00013473
   12f10:	00013473 	.word	0x00013473
   12f14:	00013473 	.word	0x00013473
   12f18:	00013473 	.word	0x00013473
   12f1c:	00013473 	.word	0x00013473
   12f20:	00013279 	.word	0x00013279
   12f24:	00013473 	.word	0x00013473
   12f28:	00013473 	.word	0x00013473
   12f2c:	00013473 	.word	0x00013473
   12f30:	00013473 	.word	0x00013473
   12f34:	00013473 	.word	0x00013473
   12f38:	00013473 	.word	0x00013473
   12f3c:	00013473 	.word	0x00013473
   12f40:	00013473 	.word	0x00013473
   12f44:	00013473 	.word	0x00013473
   12f48:	00013473 	.word	0x00013473
   12f4c:	00013473 	.word	0x00013473
   12f50:	00013473 	.word	0x00013473
   12f54:	00013473 	.word	0x00013473
   12f58:	00013473 	.word	0x00013473
   12f5c:	00013473 	.word	0x00013473
   12f60:	00013473 	.word	0x00013473
   12f64:	00013473 	.word	0x00013473
   12f68:	00012fed 	.word	0x00012fed
   12f6c:	00013473 	.word	0x00013473
   12f70:	00013473 	.word	0x00013473
   12f74:	00013473 	.word	0x00013473
   12f78:	00013473 	.word	0x00013473
   12f7c:	00013473 	.word	0x00013473
   12f80:	00013473 	.word	0x00013473
   12f84:	00013473 	.word	0x00013473
   12f88:	00013473 	.word	0x00013473
   12f8c:	00013473 	.word	0x00013473
   12f90:	00012fed 	.word	0x00012fed
   12f94:	000132b5 	.word	0x000132b5
   12f98:	00012fed 	.word	0x00012fed
   12f9c:	00013473 	.word	0x00013473
   12fa0:	00013279 	.word	0x00013279
   12fa4:	00013473 	.word	0x00013473
   12fa8:	00013473 	.word	0x00013473
   12fac:	00012fed 	.word	0x00012fed
   12fb0:	00013473 	.word	0x00013473
   12fb4:	00013473 	.word	0x00013473
   12fb8:	00013473 	.word	0x00013473
   12fbc:	00013473 	.word	0x00013473
   12fc0:	00013473 	.word	0x00013473
   12fc4:	00012fed 	.word	0x00012fed
   12fc8:	00013413 	.word	0x00013413
   12fcc:	00013473 	.word	0x00013473
   12fd0:	00013473 	.word	0x00013473
   12fd4:	0001333d 	.word	0x0001333d
   12fd8:	00013473 	.word	0x00013473
   12fdc:	00012fed 	.word	0x00012fed
   12fe0:	00013473 	.word	0x00013473
   12fe4:	00013473 	.word	0x00013473
   12fe8:	00012fed 	.word	0x00012fed
      case 'X' :
      case 'o' :
      case 'b' : {
        // set the base
        unsigned int base;
        if (*format == 'x' || *format == 'X') {
   12fec:	683b      	ldr	r3, [r7, #0]
   12fee:	781b      	ldrb	r3, [r3, #0]
   12ff0:	2b78      	cmp	r3, #120	; 0x78
   12ff2:	d003      	beq.n	12ffc <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x41c>
   12ff4:	683b      	ldr	r3, [r7, #0]
   12ff6:	781b      	ldrb	r3, [r3, #0]
   12ff8:	2b58      	cmp	r3, #88	; 0x58
   12ffa:	d102      	bne.n	13002 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x422>
          base = 16U;
   12ffc:	2310      	movs	r3, #16
   12ffe:	643b      	str	r3, [r7, #64]	; 0x40
   13000:	e013      	b.n	1302a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x44a>
        }
        else if (*format == 'o') {
   13002:	683b      	ldr	r3, [r7, #0]
   13004:	781b      	ldrb	r3, [r3, #0]
   13006:	2b6f      	cmp	r3, #111	; 0x6f
   13008:	d102      	bne.n	13010 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x430>
          base =  8U;
   1300a:	2308      	movs	r3, #8
   1300c:	643b      	str	r3, [r7, #64]	; 0x40
   1300e:	e00c      	b.n	1302a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x44a>
        }
        else if (*format == 'b') {
   13010:	683b      	ldr	r3, [r7, #0]
   13012:	781b      	ldrb	r3, [r3, #0]
   13014:	2b62      	cmp	r3, #98	; 0x62
   13016:	d102      	bne.n	1301e <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x43e>
          base =  2U;
   13018:	2302      	movs	r3, #2
   1301a:	643b      	str	r3, [r7, #64]	; 0x40
   1301c:	e005      	b.n	1302a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x44a>
        }
        else {
          base = 10U;
   1301e:	230a      	movs	r3, #10
   13020:	643b      	str	r3, [r7, #64]	; 0x40
          flags &= ~FLAGS_HASH;   // no hash for dec format
   13022:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   13024:	f023 0310 	bic.w	r3, r3, #16
   13028:	657b      	str	r3, [r7, #84]	; 0x54
        }
        // uppercase
        if (*format == 'X') {
   1302a:	683b      	ldr	r3, [r7, #0]
   1302c:	781b      	ldrb	r3, [r3, #0]
   1302e:	2b58      	cmp	r3, #88	; 0x58
   13030:	d103      	bne.n	1303a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x45a>
          flags |= FLAGS_UPPERCASE;
   13032:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   13034:	f043 0320 	orr.w	r3, r3, #32
   13038:	657b      	str	r3, [r7, #84]	; 0x54
        }

        // no plus or space flag for u, x, X, o, b
        if ((*format != 'i') && (*format != 'd')) {
   1303a:	683b      	ldr	r3, [r7, #0]
   1303c:	781b      	ldrb	r3, [r3, #0]
   1303e:	2b69      	cmp	r3, #105	; 0x69
   13040:	d007      	beq.n	13052 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x472>
   13042:	683b      	ldr	r3, [r7, #0]
   13044:	781b      	ldrb	r3, [r3, #0]
   13046:	2b64      	cmp	r3, #100	; 0x64
   13048:	d003      	beq.n	13052 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x472>
          flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
   1304a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   1304c:	f023 030c 	bic.w	r3, r3, #12
   13050:	657b      	str	r3, [r7, #84]	; 0x54
        }

        // ignore '0' flag when precision is given
        if (flags & FLAGS_PRECISION) {
   13052:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   13054:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   13058:	2b00      	cmp	r3, #0
   1305a:	d003      	beq.n	13064 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x484>
          flags &= ~FLAGS_ZEROPAD;
   1305c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   1305e:	f023 0301 	bic.w	r3, r3, #1
   13062:	657b      	str	r3, [r7, #84]	; 0x54
        }

        // convert the integer
        if ((*format == 'i') || (*format == 'd')) {
   13064:	683b      	ldr	r3, [r7, #0]
   13066:	781b      	ldrb	r3, [r3, #0]
   13068:	2b69      	cmp	r3, #105	; 0x69
   1306a:	d004      	beq.n	13076 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x496>
   1306c:	683b      	ldr	r3, [r7, #0]
   1306e:	781b      	ldrb	r3, [r3, #0]
   13070:	2b64      	cmp	r3, #100	; 0x64
   13072:	f040 808d 	bne.w	13190 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x5b0>
          // signed
          if (flags & FLAGS_LONG_LONG) {
   13076:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   13078:	f403 7300 	and.w	r3, r3, #512	; 0x200
   1307c:	2b00      	cmp	r3, #0
   1307e:	d02e      	beq.n	130de <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x4fe>
#if defined(PRINTF_SUPPORT_LONG_LONG)
            const long long value = va_arg(va, long long);
   13080:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   13082:	3307      	adds	r3, #7
   13084:	f023 0307 	bic.w	r3, r3, #7
   13088:	f103 0208 	add.w	r2, r3, #8
   1308c:	66ba      	str	r2, [r7, #104]	; 0x68
   1308e:	e9d3 3400 	ldrd	r3, r4, [r3]
   13092:	e9c7 3404 	strd	r3, r4, [r7, #16]
            idx = _ntoa_long_long(out, buffer, idx, maxlen, (unsigned long long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
   13096:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
   1309a:	2b00      	cmp	r3, #0
   1309c:	f174 0200 	sbcs.w	r2, r4, #0
   130a0:	da02      	bge.n	130a8 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x4c8>
   130a2:	425b      	negs	r3, r3
   130a4:	eb64 0444 	sbc.w	r4, r4, r4, lsl #1
   130a8:	4619      	mov	r1, r3
   130aa:	4622      	mov	r2, r4
   130ac:	697b      	ldr	r3, [r7, #20]
   130ae:	0fdb      	lsrs	r3, r3, #31
   130b0:	b2d8      	uxtb	r0, r3
   130b2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   130b4:	f04f 0400 	mov.w	r4, #0
   130b8:	6d7d      	ldr	r5, [r7, #84]	; 0x54
   130ba:	9508      	str	r5, [sp, #32]
   130bc:	6d3d      	ldr	r5, [r7, #80]	; 0x50
   130be:	9507      	str	r5, [sp, #28]
   130c0:	6cfd      	ldr	r5, [r7, #76]	; 0x4c
   130c2:	9506      	str	r5, [sp, #24]
   130c4:	e9cd 3404 	strd	r3, r4, [sp, #16]
   130c8:	9002      	str	r0, [sp, #8]
   130ca:	e9cd 1200 	strd	r1, r2, [sp]
   130ce:	687b      	ldr	r3, [r7, #4]
   130d0:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   130d2:	68b9      	ldr	r1, [r7, #8]
   130d4:	68f8      	ldr	r0, [r7, #12]
   130d6:	f7ff faf0 	bl	126ba <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)>
   130da:	6478      	str	r0, [r7, #68]	; 0x44
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
          }
          else {
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
          }
   130dc:	e0c8      	b.n	13270 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x690>
          else if (flags & FLAGS_LONG) {
   130de:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   130e0:	f403 7380 	and.w	r3, r3, #256	; 0x100
   130e4:	2b00      	cmp	r3, #0
   130e6:	d01e      	beq.n	13126 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x546>
            const long value = va_arg(va, long);
   130e8:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   130ea:	1d1a      	adds	r2, r3, #4
   130ec:	66ba      	str	r2, [r7, #104]	; 0x68
   130ee:	681b      	ldr	r3, [r3, #0]
   130f0:	61fb      	str	r3, [r7, #28]
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
   130f2:	69fb      	ldr	r3, [r7, #28]
   130f4:	2b00      	cmp	r3, #0
   130f6:	bfb8      	it	lt
   130f8:	425b      	neglt	r3, r3
   130fa:	4619      	mov	r1, r3
   130fc:	69fb      	ldr	r3, [r7, #28]
   130fe:	0fdb      	lsrs	r3, r3, #31
   13100:	b2db      	uxtb	r3, r3
   13102:	6d7a      	ldr	r2, [r7, #84]	; 0x54
   13104:	9205      	str	r2, [sp, #20]
   13106:	6d3a      	ldr	r2, [r7, #80]	; 0x50
   13108:	9204      	str	r2, [sp, #16]
   1310a:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
   1310c:	9203      	str	r2, [sp, #12]
   1310e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   13110:	9202      	str	r2, [sp, #8]
   13112:	9301      	str	r3, [sp, #4]
   13114:	9100      	str	r1, [sp, #0]
   13116:	687b      	ldr	r3, [r7, #4]
   13118:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   1311a:	68b9      	ldr	r1, [r7, #8]
   1311c:	68f8      	ldr	r0, [r7, #12]
   1311e:	f7ff fa64 	bl	125ea <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)>
   13122:	6478      	str	r0, [r7, #68]	; 0x44
          }
   13124:	e0a4      	b.n	13270 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x690>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
   13126:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   13128:	f003 0340 	and.w	r3, r3, #64	; 0x40
   1312c:	2b00      	cmp	r3, #0
   1312e:	d005      	beq.n	1313c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x55c>
   13130:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   13132:	1d1a      	adds	r2, r3, #4
   13134:	66ba      	str	r2, [r7, #104]	; 0x68
   13136:	681b      	ldr	r3, [r3, #0]
   13138:	b2db      	uxtb	r3, r3
   1313a:	e00e      	b.n	1315a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x57a>
   1313c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   1313e:	f003 0380 	and.w	r3, r3, #128	; 0x80
   13142:	2b00      	cmp	r3, #0
   13144:	d005      	beq.n	13152 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x572>
   13146:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   13148:	1d1a      	adds	r2, r3, #4
   1314a:	66ba      	str	r2, [r7, #104]	; 0x68
   1314c:	681b      	ldr	r3, [r3, #0]
   1314e:	b21b      	sxth	r3, r3
   13150:	e003      	b.n	1315a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x57a>
   13152:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   13154:	1d1a      	adds	r2, r3, #4
   13156:	66ba      	str	r2, [r7, #104]	; 0x68
   13158:	681b      	ldr	r3, [r3, #0]
   1315a:	623b      	str	r3, [r7, #32]
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
   1315c:	6a3b      	ldr	r3, [r7, #32]
   1315e:	2b00      	cmp	r3, #0
   13160:	bfb8      	it	lt
   13162:	425b      	neglt	r3, r3
   13164:	4619      	mov	r1, r3
   13166:	6a3b      	ldr	r3, [r7, #32]
   13168:	0fdb      	lsrs	r3, r3, #31
   1316a:	b2db      	uxtb	r3, r3
   1316c:	6d7a      	ldr	r2, [r7, #84]	; 0x54
   1316e:	9205      	str	r2, [sp, #20]
   13170:	6d3a      	ldr	r2, [r7, #80]	; 0x50
   13172:	9204      	str	r2, [sp, #16]
   13174:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
   13176:	9203      	str	r2, [sp, #12]
   13178:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   1317a:	9202      	str	r2, [sp, #8]
   1317c:	9301      	str	r3, [sp, #4]
   1317e:	9100      	str	r1, [sp, #0]
   13180:	687b      	ldr	r3, [r7, #4]
   13182:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   13184:	68b9      	ldr	r1, [r7, #8]
   13186:	68f8      	ldr	r0, [r7, #12]
   13188:	f7ff fa2f 	bl	125ea <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)>
   1318c:	6478      	str	r0, [r7, #68]	; 0x44
          }
   1318e:	e06f      	b.n	13270 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x690>
        }
        else {
          // unsigned
          if (flags & FLAGS_LONG_LONG) {
   13190:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   13192:	f403 7300 	and.w	r3, r3, #512	; 0x200
   13196:	2b00      	cmp	r3, #0
   13198:	d020      	beq.n	131dc <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x5fc>
#if defined(PRINTF_SUPPORT_LONG_LONG)
            idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
   1319a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   1319c:	3307      	adds	r3, #7
   1319e:	f023 0307 	bic.w	r3, r3, #7
   131a2:	f103 0208 	add.w	r2, r3, #8
   131a6:	66ba      	str	r2, [r7, #104]	; 0x68
   131a8:	e9d3 3400 	ldrd	r3, r4, [r3]
   131ac:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   131ae:	4611      	mov	r1, r2
   131b0:	f04f 0200 	mov.w	r2, #0
   131b4:	6d78      	ldr	r0, [r7, #84]	; 0x54
   131b6:	9008      	str	r0, [sp, #32]
   131b8:	6d38      	ldr	r0, [r7, #80]	; 0x50
   131ba:	9007      	str	r0, [sp, #28]
   131bc:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
   131be:	9006      	str	r0, [sp, #24]
   131c0:	e9cd 1204 	strd	r1, r2, [sp, #16]
   131c4:	2200      	movs	r2, #0
   131c6:	9202      	str	r2, [sp, #8]
   131c8:	e9cd 3400 	strd	r3, r4, [sp]
   131cc:	687b      	ldr	r3, [r7, #4]
   131ce:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   131d0:	68b9      	ldr	r1, [r7, #8]
   131d2:	68f8      	ldr	r0, [r7, #12]
   131d4:	f7ff fa71 	bl	126ba <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)>
   131d8:	6478      	str	r0, [r7, #68]	; 0x44
   131da:	e049      	b.n	13270 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x690>
#endif
          }
          else if (flags & FLAGS_LONG) {
   131dc:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   131de:	f403 7380 	and.w	r3, r3, #256	; 0x100
   131e2:	2b00      	cmp	r3, #0
   131e4:	d016      	beq.n	13214 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x634>
            idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
   131e6:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   131e8:	1d1a      	adds	r2, r3, #4
   131ea:	66ba      	str	r2, [r7, #104]	; 0x68
   131ec:	681b      	ldr	r3, [r3, #0]
   131ee:	6d7a      	ldr	r2, [r7, #84]	; 0x54
   131f0:	9205      	str	r2, [sp, #20]
   131f2:	6d3a      	ldr	r2, [r7, #80]	; 0x50
   131f4:	9204      	str	r2, [sp, #16]
   131f6:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
   131f8:	9203      	str	r2, [sp, #12]
   131fa:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   131fc:	9202      	str	r2, [sp, #8]
   131fe:	2200      	movs	r2, #0
   13200:	9201      	str	r2, [sp, #4]
   13202:	9300      	str	r3, [sp, #0]
   13204:	687b      	ldr	r3, [r7, #4]
   13206:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   13208:	68b9      	ldr	r1, [r7, #8]
   1320a:	68f8      	ldr	r0, [r7, #12]
   1320c:	f7ff f9ed 	bl	125ea <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)>
   13210:	6478      	str	r0, [r7, #68]	; 0x44
   13212:	e02d      	b.n	13270 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x690>
          }
          else {
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
   13214:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   13216:	f003 0340 	and.w	r3, r3, #64	; 0x40
   1321a:	2b00      	cmp	r3, #0
   1321c:	d005      	beq.n	1322a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x64a>
   1321e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   13220:	1d1a      	adds	r2, r3, #4
   13222:	66ba      	str	r2, [r7, #104]	; 0x68
   13224:	681b      	ldr	r3, [r3, #0]
   13226:	b2db      	uxtb	r3, r3
   13228:	e00e      	b.n	13248 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x668>
   1322a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   1322c:	f003 0380 	and.w	r3, r3, #128	; 0x80
   13230:	2b00      	cmp	r3, #0
   13232:	d005      	beq.n	13240 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x660>
   13234:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   13236:	1d1a      	adds	r2, r3, #4
   13238:	66ba      	str	r2, [r7, #104]	; 0x68
   1323a:	681b      	ldr	r3, [r3, #0]
   1323c:	b29b      	uxth	r3, r3
   1323e:	e003      	b.n	13248 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x668>
   13240:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   13242:	1d1a      	adds	r2, r3, #4
   13244:	66ba      	str	r2, [r7, #104]	; 0x68
   13246:	681b      	ldr	r3, [r3, #0]
   13248:	627b      	str	r3, [r7, #36]	; 0x24
            idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);
   1324a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   1324c:	9305      	str	r3, [sp, #20]
   1324e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
   13250:	9304      	str	r3, [sp, #16]
   13252:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   13254:	9303      	str	r3, [sp, #12]
   13256:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   13258:	9302      	str	r3, [sp, #8]
   1325a:	2300      	movs	r3, #0
   1325c:	9301      	str	r3, [sp, #4]
   1325e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   13260:	9300      	str	r3, [sp, #0]
   13262:	687b      	ldr	r3, [r7, #4]
   13264:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   13266:	68b9      	ldr	r1, [r7, #8]
   13268:	68f8      	ldr	r0, [r7, #12]
   1326a:	f7ff f9be 	bl	125ea <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)>
   1326e:	6478      	str	r0, [r7, #68]	; 0x44
          }
        }
        format++;
   13270:	683b      	ldr	r3, [r7, #0]
   13272:	3301      	adds	r3, #1
   13274:	603b      	str	r3, [r7, #0]
        break;
   13276:	e109      	b.n	1348c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8ac>
      }
#if defined(PRINTF_SUPPORT_FLOAT)
      case 'f' :
      case 'F' :
        idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
   13278:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   1327a:	3307      	adds	r3, #7
   1327c:	f023 0307 	bic.w	r3, r3, #7
   13280:	f103 0208 	add.w	r2, r3, #8
   13284:	66ba      	str	r2, [r7, #104]	; 0x68
   13286:	ed93 7b00 	vldr	d7, [r3]
   1328a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   1328c:	9302      	str	r3, [sp, #8]
   1328e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
   13290:	9301      	str	r3, [sp, #4]
   13292:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   13294:	9300      	str	r3, [sp, #0]
   13296:	eeb0 0a47 	vmov.f32	s0, s14
   1329a:	eef0 0a67 	vmov.f32	s1, s15
   1329e:	687b      	ldr	r3, [r7, #4]
   132a0:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   132a2:	68b9      	ldr	r1, [r7, #8]
   132a4:	68f8      	ldr	r0, [r7, #12]
   132a6:	f7ff fa79 	bl	1279c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)>
   132aa:	6478      	str	r0, [r7, #68]	; 0x44
        format++;
   132ac:	683b      	ldr	r3, [r7, #0]
   132ae:	3301      	adds	r3, #1
   132b0:	603b      	str	r3, [r7, #0]
        break;
   132b2:	e0eb      	b.n	1348c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8ac>
#endif  // PRINTF_SUPPORT_FLOAT
      case 'c' : {
        unsigned int l = 1U;
   132b4:	2301      	movs	r3, #1
   132b6:	63fb      	str	r3, [r7, #60]	; 0x3c
        // pre padding
        if (!(flags & FLAGS_LEFT)) {
   132b8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   132ba:	f003 0302 	and.w	r3, r3, #2
   132be:	2b00      	cmp	r3, #0
   132c0:	d113      	bne.n	132ea <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x70a>
          while (l++ < width) {
   132c2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   132c4:	1c5a      	adds	r2, r3, #1
   132c6:	63fa      	str	r2, [r7, #60]	; 0x3c
   132c8:	6d3a      	ldr	r2, [r7, #80]	; 0x50
   132ca:	429a      	cmp	r2, r3
   132cc:	bf8c      	ite	hi
   132ce:	2301      	movhi	r3, #1
   132d0:	2300      	movls	r3, #0
   132d2:	b2db      	uxtb	r3, r3
   132d4:	2b00      	cmp	r3, #0
   132d6:	d008      	beq.n	132ea <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x70a>
            out(' ', buffer, idx++, maxlen);
   132d8:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   132da:	1c53      	adds	r3, r2, #1
   132dc:	647b      	str	r3, [r7, #68]	; 0x44
   132de:	68fc      	ldr	r4, [r7, #12]
   132e0:	687b      	ldr	r3, [r7, #4]
   132e2:	68b9      	ldr	r1, [r7, #8]
   132e4:	2020      	movs	r0, #32
   132e6:	47a0      	blx	r4
          while (l++ < width) {
   132e8:	e7eb      	b.n	132c2 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x6e2>
          }
        }
        // char output
        out((char)va_arg(va, int), buffer, idx++, maxlen);
   132ea:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   132ec:	1d1a      	adds	r2, r3, #4
   132ee:	66ba      	str	r2, [r7, #104]	; 0x68
   132f0:	681b      	ldr	r3, [r3, #0]
   132f2:	b2d8      	uxtb	r0, r3
   132f4:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   132f6:	1c53      	adds	r3, r2, #1
   132f8:	647b      	str	r3, [r7, #68]	; 0x44
   132fa:	68fc      	ldr	r4, [r7, #12]
   132fc:	687b      	ldr	r3, [r7, #4]
   132fe:	68b9      	ldr	r1, [r7, #8]
   13300:	47a0      	blx	r4
        // post padding
        if (flags & FLAGS_LEFT) {
   13302:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   13304:	f003 0302 	and.w	r3, r3, #2
   13308:	2b00      	cmp	r3, #0
   1330a:	d013      	beq.n	13334 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x754>
          while (l++ < width) {
   1330c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   1330e:	1c5a      	adds	r2, r3, #1
   13310:	63fa      	str	r2, [r7, #60]	; 0x3c
   13312:	6d3a      	ldr	r2, [r7, #80]	; 0x50
   13314:	429a      	cmp	r2, r3
   13316:	bf8c      	ite	hi
   13318:	2301      	movhi	r3, #1
   1331a:	2300      	movls	r3, #0
   1331c:	b2db      	uxtb	r3, r3
   1331e:	2b00      	cmp	r3, #0
   13320:	d008      	beq.n	13334 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x754>
            out(' ', buffer, idx++, maxlen);
   13322:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   13324:	1c53      	adds	r3, r2, #1
   13326:	647b      	str	r3, [r7, #68]	; 0x44
   13328:	68fc      	ldr	r4, [r7, #12]
   1332a:	687b      	ldr	r3, [r7, #4]
   1332c:	68b9      	ldr	r1, [r7, #8]
   1332e:	2020      	movs	r0, #32
   13330:	47a0      	blx	r4
          while (l++ < width) {
   13332:	e7eb      	b.n	1330c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x72c>
          }
        }
        format++;
   13334:	683b      	ldr	r3, [r7, #0]
   13336:	3301      	adds	r3, #1
   13338:	603b      	str	r3, [r7, #0]
        break;
   1333a:	e0a7      	b.n	1348c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8ac>
      }

      case 's' : {
        char* p = va_arg(va, char*);
   1333c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   1333e:	1d1a      	adds	r2, r3, #4
   13340:	66ba      	str	r2, [r7, #104]	; 0x68
   13342:	681b      	ldr	r3, [r3, #0]
   13344:	63bb      	str	r3, [r7, #56]	; 0x38
        unsigned int l = _strlen(p);
   13346:	6bb8      	ldr	r0, [r7, #56]	; 0x38
   13348:	f7fe ffdf 	bl	1230a <_strlen(char const*)>
   1334c:	6378      	str	r0, [r7, #52]	; 0x34
        // pre padding
        if (flags & FLAGS_PRECISION) {
   1334e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   13350:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   13354:	2b00      	cmp	r3, #0
   13356:	d007      	beq.n	13368 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x788>
          l = (l < precision ? l : precision);
   13358:	6b7a      	ldr	r2, [r7, #52]	; 0x34
   1335a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   1335c:	429a      	cmp	r2, r3
   1335e:	d201      	bcs.n	13364 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x784>
   13360:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   13362:	e000      	b.n	13366 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x786>
   13364:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   13366:	637b      	str	r3, [r7, #52]	; 0x34
        }
        if (!(flags & FLAGS_LEFT)) {
   13368:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   1336a:	f003 0302 	and.w	r3, r3, #2
   1336e:	2b00      	cmp	r3, #0
   13370:	d113      	bne.n	1339a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7ba>
          while (l++ < width) {
   13372:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   13374:	1c5a      	adds	r2, r3, #1
   13376:	637a      	str	r2, [r7, #52]	; 0x34
   13378:	6d3a      	ldr	r2, [r7, #80]	; 0x50
   1337a:	429a      	cmp	r2, r3
   1337c:	bf8c      	ite	hi
   1337e:	2301      	movhi	r3, #1
   13380:	2300      	movls	r3, #0
   13382:	b2db      	uxtb	r3, r3
   13384:	2b00      	cmp	r3, #0
   13386:	d008      	beq.n	1339a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7ba>
            out(' ', buffer, idx++, maxlen);
   13388:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   1338a:	1c53      	adds	r3, r2, #1
   1338c:	647b      	str	r3, [r7, #68]	; 0x44
   1338e:	68fc      	ldr	r4, [r7, #12]
   13390:	687b      	ldr	r3, [r7, #4]
   13392:	68b9      	ldr	r1, [r7, #8]
   13394:	2020      	movs	r0, #32
   13396:	47a0      	blx	r4
          while (l++ < width) {
   13398:	e7eb      	b.n	13372 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x792>
          }
        }
        // string output
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
   1339a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1339c:	781b      	ldrb	r3, [r3, #0]
   1339e:	2b00      	cmp	r3, #0
   133a0:	d00b      	beq.n	133ba <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7da>
   133a2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   133a4:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   133a8:	2b00      	cmp	r3, #0
   133aa:	d004      	beq.n	133b6 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7d6>
   133ac:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   133ae:	1e5a      	subs	r2, r3, #1
   133b0:	64fa      	str	r2, [r7, #76]	; 0x4c
   133b2:	2b00      	cmp	r3, #0
   133b4:	d001      	beq.n	133ba <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7da>
   133b6:	2301      	movs	r3, #1
   133b8:	e000      	b.n	133bc <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7dc>
   133ba:	2300      	movs	r3, #0
   133bc:	2b00      	cmp	r3, #0
   133be:	d00b      	beq.n	133d8 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7f8>
          out(*(p++), buffer, idx++, maxlen);
   133c0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   133c2:	1c5a      	adds	r2, r3, #1
   133c4:	63ba      	str	r2, [r7, #56]	; 0x38
   133c6:	7818      	ldrb	r0, [r3, #0]
   133c8:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   133ca:	1c53      	adds	r3, r2, #1
   133cc:	647b      	str	r3, [r7, #68]	; 0x44
   133ce:	68fc      	ldr	r4, [r7, #12]
   133d0:	687b      	ldr	r3, [r7, #4]
   133d2:	68b9      	ldr	r1, [r7, #8]
   133d4:	47a0      	blx	r4
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
   133d6:	e7e0      	b.n	1339a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7ba>
        }
        // post padding
        if (flags & FLAGS_LEFT) {
   133d8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   133da:	f003 0302 	and.w	r3, r3, #2
   133de:	2b00      	cmp	r3, #0
   133e0:	d013      	beq.n	1340a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x82a>
          while (l++ < width) {
   133e2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   133e4:	1c5a      	adds	r2, r3, #1
   133e6:	637a      	str	r2, [r7, #52]	; 0x34
   133e8:	6d3a      	ldr	r2, [r7, #80]	; 0x50
   133ea:	429a      	cmp	r2, r3
   133ec:	bf8c      	ite	hi
   133ee:	2301      	movhi	r3, #1
   133f0:	2300      	movls	r3, #0
   133f2:	b2db      	uxtb	r3, r3
   133f4:	2b00      	cmp	r3, #0
   133f6:	d008      	beq.n	1340a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x82a>
            out(' ', buffer, idx++, maxlen);
   133f8:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   133fa:	1c53      	adds	r3, r2, #1
   133fc:	647b      	str	r3, [r7, #68]	; 0x44
   133fe:	68fc      	ldr	r4, [r7, #12]
   13400:	687b      	ldr	r3, [r7, #4]
   13402:	68b9      	ldr	r1, [r7, #8]
   13404:	2020      	movs	r0, #32
   13406:	47a0      	blx	r4
          while (l++ < width) {
   13408:	e7eb      	b.n	133e2 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x802>
          }
        }
        format++;
   1340a:	683b      	ldr	r3, [r7, #0]
   1340c:	3301      	adds	r3, #1
   1340e:	603b      	str	r3, [r7, #0]
        break;
   13410:	e03c      	b.n	1348c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8ac>
      }

      case 'p' : {
        width = sizeof(void*) * 2U;
   13412:	2308      	movs	r3, #8
   13414:	653b      	str	r3, [r7, #80]	; 0x50
        flags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;
   13416:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   13418:	f043 0321 	orr.w	r3, r3, #33	; 0x21
   1341c:	657b      	str	r3, [r7, #84]	; 0x54
#if defined(PRINTF_SUPPORT_LONG_LONG)
        const bool is_ll = sizeof(uintptr_t) == sizeof(long long);
   1341e:	2300      	movs	r3, #0
   13420:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
        if (is_ll) {
          idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);
        }
        else {
#endif
          idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)((uintptr_t)va_arg(va, void*)), false, 16U, precision, width, flags);
   13424:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   13426:	1d1a      	adds	r2, r3, #4
   13428:	66ba      	str	r2, [r7, #104]	; 0x68
   1342a:	681b      	ldr	r3, [r3, #0]
   1342c:	461a      	mov	r2, r3
   1342e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   13430:	9305      	str	r3, [sp, #20]
   13432:	6d3b      	ldr	r3, [r7, #80]	; 0x50
   13434:	9304      	str	r3, [sp, #16]
   13436:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   13438:	9303      	str	r3, [sp, #12]
   1343a:	2310      	movs	r3, #16
   1343c:	9302      	str	r3, [sp, #8]
   1343e:	2300      	movs	r3, #0
   13440:	9301      	str	r3, [sp, #4]
   13442:	9200      	str	r2, [sp, #0]
   13444:	687b      	ldr	r3, [r7, #4]
   13446:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   13448:	68b9      	ldr	r1, [r7, #8]
   1344a:	68f8      	ldr	r0, [r7, #12]
   1344c:	f7ff f8cd 	bl	125ea <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)>
   13450:	6478      	str	r0, [r7, #68]	; 0x44
#if defined(PRINTF_SUPPORT_LONG_LONG)
        }
#endif
        format++;
   13452:	683b      	ldr	r3, [r7, #0]
   13454:	3301      	adds	r3, #1
   13456:	603b      	str	r3, [r7, #0]
        break;
   13458:	e018      	b.n	1348c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8ac>
      }

      case '%' :
        out('%', buffer, idx++, maxlen);
   1345a:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   1345c:	1c53      	adds	r3, r2, #1
   1345e:	647b      	str	r3, [r7, #68]	; 0x44
   13460:	68fc      	ldr	r4, [r7, #12]
   13462:	687b      	ldr	r3, [r7, #4]
   13464:	68b9      	ldr	r1, [r7, #8]
   13466:	2025      	movs	r0, #37	; 0x25
   13468:	47a0      	blx	r4
        format++;
   1346a:	683b      	ldr	r3, [r7, #0]
   1346c:	3301      	adds	r3, #1
   1346e:	603b      	str	r3, [r7, #0]
        break;
   13470:	e00c      	b.n	1348c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8ac>

      default :
        out(*format, buffer, idx++, maxlen);
   13472:	683b      	ldr	r3, [r7, #0]
   13474:	7818      	ldrb	r0, [r3, #0]
   13476:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   13478:	1c53      	adds	r3, r2, #1
   1347a:	647b      	str	r3, [r7, #68]	; 0x44
   1347c:	68fc      	ldr	r4, [r7, #12]
   1347e:	687b      	ldr	r3, [r7, #4]
   13480:	68b9      	ldr	r1, [r7, #8]
   13482:	47a0      	blx	r4
        format++;
   13484:	683b      	ldr	r3, [r7, #0]
   13486:	3301      	adds	r3, #1
   13488:	603b      	str	r3, [r7, #0]
        break;
   1348a:	bf00      	nop
  while (*format)
   1348c:	f7ff bbb6 	b.w	12bfc <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x1c>
    }
  }

  // termination
  out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);
   13490:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   13492:	687b      	ldr	r3, [r7, #4]
   13494:	429a      	cmp	r2, r3
   13496:	d302      	bcc.n	1349e <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8be>
   13498:	687b      	ldr	r3, [r7, #4]
   1349a:	1e5a      	subs	r2, r3, #1
   1349c:	e000      	b.n	134a0 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8c0>
   1349e:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   134a0:	68fc      	ldr	r4, [r7, #12]
   134a2:	687b      	ldr	r3, [r7, #4]
   134a4:	68b9      	ldr	r1, [r7, #8]
   134a6:	2000      	movs	r0, #0
   134a8:	47a0      	blx	r4

  // return written chars without terminating \0
  return (int)idx;
   134aa:	6c7b      	ldr	r3, [r7, #68]	; 0x44
}
   134ac:	4618      	mov	r0, r3
   134ae:	3758      	adds	r7, #88	; 0x58
   134b0:	46bd      	mov	sp, r7
   134b2:	bdb0      	pop	{r4, r5, r7, pc}

000134b4 <printf>:

///////////////////////////////////////////////////////////////////////////////


int printf(const char* format, ...)
{
   134b4:	b40f      	push	{r0, r1, r2, r3}
   134b6:	b580      	push	{r7, lr}
   134b8:	b086      	sub	sp, #24
   134ba:	af02      	add	r7, sp, #8
  va_list va;
  va_start(va, format);
   134bc:	f107 031c 	add.w	r3, r7, #28
   134c0:	60bb      	str	r3, [r7, #8]
  char buffer[1];
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
   134c2:	1d39      	adds	r1, r7, #4
   134c4:	68bb      	ldr	r3, [r7, #8]
   134c6:	9300      	str	r3, [sp, #0]
   134c8:	69bb      	ldr	r3, [r7, #24]
   134ca:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   134ce:	4806      	ldr	r0, [pc, #24]	; (134e8 <printf+0x34>)
   134d0:	f7ff fb86 	bl	12be0 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)>
   134d4:	60f8      	str	r0, [r7, #12]
  va_end(va);
  return ret;
   134d6:	68fb      	ldr	r3, [r7, #12]
}
   134d8:	4618      	mov	r0, r3
   134da:	3710      	adds	r7, #16
   134dc:	46bd      	mov	sp, r7
   134de:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
   134e2:	b004      	add	sp, #16
   134e4:	4770      	bx	lr
   134e6:	bf00      	nop
   134e8:	000122e5 	.word	0x000122e5

000134ec <__cxa_pure_virtual>:
   134ec:	b508      	push	{r3, lr}
   134ee:	f000 f80d 	bl	1350c <std::terminate()>

000134f2 <__cxxabiv1::__terminate(void (*)())>:
   134f2:	b508      	push	{r3, lr}
   134f4:	4780      	blx	r0
   134f6:	f001 f965 	bl	147c4 <abort>
   134fa:	Address 0x00000000000134fa is out of bounds.


000134fc <std::get_terminate()>:
   134fc:	4b02      	ldr	r3, [pc, #8]	; (13508 <std::get_terminate()+0xc>)
   134fe:	6818      	ldr	r0, [r3, #0]
   13500:	f3bf 8f5b 	dmb	ish
   13504:	4770      	bx	lr
   13506:	bf00      	nop
   13508:	10000188 	.word	0x10000188

0001350c <std::terminate()>:
   1350c:	b508      	push	{r3, lr}
   1350e:	f7ff fff5 	bl	134fc <std::get_terminate()>
   13512:	f7ff ffee 	bl	134f2 <__cxxabiv1::__terminate(void (*)())>
   13516:	Address 0x0000000000013516 is out of bounds.


00013518 <__aeabi_d2f>:
   13518:	ea4f 0241 	mov.w	r2, r1, lsl #1
   1351c:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
   13520:	bf24      	itt	cs
   13522:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
   13526:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
   1352a:	d90d      	bls.n	13548 <__aeabi_d2f+0x30>
   1352c:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
   13530:	ea4f 02c0 	mov.w	r2, r0, lsl #3
   13534:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
   13538:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
   1353c:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
   13540:	bf08      	it	eq
   13542:	f020 0001 	biceq.w	r0, r0, #1
   13546:	4770      	bx	lr
   13548:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
   1354c:	d121      	bne.n	13592 <__aeabi_d2f+0x7a>
   1354e:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
   13552:	bfbc      	itt	lt
   13554:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
   13558:	4770      	bxlt	lr
   1355a:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   1355e:	ea4f 5252 	mov.w	r2, r2, lsr #21
   13562:	f1c2 0218 	rsb	r2, r2, #24
   13566:	f1c2 0c20 	rsb	ip, r2, #32
   1356a:	fa10 f30c 	lsls.w	r3, r0, ip
   1356e:	fa20 f002 	lsr.w	r0, r0, r2
   13572:	bf18      	it	ne
   13574:	f040 0001 	orrne.w	r0, r0, #1
   13578:	ea4f 23c1 	mov.w	r3, r1, lsl #11
   1357c:	ea4f 23d3 	mov.w	r3, r3, lsr #11
   13580:	fa03 fc0c 	lsl.w	ip, r3, ip
   13584:	ea40 000c 	orr.w	r0, r0, ip
   13588:	fa23 f302 	lsr.w	r3, r3, r2
   1358c:	ea4f 0343 	mov.w	r3, r3, lsl #1
   13590:	e7cc      	b.n	1352c <__aeabi_d2f+0x14>
   13592:	ea7f 5362 	mvns.w	r3, r2, asr #21
   13596:	d107      	bne.n	135a8 <__aeabi_d2f+0x90>
   13598:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
   1359c:	bf1e      	ittt	ne
   1359e:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
   135a2:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
   135a6:	4770      	bxne	lr
   135a8:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
   135ac:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
   135b0:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   135b4:	4770      	bx	lr
   135b6:	bf00      	nop

000135b8 <__aeabi_uldivmod>:
   135b8:	b953      	cbnz	r3, 135d0 <__aeabi_uldivmod+0x18>
   135ba:	b94a      	cbnz	r2, 135d0 <__aeabi_uldivmod+0x18>
   135bc:	2900      	cmp	r1, #0
   135be:	bf08      	it	eq
   135c0:	2800      	cmpeq	r0, #0
   135c2:	bf1c      	itt	ne
   135c4:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
   135c8:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
   135cc:	f001 b8f8 	b.w	147c0 <__aeabi_idiv0>
   135d0:	f1ad 0c08 	sub.w	ip, sp, #8
   135d4:	e96d ce04 	strd	ip, lr, [sp, #-16]!
   135d8:	f000 f806 	bl	135e8 <__udivmoddi4>
   135dc:	f8dd e004 	ldr.w	lr, [sp, #4]
   135e0:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   135e4:	b004      	add	sp, #16
   135e6:	4770      	bx	lr

000135e8 <__udivmoddi4>:
   135e8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   135ec:	9e08      	ldr	r6, [sp, #32]
   135ee:	4604      	mov	r4, r0
   135f0:	4688      	mov	r8, r1
   135f2:	2b00      	cmp	r3, #0
   135f4:	d14b      	bne.n	1368e <__udivmoddi4+0xa6>
   135f6:	428a      	cmp	r2, r1
   135f8:	4615      	mov	r5, r2
   135fa:	d967      	bls.n	136cc <__udivmoddi4+0xe4>
   135fc:	fab2 f282 	clz	r2, r2
   13600:	b14a      	cbz	r2, 13616 <__udivmoddi4+0x2e>
   13602:	f1c2 0720 	rsb	r7, r2, #32
   13606:	fa01 f302 	lsl.w	r3, r1, r2
   1360a:	fa20 f707 	lsr.w	r7, r0, r7
   1360e:	4095      	lsls	r5, r2
   13610:	ea47 0803 	orr.w	r8, r7, r3
   13614:	4094      	lsls	r4, r2
   13616:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   1361a:	0c23      	lsrs	r3, r4, #16
   1361c:	fbb8 f7fe 	udiv	r7, r8, lr
   13620:	fa1f fc85 	uxth.w	ip, r5
   13624:	fb0e 8817 	mls	r8, lr, r7, r8
   13628:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
   1362c:	fb07 f10c 	mul.w	r1, r7, ip
   13630:	4299      	cmp	r1, r3
   13632:	d909      	bls.n	13648 <__udivmoddi4+0x60>
   13634:	18eb      	adds	r3, r5, r3
   13636:	f107 30ff 	add.w	r0, r7, #4294967295	; 0xffffffff
   1363a:	f080 811b 	bcs.w	13874 <__udivmoddi4+0x28c>
   1363e:	4299      	cmp	r1, r3
   13640:	f240 8118 	bls.w	13874 <__udivmoddi4+0x28c>
   13644:	3f02      	subs	r7, #2
   13646:	442b      	add	r3, r5
   13648:	1a5b      	subs	r3, r3, r1
   1364a:	b2a4      	uxth	r4, r4
   1364c:	fbb3 f0fe 	udiv	r0, r3, lr
   13650:	fb0e 3310 	mls	r3, lr, r0, r3
   13654:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
   13658:	fb00 fc0c 	mul.w	ip, r0, ip
   1365c:	45a4      	cmp	ip, r4
   1365e:	d909      	bls.n	13674 <__udivmoddi4+0x8c>
   13660:	192c      	adds	r4, r5, r4
   13662:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   13666:	f080 8107 	bcs.w	13878 <__udivmoddi4+0x290>
   1366a:	45a4      	cmp	ip, r4
   1366c:	f240 8104 	bls.w	13878 <__udivmoddi4+0x290>
   13670:	3802      	subs	r0, #2
   13672:	442c      	add	r4, r5
   13674:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
   13678:	eba4 040c 	sub.w	r4, r4, ip
   1367c:	2700      	movs	r7, #0
   1367e:	b11e      	cbz	r6, 13688 <__udivmoddi4+0xa0>
   13680:	40d4      	lsrs	r4, r2
   13682:	2300      	movs	r3, #0
   13684:	e9c6 4300 	strd	r4, r3, [r6]
   13688:	4639      	mov	r1, r7
   1368a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1368e:	428b      	cmp	r3, r1
   13690:	d909      	bls.n	136a6 <__udivmoddi4+0xbe>
   13692:	2e00      	cmp	r6, #0
   13694:	f000 80eb 	beq.w	1386e <__udivmoddi4+0x286>
   13698:	2700      	movs	r7, #0
   1369a:	e9c6 0100 	strd	r0, r1, [r6]
   1369e:	4638      	mov	r0, r7
   136a0:	4639      	mov	r1, r7
   136a2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   136a6:	fab3 f783 	clz	r7, r3
   136aa:	2f00      	cmp	r7, #0
   136ac:	d147      	bne.n	1373e <__udivmoddi4+0x156>
   136ae:	428b      	cmp	r3, r1
   136b0:	d302      	bcc.n	136b8 <__udivmoddi4+0xd0>
   136b2:	4282      	cmp	r2, r0
   136b4:	f200 80fa 	bhi.w	138ac <__udivmoddi4+0x2c4>
   136b8:	1a84      	subs	r4, r0, r2
   136ba:	eb61 0303 	sbc.w	r3, r1, r3
   136be:	2001      	movs	r0, #1
   136c0:	4698      	mov	r8, r3
   136c2:	2e00      	cmp	r6, #0
   136c4:	d0e0      	beq.n	13688 <__udivmoddi4+0xa0>
   136c6:	e9c6 4800 	strd	r4, r8, [r6]
   136ca:	e7dd      	b.n	13688 <__udivmoddi4+0xa0>
   136cc:	b902      	cbnz	r2, 136d0 <__udivmoddi4+0xe8>
   136ce:	deff      	udf	#255	; 0xff
   136d0:	fab2 f282 	clz	r2, r2
   136d4:	2a00      	cmp	r2, #0
   136d6:	f040 808f 	bne.w	137f8 <__udivmoddi4+0x210>
   136da:	1b49      	subs	r1, r1, r5
   136dc:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   136e0:	fa1f f885 	uxth.w	r8, r5
   136e4:	2701      	movs	r7, #1
   136e6:	fbb1 fcfe 	udiv	ip, r1, lr
   136ea:	0c23      	lsrs	r3, r4, #16
   136ec:	fb0e 111c 	mls	r1, lr, ip, r1
   136f0:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
   136f4:	fb08 f10c 	mul.w	r1, r8, ip
   136f8:	4299      	cmp	r1, r3
   136fa:	d907      	bls.n	1370c <__udivmoddi4+0x124>
   136fc:	18eb      	adds	r3, r5, r3
   136fe:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
   13702:	d202      	bcs.n	1370a <__udivmoddi4+0x122>
   13704:	4299      	cmp	r1, r3
   13706:	f200 80cd 	bhi.w	138a4 <__udivmoddi4+0x2bc>
   1370a:	4684      	mov	ip, r0
   1370c:	1a59      	subs	r1, r3, r1
   1370e:	b2a3      	uxth	r3, r4
   13710:	fbb1 f0fe 	udiv	r0, r1, lr
   13714:	fb0e 1410 	mls	r4, lr, r0, r1
   13718:	ea43 4404 	orr.w	r4, r3, r4, lsl #16
   1371c:	fb08 f800 	mul.w	r8, r8, r0
   13720:	45a0      	cmp	r8, r4
   13722:	d907      	bls.n	13734 <__udivmoddi4+0x14c>
   13724:	192c      	adds	r4, r5, r4
   13726:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   1372a:	d202      	bcs.n	13732 <__udivmoddi4+0x14a>
   1372c:	45a0      	cmp	r8, r4
   1372e:	f200 80b6 	bhi.w	1389e <__udivmoddi4+0x2b6>
   13732:	4618      	mov	r0, r3
   13734:	eba4 0408 	sub.w	r4, r4, r8
   13738:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
   1373c:	e79f      	b.n	1367e <__udivmoddi4+0x96>
   1373e:	f1c7 0c20 	rsb	ip, r7, #32
   13742:	40bb      	lsls	r3, r7
   13744:	fa22 fe0c 	lsr.w	lr, r2, ip
   13748:	ea4e 0e03 	orr.w	lr, lr, r3
   1374c:	fa01 f407 	lsl.w	r4, r1, r7
   13750:	fa20 f50c 	lsr.w	r5, r0, ip
   13754:	fa21 f30c 	lsr.w	r3, r1, ip
   13758:	ea4f 481e 	mov.w	r8, lr, lsr #16
   1375c:	4325      	orrs	r5, r4
   1375e:	fbb3 f9f8 	udiv	r9, r3, r8
   13762:	0c2c      	lsrs	r4, r5, #16
   13764:	fb08 3319 	mls	r3, r8, r9, r3
   13768:	fa1f fa8e 	uxth.w	sl, lr
   1376c:	ea44 4303 	orr.w	r3, r4, r3, lsl #16
   13770:	fb09 f40a 	mul.w	r4, r9, sl
   13774:	429c      	cmp	r4, r3
   13776:	fa02 f207 	lsl.w	r2, r2, r7
   1377a:	fa00 f107 	lsl.w	r1, r0, r7
   1377e:	d90b      	bls.n	13798 <__udivmoddi4+0x1b0>
   13780:	eb1e 0303 	adds.w	r3, lr, r3
   13784:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
   13788:	f080 8087 	bcs.w	1389a <__udivmoddi4+0x2b2>
   1378c:	429c      	cmp	r4, r3
   1378e:	f240 8084 	bls.w	1389a <__udivmoddi4+0x2b2>
   13792:	f1a9 0902 	sub.w	r9, r9, #2
   13796:	4473      	add	r3, lr
   13798:	1b1b      	subs	r3, r3, r4
   1379a:	b2ad      	uxth	r5, r5
   1379c:	fbb3 f0f8 	udiv	r0, r3, r8
   137a0:	fb08 3310 	mls	r3, r8, r0, r3
   137a4:	ea45 4403 	orr.w	r4, r5, r3, lsl #16
   137a8:	fb00 fa0a 	mul.w	sl, r0, sl
   137ac:	45a2      	cmp	sl, r4
   137ae:	d908      	bls.n	137c2 <__udivmoddi4+0x1da>
   137b0:	eb1e 0404 	adds.w	r4, lr, r4
   137b4:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   137b8:	d26b      	bcs.n	13892 <__udivmoddi4+0x2aa>
   137ba:	45a2      	cmp	sl, r4
   137bc:	d969      	bls.n	13892 <__udivmoddi4+0x2aa>
   137be:	3802      	subs	r0, #2
   137c0:	4474      	add	r4, lr
   137c2:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
   137c6:	fba0 8902 	umull	r8, r9, r0, r2
   137ca:	eba4 040a 	sub.w	r4, r4, sl
   137ce:	454c      	cmp	r4, r9
   137d0:	46c2      	mov	sl, r8
   137d2:	464b      	mov	r3, r9
   137d4:	d354      	bcc.n	13880 <__udivmoddi4+0x298>
   137d6:	d051      	beq.n	1387c <__udivmoddi4+0x294>
   137d8:	2e00      	cmp	r6, #0
   137da:	d069      	beq.n	138b0 <__udivmoddi4+0x2c8>
   137dc:	ebb1 050a 	subs.w	r5, r1, sl
   137e0:	eb64 0403 	sbc.w	r4, r4, r3
   137e4:	fa04 fc0c 	lsl.w	ip, r4, ip
   137e8:	40fd      	lsrs	r5, r7
   137ea:	40fc      	lsrs	r4, r7
   137ec:	ea4c 0505 	orr.w	r5, ip, r5
   137f0:	e9c6 5400 	strd	r5, r4, [r6]
   137f4:	2700      	movs	r7, #0
   137f6:	e747      	b.n	13688 <__udivmoddi4+0xa0>
   137f8:	f1c2 0320 	rsb	r3, r2, #32
   137fc:	fa20 f703 	lsr.w	r7, r0, r3
   13800:	4095      	lsls	r5, r2
   13802:	fa01 f002 	lsl.w	r0, r1, r2
   13806:	fa21 f303 	lsr.w	r3, r1, r3
   1380a:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   1380e:	4338      	orrs	r0, r7
   13810:	0c01      	lsrs	r1, r0, #16
   13812:	fbb3 f7fe 	udiv	r7, r3, lr
   13816:	fa1f f885 	uxth.w	r8, r5
   1381a:	fb0e 3317 	mls	r3, lr, r7, r3
   1381e:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
   13822:	fb07 f308 	mul.w	r3, r7, r8
   13826:	428b      	cmp	r3, r1
   13828:	fa04 f402 	lsl.w	r4, r4, r2
   1382c:	d907      	bls.n	1383e <__udivmoddi4+0x256>
   1382e:	1869      	adds	r1, r5, r1
   13830:	f107 3cff 	add.w	ip, r7, #4294967295	; 0xffffffff
   13834:	d22f      	bcs.n	13896 <__udivmoddi4+0x2ae>
   13836:	428b      	cmp	r3, r1
   13838:	d92d      	bls.n	13896 <__udivmoddi4+0x2ae>
   1383a:	3f02      	subs	r7, #2
   1383c:	4429      	add	r1, r5
   1383e:	1acb      	subs	r3, r1, r3
   13840:	b281      	uxth	r1, r0
   13842:	fbb3 f0fe 	udiv	r0, r3, lr
   13846:	fb0e 3310 	mls	r3, lr, r0, r3
   1384a:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
   1384e:	fb00 f308 	mul.w	r3, r0, r8
   13852:	428b      	cmp	r3, r1
   13854:	d907      	bls.n	13866 <__udivmoddi4+0x27e>
   13856:	1869      	adds	r1, r5, r1
   13858:	f100 3cff 	add.w	ip, r0, #4294967295	; 0xffffffff
   1385c:	d217      	bcs.n	1388e <__udivmoddi4+0x2a6>
   1385e:	428b      	cmp	r3, r1
   13860:	d915      	bls.n	1388e <__udivmoddi4+0x2a6>
   13862:	3802      	subs	r0, #2
   13864:	4429      	add	r1, r5
   13866:	1ac9      	subs	r1, r1, r3
   13868:	ea40 4707 	orr.w	r7, r0, r7, lsl #16
   1386c:	e73b      	b.n	136e6 <__udivmoddi4+0xfe>
   1386e:	4637      	mov	r7, r6
   13870:	4630      	mov	r0, r6
   13872:	e709      	b.n	13688 <__udivmoddi4+0xa0>
   13874:	4607      	mov	r7, r0
   13876:	e6e7      	b.n	13648 <__udivmoddi4+0x60>
   13878:	4618      	mov	r0, r3
   1387a:	e6fb      	b.n	13674 <__udivmoddi4+0x8c>
   1387c:	4541      	cmp	r1, r8
   1387e:	d2ab      	bcs.n	137d8 <__udivmoddi4+0x1f0>
   13880:	ebb8 0a02 	subs.w	sl, r8, r2
   13884:	eb69 020e 	sbc.w	r2, r9, lr
   13888:	3801      	subs	r0, #1
   1388a:	4613      	mov	r3, r2
   1388c:	e7a4      	b.n	137d8 <__udivmoddi4+0x1f0>
   1388e:	4660      	mov	r0, ip
   13890:	e7e9      	b.n	13866 <__udivmoddi4+0x27e>
   13892:	4618      	mov	r0, r3
   13894:	e795      	b.n	137c2 <__udivmoddi4+0x1da>
   13896:	4667      	mov	r7, ip
   13898:	e7d1      	b.n	1383e <__udivmoddi4+0x256>
   1389a:	4681      	mov	r9, r0
   1389c:	e77c      	b.n	13798 <__udivmoddi4+0x1b0>
   1389e:	3802      	subs	r0, #2
   138a0:	442c      	add	r4, r5
   138a2:	e747      	b.n	13734 <__udivmoddi4+0x14c>
   138a4:	f1ac 0c02 	sub.w	ip, ip, #2
   138a8:	442b      	add	r3, r5
   138aa:	e72f      	b.n	1370c <__udivmoddi4+0x124>
   138ac:	4638      	mov	r0, r7
   138ae:	e708      	b.n	136c2 <__udivmoddi4+0xda>
   138b0:	4637      	mov	r7, r6
   138b2:	e6e9      	b.n	13688 <__udivmoddi4+0xa0>

000138b4 <selfrel_offset31>:
   138b4:	6803      	ldr	r3, [r0, #0]
   138b6:	005a      	lsls	r2, r3, #1
   138b8:	bf4c      	ite	mi
   138ba:	f043 4300 	orrmi.w	r3, r3, #2147483648	; 0x80000000
   138be:	f023 4300 	bicpl.w	r3, r3, #2147483648	; 0x80000000
   138c2:	4418      	add	r0, r3
   138c4:	4770      	bx	lr
   138c6:	bf00      	nop

000138c8 <search_EIT_table>:
   138c8:	b361      	cbz	r1, 13924 <search_EIT_table+0x5c>
   138ca:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   138ce:	f101 3aff 	add.w	sl, r1, #4294967295	; 0xffffffff
   138d2:	4690      	mov	r8, r2
   138d4:	4606      	mov	r6, r0
   138d6:	46d1      	mov	r9, sl
   138d8:	2700      	movs	r7, #0
   138da:	eb07 0409 	add.w	r4, r7, r9
   138de:	eb04 74d4 	add.w	r4, r4, r4, lsr #31
   138e2:	1064      	asrs	r4, r4, #1
   138e4:	00e5      	lsls	r5, r4, #3
   138e6:	1971      	adds	r1, r6, r5
   138e8:	4608      	mov	r0, r1
   138ea:	f7ff ffe3 	bl	138b4 <selfrel_offset31>
   138ee:	45a2      	cmp	sl, r4
   138f0:	4683      	mov	fp, r0
   138f2:	f105 0008 	add.w	r0, r5, #8
   138f6:	4430      	add	r0, r6
   138f8:	d009      	beq.n	1390e <search_EIT_table+0x46>
   138fa:	f7ff ffdb 	bl	138b4 <selfrel_offset31>
   138fe:	45c3      	cmp	fp, r8
   13900:	f100 30ff 	add.w	r0, r0, #4294967295	; 0xffffffff
   13904:	d805      	bhi.n	13912 <search_EIT_table+0x4a>
   13906:	4540      	cmp	r0, r8
   13908:	d209      	bcs.n	1391e <search_EIT_table+0x56>
   1390a:	1c67      	adds	r7, r4, #1
   1390c:	e7e5      	b.n	138da <search_EIT_table+0x12>
   1390e:	45c3      	cmp	fp, r8
   13910:	d905      	bls.n	1391e <search_EIT_table+0x56>
   13912:	42a7      	cmp	r7, r4
   13914:	d002      	beq.n	1391c <search_EIT_table+0x54>
   13916:	f104 39ff 	add.w	r9, r4, #4294967295	; 0xffffffff
   1391a:	e7de      	b.n	138da <search_EIT_table+0x12>
   1391c:	2100      	movs	r1, #0
   1391e:	4608      	mov	r0, r1
   13920:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   13924:	4608      	mov	r0, r1
   13926:	4770      	bx	lr

00013928 <__gnu_unwind_get_pr_addr>:
   13928:	2801      	cmp	r0, #1
   1392a:	d007      	beq.n	1393c <__gnu_unwind_get_pr_addr+0x14>
   1392c:	2802      	cmp	r0, #2
   1392e:	d007      	beq.n	13940 <__gnu_unwind_get_pr_addr+0x18>
   13930:	4b04      	ldr	r3, [pc, #16]	; (13944 <__gnu_unwind_get_pr_addr+0x1c>)
   13932:	2800      	cmp	r0, #0
   13934:	bf0c      	ite	eq
   13936:	4618      	moveq	r0, r3
   13938:	2000      	movne	r0, #0
   1393a:	4770      	bx	lr
   1393c:	4802      	ldr	r0, [pc, #8]	; (13948 <__gnu_unwind_get_pr_addr+0x20>)
   1393e:	4770      	bx	lr
   13940:	4802      	ldr	r0, [pc, #8]	; (1394c <__gnu_unwind_get_pr_addr+0x24>)
   13942:	4770      	bx	lr
   13944:	00014015 	.word	0x00014015
   13948:	00014019 	.word	0x00014019
   1394c:	0001401d 	.word	0x0001401d

00013950 <get_eit_entry>:
   13950:	b530      	push	{r4, r5, lr}
   13952:	4b25      	ldr	r3, [pc, #148]	; (139e8 <get_eit_entry+0x98>)
   13954:	b083      	sub	sp, #12
   13956:	4604      	mov	r4, r0
   13958:	1e8d      	subs	r5, r1, #2
   1395a:	b34b      	cbz	r3, 139b0 <get_eit_entry+0x60>
   1395c:	a901      	add	r1, sp, #4
   1395e:	4628      	mov	r0, r5
   13960:	f3af 8000 	nop.w
   13964:	b1f0      	cbz	r0, 139a4 <get_eit_entry+0x54>
   13966:	9901      	ldr	r1, [sp, #4]
   13968:	462a      	mov	r2, r5
   1396a:	f7ff ffad 	bl	138c8 <search_EIT_table>
   1396e:	4601      	mov	r1, r0
   13970:	b1c0      	cbz	r0, 139a4 <get_eit_entry+0x54>
   13972:	f7ff ff9f 	bl	138b4 <selfrel_offset31>
   13976:	684b      	ldr	r3, [r1, #4]
   13978:	64a0      	str	r0, [r4, #72]	; 0x48
   1397a:	2b01      	cmp	r3, #1
   1397c:	d02e      	beq.n	139dc <get_eit_entry+0x8c>
   1397e:	2b00      	cmp	r3, #0
   13980:	f101 0004 	add.w	r0, r1, #4
   13984:	db26      	blt.n	139d4 <get_eit_entry+0x84>
   13986:	f7ff ff95 	bl	138b4 <selfrel_offset31>
   1398a:	2300      	movs	r3, #0
   1398c:	e9c4 0313 	strd	r0, r3, [r4, #76]	; 0x4c
   13990:	6803      	ldr	r3, [r0, #0]
   13992:	2b00      	cmp	r3, #0
   13994:	db12      	blt.n	139bc <get_eit_entry+0x6c>
   13996:	f7ff ff8d 	bl	138b4 <selfrel_offset31>
   1399a:	2300      	movs	r3, #0
   1399c:	6120      	str	r0, [r4, #16]
   1399e:	4618      	mov	r0, r3
   139a0:	b003      	add	sp, #12
   139a2:	bd30      	pop	{r4, r5, pc}
   139a4:	2300      	movs	r3, #0
   139a6:	6123      	str	r3, [r4, #16]
   139a8:	2309      	movs	r3, #9
   139aa:	4618      	mov	r0, r3
   139ac:	b003      	add	sp, #12
   139ae:	bd30      	pop	{r4, r5, pc}
   139b0:	490e      	ldr	r1, [pc, #56]	; (139ec <get_eit_entry+0x9c>)
   139b2:	480f      	ldr	r0, [pc, #60]	; (139f0 <get_eit_entry+0xa0>)
   139b4:	1a09      	subs	r1, r1, r0
   139b6:	10c9      	asrs	r1, r1, #3
   139b8:	9101      	str	r1, [sp, #4]
   139ba:	e7d5      	b.n	13968 <get_eit_entry+0x18>
   139bc:	f3c3 6003 	ubfx	r0, r3, #24, #4
   139c0:	f7ff ffb2 	bl	13928 <__gnu_unwind_get_pr_addr>
   139c4:	2800      	cmp	r0, #0
   139c6:	bf14      	ite	ne
   139c8:	2300      	movne	r3, #0
   139ca:	2309      	moveq	r3, #9
   139cc:	6120      	str	r0, [r4, #16]
   139ce:	4618      	mov	r0, r3
   139d0:	b003      	add	sp, #12
   139d2:	bd30      	pop	{r4, r5, pc}
   139d4:	2301      	movs	r3, #1
   139d6:	e9c4 0313 	strd	r0, r3, [r4, #76]	; 0x4c
   139da:	e7d9      	b.n	13990 <get_eit_entry+0x40>
   139dc:	2300      	movs	r3, #0
   139de:	6123      	str	r3, [r4, #16]
   139e0:	2305      	movs	r3, #5
   139e2:	4618      	mov	r0, r3
   139e4:	b003      	add	sp, #12
   139e6:	bd30      	pop	{r4, r5, pc}
   139e8:	00000000 	.word	0x00000000
   139ec:	000166f0 	.word	0x000166f0
   139f0:	00016298 	.word	0x00016298

000139f4 <restore_non_core_regs>:
   139f4:	6803      	ldr	r3, [r0, #0]
   139f6:	07da      	lsls	r2, r3, #31
   139f8:	b510      	push	{r4, lr}
   139fa:	4604      	mov	r4, r0
   139fc:	d406      	bmi.n	13a0c <restore_non_core_regs+0x18>
   139fe:	079b      	lsls	r3, r3, #30
   13a00:	f100 0048 	add.w	r0, r0, #72	; 0x48
   13a04:	d509      	bpl.n	13a1a <restore_non_core_regs+0x26>
   13a06:	f000 fc5f 	bl	142c8 <__gnu_Unwind_Restore_VFP_D>
   13a0a:	6823      	ldr	r3, [r4, #0]
   13a0c:	0759      	lsls	r1, r3, #29
   13a0e:	d509      	bpl.n	13a24 <restore_non_core_regs+0x30>
   13a10:	071a      	lsls	r2, r3, #28
   13a12:	d50e      	bpl.n	13a32 <restore_non_core_regs+0x3e>
   13a14:	06db      	lsls	r3, r3, #27
   13a16:	d513      	bpl.n	13a40 <restore_non_core_regs+0x4c>
   13a18:	bd10      	pop	{r4, pc}
   13a1a:	f000 fc4d 	bl	142b8 <__gnu_Unwind_Restore_VFP>
   13a1e:	6823      	ldr	r3, [r4, #0]
   13a20:	0759      	lsls	r1, r3, #29
   13a22:	d4f5      	bmi.n	13a10 <restore_non_core_regs+0x1c>
   13a24:	f104 00d0 	add.w	r0, r4, #208	; 0xd0
   13a28:	f000 fc56 	bl	142d8 <__gnu_Unwind_Restore_VFP_D_16_to_31>
   13a2c:	6823      	ldr	r3, [r4, #0]
   13a2e:	071a      	lsls	r2, r3, #28
   13a30:	d4f0      	bmi.n	13a14 <restore_non_core_regs+0x20>
   13a32:	f504 70a8 	add.w	r0, r4, #336	; 0x150
   13a36:	f000 fc57 	bl	142e8 <__gnu_Unwind_Restore_WMMXD>
   13a3a:	6823      	ldr	r3, [r4, #0]
   13a3c:	06db      	lsls	r3, r3, #27
   13a3e:	d4eb      	bmi.n	13a18 <restore_non_core_regs+0x24>
   13a40:	f504 70e8 	add.w	r0, r4, #464	; 0x1d0
   13a44:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   13a48:	f000 bc92 	b.w	14370 <__gnu_Unwind_Restore_WMMXC>

00013a4c <_Unwind_decode_typeinfo_ptr.isra.0>:
   13a4c:	6803      	ldr	r3, [r0, #0]
   13a4e:	b103      	cbz	r3, 13a52 <_Unwind_decode_typeinfo_ptr.isra.0+0x6>
   13a50:	4403      	add	r3, r0
   13a52:	4618      	mov	r0, r3
   13a54:	4770      	bx	lr
   13a56:	bf00      	nop

00013a58 <__gnu_unwind_24bit.isra.1>:
   13a58:	2009      	movs	r0, #9
   13a5a:	4770      	bx	lr

00013a5c <_Unwind_DebugHook>:
   13a5c:	4770      	bx	lr
   13a5e:	bf00      	nop

00013a60 <unwind_phase2>:
   13a60:	b570      	push	{r4, r5, r6, lr}
   13a62:	4604      	mov	r4, r0
   13a64:	460d      	mov	r5, r1
   13a66:	e008      	b.n	13a7a <unwind_phase2+0x1a>
   13a68:	6c2b      	ldr	r3, [r5, #64]	; 0x40
   13a6a:	6163      	str	r3, [r4, #20]
   13a6c:	462a      	mov	r2, r5
   13a6e:	6923      	ldr	r3, [r4, #16]
   13a70:	4621      	mov	r1, r4
   13a72:	2001      	movs	r0, #1
   13a74:	4798      	blx	r3
   13a76:	2808      	cmp	r0, #8
   13a78:	d108      	bne.n	13a8c <unwind_phase2+0x2c>
   13a7a:	6c29      	ldr	r1, [r5, #64]	; 0x40
   13a7c:	4620      	mov	r0, r4
   13a7e:	f7ff ff67 	bl	13950 <get_eit_entry>
   13a82:	4606      	mov	r6, r0
   13a84:	2800      	cmp	r0, #0
   13a86:	d0ef      	beq.n	13a68 <unwind_phase2+0x8>
   13a88:	f000 fe9c 	bl	147c4 <abort>
   13a8c:	2807      	cmp	r0, #7
   13a8e:	d1fb      	bne.n	13a88 <unwind_phase2+0x28>
   13a90:	4630      	mov	r0, r6
   13a92:	6c29      	ldr	r1, [r5, #64]	; 0x40
   13a94:	f7ff ffe2 	bl	13a5c <_Unwind_DebugHook>
   13a98:	1d28      	adds	r0, r5, #4
   13a9a:	f000 fc01 	bl	142a0 <__restore_core_regs>
   13a9e:	bf00      	nop

00013aa0 <unwind_phase2_forced>:
   13aa0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   13aa4:	1d0c      	adds	r4, r1, #4
   13aa6:	4605      	mov	r5, r0
   13aa8:	4617      	mov	r7, r2
   13aaa:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
   13aac:	f5ad 7d72 	sub.w	sp, sp, #968	; 0x3c8
   13ab0:	ae03      	add	r6, sp, #12
   13ab2:	c60f      	stmia	r6!, {r0, r1, r2, r3}
   13ab4:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
   13ab6:	c60f      	stmia	r6!, {r0, r1, r2, r3}
   13ab8:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
   13aba:	c60f      	stmia	r6!, {r0, r1, r2, r3}
   13abc:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
   13ac0:	ac02      	add	r4, sp, #8
   13ac2:	f8d5 800c 	ldr.w	r8, [r5, #12]
   13ac6:	f8d5 9018 	ldr.w	r9, [r5, #24]
   13aca:	e886 000f 	stmia.w	r6, {r0, r1, r2, r3}
   13ace:	2300      	movs	r3, #0
   13ad0:	6023      	str	r3, [r4, #0]
   13ad2:	e021      	b.n	13b18 <unwind_phase2_forced+0x78>
   13ad4:	6c23      	ldr	r3, [r4, #64]	; 0x40
   13ad6:	616b      	str	r3, [r5, #20]
   13ad8:	f44f 72f0 	mov.w	r2, #480	; 0x1e0
   13adc:	4621      	mov	r1, r4
   13ade:	a87a      	add	r0, sp, #488	; 0x1e8
   13ae0:	f000 fe9c 	bl	1481c <memcpy>
   13ae4:	692b      	ldr	r3, [r5, #16]
   13ae6:	aa7a      	add	r2, sp, #488	; 0x1e8
   13ae8:	4629      	mov	r1, r5
   13aea:	4630      	mov	r0, r6
   13aec:	4798      	blx	r3
   13aee:	9b88      	ldr	r3, [sp, #544]	; 0x220
   13af0:	e9cd 4900 	strd	r4, r9, [sp]
   13af4:	4682      	mov	sl, r0
   13af6:	6463      	str	r3, [r4, #68]	; 0x44
   13af8:	4631      	mov	r1, r6
   13afa:	462b      	mov	r3, r5
   13afc:	462a      	mov	r2, r5
   13afe:	2001      	movs	r0, #1
   13b00:	47c0      	blx	r8
   13b02:	4607      	mov	r7, r0
   13b04:	b9f8      	cbnz	r0, 13b46 <unwind_phase2_forced+0xa6>
   13b06:	f44f 72f0 	mov.w	r2, #480	; 0x1e0
   13b0a:	a97a      	add	r1, sp, #488	; 0x1e8
   13b0c:	4620      	mov	r0, r4
   13b0e:	f000 fe85 	bl	1481c <memcpy>
   13b12:	f1ba 0f08 	cmp.w	sl, #8
   13b16:	d11c      	bne.n	13b52 <unwind_phase2_forced+0xb2>
   13b18:	6c21      	ldr	r1, [r4, #64]	; 0x40
   13b1a:	4628      	mov	r0, r5
   13b1c:	f7ff ff18 	bl	13950 <get_eit_entry>
   13b20:	2f00      	cmp	r7, #0
   13b22:	bf08      	it	eq
   13b24:	2609      	moveq	r6, #9
   13b26:	4607      	mov	r7, r0
   13b28:	bf18      	it	ne
   13b2a:	260a      	movne	r6, #10
   13b2c:	2800      	cmp	r0, #0
   13b2e:	d0d1      	beq.n	13ad4 <unwind_phase2_forced+0x34>
   13b30:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   13b32:	f046 0110 	orr.w	r1, r6, #16
   13b36:	e9cd 4900 	strd	r4, r9, [sp]
   13b3a:	462a      	mov	r2, r5
   13b3c:	6463      	str	r3, [r4, #68]	; 0x44
   13b3e:	2001      	movs	r0, #1
   13b40:	462b      	mov	r3, r5
   13b42:	47c0      	blx	r8
   13b44:	b100      	cbz	r0, 13b48 <unwind_phase2_forced+0xa8>
   13b46:	2709      	movs	r7, #9
   13b48:	4638      	mov	r0, r7
   13b4a:	f50d 7d72 	add.w	sp, sp, #968	; 0x3c8
   13b4e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   13b52:	f1ba 0f07 	cmp.w	sl, #7
   13b56:	d1f6      	bne.n	13b46 <unwind_phase2_forced+0xa6>
   13b58:	4638      	mov	r0, r7
   13b5a:	6c21      	ldr	r1, [r4, #64]	; 0x40
   13b5c:	f7ff ff7e 	bl	13a5c <_Unwind_DebugHook>
   13b60:	a803      	add	r0, sp, #12
   13b62:	f000 fb9d 	bl	142a0 <__restore_core_regs>
   13b66:	bf00      	nop

00013b68 <_Unwind_GetCFA>:
   13b68:	6c40      	ldr	r0, [r0, #68]	; 0x44
   13b6a:	4770      	bx	lr

00013b6c <__gnu_Unwind_RaiseException>:
   13b6c:	b5f0      	push	{r4, r5, r6, r7, lr}
   13b6e:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
   13b70:	640b      	str	r3, [r1, #64]	; 0x40
   13b72:	1d0d      	adds	r5, r1, #4
   13b74:	460f      	mov	r7, r1
   13b76:	4606      	mov	r6, r0
   13b78:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   13b7a:	b0f9      	sub	sp, #484	; 0x1e4
   13b7c:	ac01      	add	r4, sp, #4
   13b7e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   13b80:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   13b82:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   13b84:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   13b86:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   13b88:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
   13b8c:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   13b90:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
   13b94:	9500      	str	r5, [sp, #0]
   13b96:	e006      	b.n	13ba6 <__gnu_Unwind_RaiseException+0x3a>
   13b98:	6933      	ldr	r3, [r6, #16]
   13b9a:	466a      	mov	r2, sp
   13b9c:	4631      	mov	r1, r6
   13b9e:	4798      	blx	r3
   13ba0:	2808      	cmp	r0, #8
   13ba2:	4604      	mov	r4, r0
   13ba4:	d108      	bne.n	13bb8 <__gnu_Unwind_RaiseException+0x4c>
   13ba6:	9910      	ldr	r1, [sp, #64]	; 0x40
   13ba8:	4630      	mov	r0, r6
   13baa:	f7ff fed1 	bl	13950 <get_eit_entry>
   13bae:	2800      	cmp	r0, #0
   13bb0:	d0f2      	beq.n	13b98 <__gnu_Unwind_RaiseException+0x2c>
   13bb2:	2009      	movs	r0, #9
   13bb4:	b079      	add	sp, #484	; 0x1e4
   13bb6:	bdf0      	pop	{r4, r5, r6, r7, pc}
   13bb8:	4668      	mov	r0, sp
   13bba:	f7ff ff1b 	bl	139f4 <restore_non_core_regs>
   13bbe:	2c06      	cmp	r4, #6
   13bc0:	d1f7      	bne.n	13bb2 <__gnu_Unwind_RaiseException+0x46>
   13bc2:	4639      	mov	r1, r7
   13bc4:	4630      	mov	r0, r6
   13bc6:	f7ff ff4b 	bl	13a60 <unwind_phase2>
   13bca:	bf00      	nop

00013bcc <__gnu_Unwind_ForcedUnwind>:
   13bcc:	b430      	push	{r4, r5}
   13bce:	6bdd      	ldr	r5, [r3, #60]	; 0x3c
   13bd0:	60c1      	str	r1, [r0, #12]
   13bd2:	6182      	str	r2, [r0, #24]
   13bd4:	4619      	mov	r1, r3
   13bd6:	641d      	str	r5, [r3, #64]	; 0x40
   13bd8:	2200      	movs	r2, #0
   13bda:	bc30      	pop	{r4, r5}
   13bdc:	e760      	b.n	13aa0 <unwind_phase2_forced>
   13bde:	bf00      	nop

00013be0 <__gnu_Unwind_Resume>:
   13be0:	b570      	push	{r4, r5, r6, lr}
   13be2:	68c6      	ldr	r6, [r0, #12]
   13be4:	6943      	ldr	r3, [r0, #20]
   13be6:	640b      	str	r3, [r1, #64]	; 0x40
   13be8:	b9be      	cbnz	r6, 13c1a <__gnu_Unwind_Resume+0x3a>
   13bea:	6903      	ldr	r3, [r0, #16]
   13bec:	460a      	mov	r2, r1
   13bee:	4604      	mov	r4, r0
   13bf0:	460d      	mov	r5, r1
   13bf2:	4601      	mov	r1, r0
   13bf4:	2002      	movs	r0, #2
   13bf6:	4798      	blx	r3
   13bf8:	2807      	cmp	r0, #7
   13bfa:	d007      	beq.n	13c0c <__gnu_Unwind_Resume+0x2c>
   13bfc:	2808      	cmp	r0, #8
   13bfe:	d103      	bne.n	13c08 <__gnu_Unwind_Resume+0x28>
   13c00:	4629      	mov	r1, r5
   13c02:	4620      	mov	r0, r4
   13c04:	f7ff ff2c 	bl	13a60 <unwind_phase2>
   13c08:	f000 fddc 	bl	147c4 <abort>
   13c0c:	4630      	mov	r0, r6
   13c0e:	6c29      	ldr	r1, [r5, #64]	; 0x40
   13c10:	f7ff ff24 	bl	13a5c <_Unwind_DebugHook>
   13c14:	1d28      	adds	r0, r5, #4
   13c16:	f000 fb43 	bl	142a0 <__restore_core_regs>
   13c1a:	2201      	movs	r2, #1
   13c1c:	f7ff ff40 	bl	13aa0 <unwind_phase2_forced>
   13c20:	f000 fdd0 	bl	147c4 <abort>

00013c24 <__gnu_Unwind_Resume_or_Rethrow>:
   13c24:	68c2      	ldr	r2, [r0, #12]
   13c26:	b11a      	cbz	r2, 13c30 <__gnu_Unwind_Resume_or_Rethrow+0xc>
   13c28:	6bca      	ldr	r2, [r1, #60]	; 0x3c
   13c2a:	640a      	str	r2, [r1, #64]	; 0x40
   13c2c:	2200      	movs	r2, #0
   13c2e:	e737      	b.n	13aa0 <unwind_phase2_forced>
   13c30:	e79c      	b.n	13b6c <__gnu_Unwind_RaiseException>
   13c32:	bf00      	nop

00013c34 <_Unwind_Complete>:
   13c34:	4770      	bx	lr
   13c36:	bf00      	nop

00013c38 <_Unwind_DeleteException>:
   13c38:	6883      	ldr	r3, [r0, #8]
   13c3a:	b113      	cbz	r3, 13c42 <_Unwind_DeleteException+0xa>
   13c3c:	4601      	mov	r1, r0
   13c3e:	2001      	movs	r0, #1
   13c40:	4718      	bx	r3
   13c42:	4770      	bx	lr

00013c44 <_Unwind_VRS_Get>:
   13c44:	2904      	cmp	r1, #4
   13c46:	d807      	bhi.n	13c58 <_Unwind_VRS_Get+0x14>
   13c48:	e8df f001 	tbb	[pc, r1]
   13c4c:	08060803 	.word	0x08060803
   13c50:	08          	.byte	0x08
   13c51:	00          	.byte	0x00
   13c52:	b90b      	cbnz	r3, 13c58 <_Unwind_VRS_Get+0x14>
   13c54:	2a0f      	cmp	r2, #15
   13c56:	d903      	bls.n	13c60 <_Unwind_VRS_Get+0x1c>
   13c58:	2002      	movs	r0, #2
   13c5a:	4770      	bx	lr
   13c5c:	2001      	movs	r0, #1
   13c5e:	4770      	bx	lr
   13c60:	eb00 0282 	add.w	r2, r0, r2, lsl #2
   13c64:	4618      	mov	r0, r3
   13c66:	6853      	ldr	r3, [r2, #4]
   13c68:	9a00      	ldr	r2, [sp, #0]
   13c6a:	6013      	str	r3, [r2, #0]
   13c6c:	4770      	bx	lr
   13c6e:	bf00      	nop

00013c70 <_Unwind_GetGR>:
   13c70:	b510      	push	{r4, lr}
   13c72:	b084      	sub	sp, #16
   13c74:	2300      	movs	r3, #0
   13c76:	ac03      	add	r4, sp, #12
   13c78:	460a      	mov	r2, r1
   13c7a:	9400      	str	r4, [sp, #0]
   13c7c:	4619      	mov	r1, r3
   13c7e:	f7ff ffe1 	bl	13c44 <_Unwind_VRS_Get>
   13c82:	9803      	ldr	r0, [sp, #12]
   13c84:	b004      	add	sp, #16
   13c86:	bd10      	pop	{r4, pc}

00013c88 <_Unwind_VRS_Set>:
   13c88:	2904      	cmp	r1, #4
   13c8a:	d807      	bhi.n	13c9c <_Unwind_VRS_Set+0x14>
   13c8c:	e8df f001 	tbb	[pc, r1]
   13c90:	08060803 	.word	0x08060803
   13c94:	08          	.byte	0x08
   13c95:	00          	.byte	0x00
   13c96:	b90b      	cbnz	r3, 13c9c <_Unwind_VRS_Set+0x14>
   13c98:	2a0f      	cmp	r2, #15
   13c9a:	d903      	bls.n	13ca4 <_Unwind_VRS_Set+0x1c>
   13c9c:	2002      	movs	r0, #2
   13c9e:	4770      	bx	lr
   13ca0:	2001      	movs	r0, #1
   13ca2:	4770      	bx	lr
   13ca4:	eb00 0082 	add.w	r0, r0, r2, lsl #2
   13ca8:	9a00      	ldr	r2, [sp, #0]
   13caa:	6812      	ldr	r2, [r2, #0]
   13cac:	6042      	str	r2, [r0, #4]
   13cae:	4618      	mov	r0, r3
   13cb0:	4770      	bx	lr
   13cb2:	bf00      	nop

00013cb4 <_Unwind_SetGR>:
   13cb4:	b510      	push	{r4, lr}
   13cb6:	b084      	sub	sp, #16
   13cb8:	ac04      	add	r4, sp, #16
   13cba:	2300      	movs	r3, #0
   13cbc:	f844 2d04 	str.w	r2, [r4, #-4]!
   13cc0:	460a      	mov	r2, r1
   13cc2:	9400      	str	r4, [sp, #0]
   13cc4:	4619      	mov	r1, r3
   13cc6:	f7ff ffdf 	bl	13c88 <_Unwind_VRS_Set>
   13cca:	b004      	add	sp, #16
   13ccc:	bd10      	pop	{r4, pc}
   13cce:	bf00      	nop

00013cd0 <__gnu_Unwind_Backtrace>:
   13cd0:	b5f0      	push	{r4, r5, r6, r7, lr}
   13cd2:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
   13cd4:	6413      	str	r3, [r2, #64]	; 0x40
   13cd6:	1d15      	adds	r5, r2, #4
   13cd8:	4607      	mov	r7, r0
   13cda:	460e      	mov	r6, r1
   13cdc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   13cde:	f5ad 7d0f 	sub.w	sp, sp, #572	; 0x23c
   13ce2:	ac17      	add	r4, sp, #92	; 0x5c
   13ce4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   13ce6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   13ce8:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   13cea:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   13cec:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   13cee:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
   13cf2:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   13cf6:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
   13cfa:	9516      	str	r5, [sp, #88]	; 0x58
   13cfc:	e010      	b.n	13d20 <__gnu_Unwind_Backtrace+0x50>
   13cfe:	a816      	add	r0, sp, #88	; 0x58
   13d00:	f7ff ffd8 	bl	13cb4 <_Unwind_SetGR>
   13d04:	4631      	mov	r1, r6
   13d06:	a816      	add	r0, sp, #88	; 0x58
   13d08:	47b8      	blx	r7
   13d0a:	aa16      	add	r2, sp, #88	; 0x58
   13d0c:	4669      	mov	r1, sp
   13d0e:	b978      	cbnz	r0, 13d30 <__gnu_Unwind_Backtrace+0x60>
   13d10:	9b04      	ldr	r3, [sp, #16]
   13d12:	2008      	movs	r0, #8
   13d14:	4798      	blx	r3
   13d16:	2805      	cmp	r0, #5
   13d18:	4604      	mov	r4, r0
   13d1a:	d00a      	beq.n	13d32 <__gnu_Unwind_Backtrace+0x62>
   13d1c:	2809      	cmp	r0, #9
   13d1e:	d007      	beq.n	13d30 <__gnu_Unwind_Backtrace+0x60>
   13d20:	9926      	ldr	r1, [sp, #152]	; 0x98
   13d22:	4668      	mov	r0, sp
   13d24:	f7ff fe14 	bl	13950 <get_eit_entry>
   13d28:	466a      	mov	r2, sp
   13d2a:	210c      	movs	r1, #12
   13d2c:	2800      	cmp	r0, #0
   13d2e:	d0e6      	beq.n	13cfe <__gnu_Unwind_Backtrace+0x2e>
   13d30:	2409      	movs	r4, #9
   13d32:	a816      	add	r0, sp, #88	; 0x58
   13d34:	f7ff fe5e 	bl	139f4 <restore_non_core_regs>
   13d38:	4620      	mov	r0, r4
   13d3a:	f50d 7d0f 	add.w	sp, sp, #572	; 0x23c
   13d3e:	bdf0      	pop	{r4, r5, r6, r7, pc}

00013d40 <__gnu_unwind_pr_common>:
   13d40:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   13d44:	460d      	mov	r5, r1
   13d46:	6cc9      	ldr	r1, [r1, #76]	; 0x4c
   13d48:	b089      	sub	sp, #36	; 0x24
   13d4a:	1d0c      	adds	r4, r1, #4
   13d4c:	4616      	mov	r6, r2
   13d4e:	f000 0b03 	and.w	fp, r0, #3
   13d52:	680a      	ldr	r2, [r1, #0]
   13d54:	9406      	str	r4, [sp, #24]
   13d56:	461f      	mov	r7, r3
   13d58:	2b00      	cmp	r3, #0
   13d5a:	d068      	beq.n	13e2e <__gnu_unwind_pr_common+0xee>
   13d5c:	0c13      	lsrs	r3, r2, #16
   13d5e:	b2d9      	uxtb	r1, r3
   13d60:	0412      	lsls	r2, r2, #16
   13d62:	f88d 301d 	strb.w	r3, [sp, #29]
   13d66:	2302      	movs	r3, #2
   13d68:	eb04 0481 	add.w	r4, r4, r1, lsl #2
   13d6c:	9205      	str	r2, [sp, #20]
   13d6e:	f88d 301c 	strb.w	r3, [sp, #28]
   13d72:	6d2b      	ldr	r3, [r5, #80]	; 0x50
   13d74:	f1bb 0f02 	cmp.w	fp, #2
   13d78:	bf08      	it	eq
   13d7a:	6bac      	ldreq	r4, [r5, #56]	; 0x38
   13d7c:	f013 0301 	ands.w	r3, r3, #1
   13d80:	d146      	bne.n	13e10 <__gnu_unwind_pr_common+0xd0>
   13d82:	9301      	str	r3, [sp, #4]
   13d84:	f000 0308 	and.w	r3, r0, #8
   13d88:	9300      	str	r3, [sp, #0]
   13d8a:	f8d4 9000 	ldr.w	r9, [r4]
   13d8e:	f1b9 0f00 	cmp.w	r9, #0
   13d92:	f000 80f3 	beq.w	13f7c <__gnu_unwind_pr_common+0x23c>
   13d96:	2f02      	cmp	r7, #2
   13d98:	d045      	beq.n	13e26 <__gnu_unwind_pr_common+0xe6>
   13d9a:	f8b4 9000 	ldrh.w	r9, [r4]
   13d9e:	f8b4 8002 	ldrh.w	r8, [r4, #2]
   13da2:	3404      	adds	r4, #4
   13da4:	6cab      	ldr	r3, [r5, #72]	; 0x48
   13da6:	f028 0a01 	bic.w	sl, r8, #1
   13daa:	210f      	movs	r1, #15
   13dac:	4630      	mov	r0, r6
   13dae:	449a      	add	sl, r3
   13db0:	f7ff ff5e 	bl	13c70 <_Unwind_GetGR>
   13db4:	4582      	cmp	sl, r0
   13db6:	d834      	bhi.n	13e22 <__gnu_unwind_pr_common+0xe2>
   13db8:	f029 0301 	bic.w	r3, r9, #1
   13dbc:	4453      	add	r3, sl
   13dbe:	4283      	cmp	r3, r0
   13dc0:	bf94      	ite	ls
   13dc2:	2000      	movls	r0, #0
   13dc4:	2001      	movhi	r0, #1
   13dc6:	ea4f 0848 	mov.w	r8, r8, lsl #1
   13dca:	f008 0802 	and.w	r8, r8, #2
   13dce:	f009 0901 	and.w	r9, r9, #1
   13dd2:	ea48 0809 	orr.w	r8, r8, r9
   13dd6:	f1b8 0f01 	cmp.w	r8, #1
   13dda:	d03a      	beq.n	13e52 <__gnu_unwind_pr_common+0x112>
   13ddc:	d331      	bcc.n	13e42 <__gnu_unwind_pr_common+0x102>
   13dde:	f1b8 0f02 	cmp.w	r8, #2
   13de2:	d11a      	bne.n	13e1a <__gnu_unwind_pr_common+0xda>
   13de4:	6823      	ldr	r3, [r4, #0]
   13de6:	f023 4a00 	bic.w	sl, r3, #2147483648	; 0x80000000
   13dea:	f1bb 0f00 	cmp.w	fp, #0
   13dee:	d166      	bne.n	13ebe <__gnu_unwind_pr_common+0x17e>
   13df0:	b130      	cbz	r0, 13e00 <__gnu_unwind_pr_common+0xc0>
   13df2:	9a00      	ldr	r2, [sp, #0]
   13df4:	2a00      	cmp	r2, #0
   13df6:	d06c      	beq.n	13ed2 <__gnu_unwind_pr_common+0x192>
   13df8:	f1ba 0f00 	cmp.w	sl, #0
   13dfc:	f000 8090 	beq.w	13f20 <__gnu_unwind_pr_common+0x1e0>
   13e00:	2b00      	cmp	r3, #0
   13e02:	da00      	bge.n	13e06 <__gnu_unwind_pr_common+0xc6>
   13e04:	3404      	adds	r4, #4
   13e06:	f10a 0301 	add.w	r3, sl, #1
   13e0a:	eb04 0483 	add.w	r4, r4, r3, lsl #2
   13e0e:	e7bc      	b.n	13d8a <__gnu_unwind_pr_common+0x4a>
   13e10:	4630      	mov	r0, r6
   13e12:	a905      	add	r1, sp, #20
   13e14:	f000 fb46 	bl	144a4 <__gnu_unwind_execute>
   13e18:	b178      	cbz	r0, 13e3a <__gnu_unwind_pr_common+0xfa>
   13e1a:	2009      	movs	r0, #9
   13e1c:	b009      	add	sp, #36	; 0x24
   13e1e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   13e22:	2000      	movs	r0, #0
   13e24:	e7cf      	b.n	13dc6 <__gnu_unwind_pr_common+0x86>
   13e26:	f8d4 8004 	ldr.w	r8, [r4, #4]
   13e2a:	3408      	adds	r4, #8
   13e2c:	e7ba      	b.n	13da4 <__gnu_unwind_pr_common+0x64>
   13e2e:	0212      	lsls	r2, r2, #8
   13e30:	2303      	movs	r3, #3
   13e32:	9205      	str	r2, [sp, #20]
   13e34:	f8ad 301c 	strh.w	r3, [sp, #28]
   13e38:	e79b      	b.n	13d72 <__gnu_unwind_pr_common+0x32>
   13e3a:	2008      	movs	r0, #8
   13e3c:	b009      	add	sp, #36	; 0x24
   13e3e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   13e42:	f1bb 0f00 	cmp.w	fp, #0
   13e46:	d002      	beq.n	13e4e <__gnu_unwind_pr_common+0x10e>
   13e48:	2800      	cmp	r0, #0
   13e4a:	f040 80b4 	bne.w	13fb6 <__gnu_unwind_pr_common+0x276>
   13e4e:	3404      	adds	r4, #4
   13e50:	e79b      	b.n	13d8a <__gnu_unwind_pr_common+0x4a>
   13e52:	f1bb 0f00 	cmp.w	fp, #0
   13e56:	d118      	bne.n	13e8a <__gnu_unwind_pr_common+0x14a>
   13e58:	b1a8      	cbz	r0, 13e86 <__gnu_unwind_pr_common+0x146>
   13e5a:	e9d4 2300 	ldrd	r2, r3, [r4]
   13e5e:	1c99      	adds	r1, r3, #2
   13e60:	ea4f 72d2 	mov.w	r2, r2, lsr #31
   13e64:	d0d9      	beq.n	13e1a <__gnu_unwind_pr_common+0xda>
   13e66:	f105 0158 	add.w	r1, r5, #88	; 0x58
   13e6a:	3301      	adds	r3, #1
   13e6c:	9104      	str	r1, [sp, #16]
   13e6e:	f000 80b5 	beq.w	13fdc <__gnu_unwind_pr_common+0x29c>
   13e72:	1d20      	adds	r0, r4, #4
   13e74:	f7ff fdea 	bl	13a4c <_Unwind_decode_typeinfo_ptr.isra.0>
   13e78:	ab04      	add	r3, sp, #16
   13e7a:	4601      	mov	r1, r0
   13e7c:	4628      	mov	r0, r5
   13e7e:	f3af 8000 	nop.w
   13e82:	2800      	cmp	r0, #0
   13e84:	d167      	bne.n	13f56 <__gnu_unwind_pr_common+0x216>
   13e86:	3408      	adds	r4, #8
   13e88:	e77f      	b.n	13d8a <__gnu_unwind_pr_common+0x4a>
   13e8a:	210d      	movs	r1, #13
   13e8c:	4630      	mov	r0, r6
   13e8e:	f8d5 8020 	ldr.w	r8, [r5, #32]
   13e92:	f7ff feed 	bl	13c70 <_Unwind_GetGR>
   13e96:	4580      	cmp	r8, r0
   13e98:	d1f5      	bne.n	13e86 <__gnu_unwind_pr_common+0x146>
   13e9a:	6aab      	ldr	r3, [r5, #40]	; 0x28
   13e9c:	429c      	cmp	r4, r3
   13e9e:	d1f2      	bne.n	13e86 <__gnu_unwind_pr_common+0x146>
   13ea0:	4620      	mov	r0, r4
   13ea2:	f7ff fd07 	bl	138b4 <selfrel_offset31>
   13ea6:	210f      	movs	r1, #15
   13ea8:	4602      	mov	r2, r0
   13eaa:	4630      	mov	r0, r6
   13eac:	f7ff ff02 	bl	13cb4 <_Unwind_SetGR>
   13eb0:	4630      	mov	r0, r6
   13eb2:	462a      	mov	r2, r5
   13eb4:	2100      	movs	r1, #0
   13eb6:	f7ff fefd 	bl	13cb4 <_Unwind_SetGR>
   13eba:	2007      	movs	r0, #7
   13ebc:	e7ae      	b.n	13e1c <__gnu_unwind_pr_common+0xdc>
   13ebe:	210d      	movs	r1, #13
   13ec0:	4630      	mov	r0, r6
   13ec2:	f8d5 8020 	ldr.w	r8, [r5, #32]
   13ec6:	f7ff fed3 	bl	13c70 <_Unwind_GetGR>
   13eca:	4580      	cmp	r8, r0
   13ecc:	d032      	beq.n	13f34 <__gnu_unwind_pr_common+0x1f4>
   13ece:	6823      	ldr	r3, [r4, #0]
   13ed0:	e796      	b.n	13e00 <__gnu_unwind_pr_common+0xc0>
   13ed2:	f1ba 0f00 	cmp.w	sl, #0
   13ed6:	d023      	beq.n	13f20 <__gnu_unwind_pr_common+0x1e0>
   13ed8:	f105 0358 	add.w	r3, r5, #88	; 0x58
   13edc:	f104 0804 	add.w	r8, r4, #4
   13ee0:	f8cd b008 	str.w	fp, [sp, #8]
   13ee4:	f8dd 9000 	ldr.w	r9, [sp]
   13ee8:	9703      	str	r7, [sp, #12]
   13eea:	46a3      	mov	fp, r4
   13eec:	461c      	mov	r4, r3
   13eee:	e002      	b.n	13ef6 <__gnu_unwind_pr_common+0x1b6>
   13ef0:	4557      	cmp	r7, sl
   13ef2:	46b9      	mov	r9, r7
   13ef4:	d040      	beq.n	13f78 <__gnu_unwind_pr_common+0x238>
   13ef6:	4640      	mov	r0, r8
   13ef8:	9404      	str	r4, [sp, #16]
   13efa:	f7ff fda7 	bl	13a4c <_Unwind_decode_typeinfo_ptr.isra.0>
   13efe:	ab04      	add	r3, sp, #16
   13f00:	4601      	mov	r1, r0
   13f02:	2200      	movs	r2, #0
   13f04:	4628      	mov	r0, r5
   13f06:	f3af 8000 	nop.w
   13f0a:	f109 0701 	add.w	r7, r9, #1
   13f0e:	f108 0804 	add.w	r8, r8, #4
   13f12:	2800      	cmp	r0, #0
   13f14:	d0ec      	beq.n	13ef0 <__gnu_unwind_pr_common+0x1b0>
   13f16:	45d1      	cmp	r9, sl
   13f18:	465c      	mov	r4, fp
   13f1a:	e9dd b702 	ldrd	fp, r7, [sp, #8]
   13f1e:	d1d6      	bne.n	13ece <__gnu_unwind_pr_common+0x18e>
   13f20:	4630      	mov	r0, r6
   13f22:	210d      	movs	r1, #13
   13f24:	f7ff fea4 	bl	13c70 <_Unwind_GetGR>
   13f28:	9b04      	ldr	r3, [sp, #16]
   13f2a:	6228      	str	r0, [r5, #32]
   13f2c:	e9c5 3409 	strd	r3, r4, [r5, #36]	; 0x24
   13f30:	2006      	movs	r0, #6
   13f32:	e773      	b.n	13e1c <__gnu_unwind_pr_common+0xdc>
   13f34:	6aab      	ldr	r3, [r5, #40]	; 0x28
   13f36:	429c      	cmp	r4, r3
   13f38:	d1c9      	bne.n	13ece <__gnu_unwind_pr_common+0x18e>
   13f3a:	2204      	movs	r2, #4
   13f3c:	f04f 0800 	mov.w	r8, #0
   13f40:	18a3      	adds	r3, r4, r2
   13f42:	e9c5 a80a 	strd	sl, r8, [r5, #40]	; 0x28
   13f46:	e9c5 230c 	strd	r2, r3, [r5, #48]	; 0x30
   13f4a:	6823      	ldr	r3, [r4, #0]
   13f4c:	4543      	cmp	r3, r8
   13f4e:	db4d      	blt.n	13fec <__gnu_unwind_pr_common+0x2ac>
   13f50:	2301      	movs	r3, #1
   13f52:	9301      	str	r3, [sp, #4]
   13f54:	e757      	b.n	13e06 <__gnu_unwind_pr_common+0xc6>
   13f56:	4680      	mov	r8, r0
   13f58:	210d      	movs	r1, #13
   13f5a:	4630      	mov	r0, r6
   13f5c:	f7ff fe88 	bl	13c70 <_Unwind_GetGR>
   13f60:	f1b8 0f02 	cmp.w	r8, #2
   13f64:	6228      	str	r0, [r5, #32]
   13f66:	d13e      	bne.n	13fe6 <__gnu_unwind_pr_common+0x2a6>
   13f68:	462b      	mov	r3, r5
   13f6a:	9a04      	ldr	r2, [sp, #16]
   13f6c:	f843 2f2c 	str.w	r2, [r3, #44]!
   13f70:	626b      	str	r3, [r5, #36]	; 0x24
   13f72:	62ac      	str	r4, [r5, #40]	; 0x28
   13f74:	2006      	movs	r0, #6
   13f76:	e751      	b.n	13e1c <__gnu_unwind_pr_common+0xdc>
   13f78:	465c      	mov	r4, fp
   13f7a:	e7d1      	b.n	13f20 <__gnu_unwind_pr_common+0x1e0>
   13f7c:	a905      	add	r1, sp, #20
   13f7e:	4630      	mov	r0, r6
   13f80:	f000 fa90 	bl	144a4 <__gnu_unwind_execute>
   13f84:	2800      	cmp	r0, #0
   13f86:	f47f af48 	bne.w	13e1a <__gnu_unwind_pr_common+0xda>
   13f8a:	9b01      	ldr	r3, [sp, #4]
   13f8c:	2b00      	cmp	r3, #0
   13f8e:	f43f af54 	beq.w	13e3a <__gnu_unwind_pr_common+0xfa>
   13f92:	210f      	movs	r1, #15
   13f94:	4630      	mov	r0, r6
   13f96:	f7ff fe6b 	bl	13c70 <_Unwind_GetGR>
   13f9a:	210e      	movs	r1, #14
   13f9c:	4602      	mov	r2, r0
   13f9e:	4630      	mov	r0, r6
   13fa0:	f7ff fe88 	bl	13cb4 <_Unwind_SetGR>
   13fa4:	4630      	mov	r0, r6
   13fa6:	4a1a      	ldr	r2, [pc, #104]	; (14010 <__gnu_unwind_pr_common+0x2d0>)
   13fa8:	210f      	movs	r1, #15
   13faa:	f7ff fe83 	bl	13cb4 <_Unwind_SetGR>
   13fae:	2007      	movs	r0, #7
   13fb0:	b009      	add	sp, #36	; 0x24
   13fb2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   13fb6:	4620      	mov	r0, r4
   13fb8:	f7ff fc7c 	bl	138b4 <selfrel_offset31>
   13fbc:	3404      	adds	r4, #4
   13fbe:	4607      	mov	r7, r0
   13fc0:	63ac      	str	r4, [r5, #56]	; 0x38
   13fc2:	4628      	mov	r0, r5
   13fc4:	f3af 8000 	nop.w
   13fc8:	2800      	cmp	r0, #0
   13fca:	f43f af26 	beq.w	13e1a <__gnu_unwind_pr_common+0xda>
   13fce:	4630      	mov	r0, r6
   13fd0:	463a      	mov	r2, r7
   13fd2:	210f      	movs	r1, #15
   13fd4:	f7ff fe6e 	bl	13cb4 <_Unwind_SetGR>
   13fd8:	2007      	movs	r0, #7
   13fda:	e71f      	b.n	13e1c <__gnu_unwind_pr_common+0xdc>
   13fdc:	4630      	mov	r0, r6
   13fde:	210d      	movs	r1, #13
   13fe0:	f7ff fe46 	bl	13c70 <_Unwind_GetGR>
   13fe4:	6228      	str	r0, [r5, #32]
   13fe6:	9b04      	ldr	r3, [sp, #16]
   13fe8:	626b      	str	r3, [r5, #36]	; 0x24
   13fea:	e7c2      	b.n	13f72 <__gnu_unwind_pr_common+0x232>
   13fec:	f10a 0001 	add.w	r0, sl, #1
   13ff0:	eb04 0080 	add.w	r0, r4, r0, lsl #2
   13ff4:	f7ff fc5e 	bl	138b4 <selfrel_offset31>
   13ff8:	210f      	movs	r1, #15
   13ffa:	4602      	mov	r2, r0
   13ffc:	4630      	mov	r0, r6
   13ffe:	f7ff fe59 	bl	13cb4 <_Unwind_SetGR>
   14002:	4630      	mov	r0, r6
   14004:	462a      	mov	r2, r5
   14006:	4641      	mov	r1, r8
   14008:	f7ff fe54 	bl	13cb4 <_Unwind_SetGR>
   1400c:	2007      	movs	r0, #7
   1400e:	e705      	b.n	13e1c <__gnu_unwind_pr_common+0xdc>
   14010:	00000000 	.word	0x00000000

00014014 <__aeabi_unwind_cpp_pr0>:
   14014:	2300      	movs	r3, #0
   14016:	e693      	b.n	13d40 <__gnu_unwind_pr_common>

00014018 <__aeabi_unwind_cpp_pr1>:
   14018:	2301      	movs	r3, #1
   1401a:	e691      	b.n	13d40 <__gnu_unwind_pr_common>

0001401c <__aeabi_unwind_cpp_pr2>:
   1401c:	2302      	movs	r3, #2
   1401e:	e68f      	b.n	13d40 <__gnu_unwind_pr_common>

00014020 <_Unwind_VRS_Pop>:
   14020:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   14024:	4605      	mov	r5, r0
   14026:	b0c4      	sub	sp, #272	; 0x110
   14028:	2904      	cmp	r1, #4
   1402a:	d806      	bhi.n	1403a <_Unwind_VRS_Pop+0x1a>
   1402c:	e8df f001 	tbb	[pc, r1]
   14030:	03052b4d 	.word	0x03052b4d
   14034:	09          	.byte	0x09
   14035:	00          	.byte	0x00
   14036:	2b03      	cmp	r3, #3
   14038:	d05f      	beq.n	140fa <_Unwind_VRS_Pop+0xda>
   1403a:	2002      	movs	r0, #2
   1403c:	b044      	add	sp, #272	; 0x110
   1403e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   14042:	2b00      	cmp	r3, #0
   14044:	d1f9      	bne.n	1403a <_Unwind_VRS_Pop+0x1a>
   14046:	2a10      	cmp	r2, #16
   14048:	d8f7      	bhi.n	1403a <_Unwind_VRS_Pop+0x1a>
   1404a:	682b      	ldr	r3, [r5, #0]
   1404c:	06dc      	lsls	r4, r3, #27
   1404e:	f100 80f4 	bmi.w	1423a <_Unwind_VRS_Pop+0x21a>
   14052:	ac22      	add	r4, sp, #136	; 0x88
   14054:	4620      	mov	r0, r4
   14056:	9201      	str	r2, [sp, #4]
   14058:	f000 f994 	bl	14384 <__gnu_Unwind_Save_WMMXC>
   1405c:	6ba8      	ldr	r0, [r5, #56]	; 0x38
   1405e:	9a01      	ldr	r2, [sp, #4]
   14060:	2300      	movs	r3, #0
   14062:	2601      	movs	r6, #1
   14064:	fa06 f103 	lsl.w	r1, r6, r3
   14068:	4211      	tst	r1, r2
   1406a:	d003      	beq.n	14074 <_Unwind_VRS_Pop+0x54>
   1406c:	6801      	ldr	r1, [r0, #0]
   1406e:	f844 1023 	str.w	r1, [r4, r3, lsl #2]
   14072:	3004      	adds	r0, #4
   14074:	3301      	adds	r3, #1
   14076:	2b04      	cmp	r3, #4
   14078:	d1f4      	bne.n	14064 <_Unwind_VRS_Pop+0x44>
   1407a:	63a8      	str	r0, [r5, #56]	; 0x38
   1407c:	4620      	mov	r0, r4
   1407e:	f000 f977 	bl	14370 <__gnu_Unwind_Restore_WMMXC>
   14082:	2000      	movs	r0, #0
   14084:	e7da      	b.n	1403c <_Unwind_VRS_Pop+0x1c>
   14086:	2b01      	cmp	r3, #1
   14088:	ea4f 4612 	mov.w	r6, r2, lsr #16
   1408c:	b297      	uxth	r7, r2
   1408e:	d052      	beq.n	14136 <_Unwind_VRS_Pop+0x116>
   14090:	2b05      	cmp	r3, #5
   14092:	d1d2      	bne.n	1403a <_Unwind_VRS_Pop+0x1a>
   14094:	eb06 0807 	add.w	r8, r6, r7
   14098:	f1b8 0f20 	cmp.w	r8, #32
   1409c:	d8cd      	bhi.n	1403a <_Unwind_VRS_Pop+0x1a>
   1409e:	2e0f      	cmp	r6, #15
   140a0:	f240 8099 	bls.w	141d6 <_Unwind_VRS_Pop+0x1b6>
   140a4:	46b8      	mov	r8, r7
   140a6:	2f00      	cmp	r7, #0
   140a8:	f040 80db 	bne.w	14262 <_Unwind_VRS_Pop+0x242>
   140ac:	6baa      	ldr	r2, [r5, #56]	; 0x38
   140ae:	63aa      	str	r2, [r5, #56]	; 0x38
   140b0:	2e0f      	cmp	r6, #15
   140b2:	f240 80be 	bls.w	14232 <_Unwind_VRS_Pop+0x212>
   140b6:	f1b8 0f00 	cmp.w	r8, #0
   140ba:	d002      	beq.n	140c2 <_Unwind_VRS_Pop+0xa2>
   140bc:	a802      	add	r0, sp, #8
   140be:	f000 f90b 	bl	142d8 <__gnu_Unwind_Restore_VFP_D_16_to_31>
   140c2:	2000      	movs	r0, #0
   140c4:	b044      	add	sp, #272	; 0x110
   140c6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   140ca:	2b00      	cmp	r3, #0
   140cc:	d1b5      	bne.n	1403a <_Unwind_VRS_Pop+0x1a>
   140ce:	6bac      	ldr	r4, [r5, #56]	; 0x38
   140d0:	b297      	uxth	r7, r2
   140d2:	1d28      	adds	r0, r5, #4
   140d4:	2601      	movs	r6, #1
   140d6:	fa06 f103 	lsl.w	r1, r6, r3
   140da:	4239      	tst	r1, r7
   140dc:	f103 0301 	add.w	r3, r3, #1
   140e0:	d002      	beq.n	140e8 <_Unwind_VRS_Pop+0xc8>
   140e2:	6821      	ldr	r1, [r4, #0]
   140e4:	6001      	str	r1, [r0, #0]
   140e6:	3404      	adds	r4, #4
   140e8:	2b10      	cmp	r3, #16
   140ea:	f100 0004 	add.w	r0, r0, #4
   140ee:	d1f2      	bne.n	140d6 <_Unwind_VRS_Pop+0xb6>
   140f0:	f412 5000 	ands.w	r0, r2, #8192	; 0x2000
   140f4:	d1e5      	bne.n	140c2 <_Unwind_VRS_Pop+0xa2>
   140f6:	63ac      	str	r4, [r5, #56]	; 0x38
   140f8:	e7a0      	b.n	1403c <_Unwind_VRS_Pop+0x1c>
   140fa:	0c16      	lsrs	r6, r2, #16
   140fc:	b297      	uxth	r7, r2
   140fe:	19f3      	adds	r3, r6, r7
   14100:	2b10      	cmp	r3, #16
   14102:	d89a      	bhi.n	1403a <_Unwind_VRS_Pop+0x1a>
   14104:	682b      	ldr	r3, [r5, #0]
   14106:	071a      	lsls	r2, r3, #28
   14108:	d45d      	bmi.n	141c6 <_Unwind_VRS_Pop+0x1a6>
   1410a:	ac22      	add	r4, sp, #136	; 0x88
   1410c:	4620      	mov	r0, r4
   1410e:	f000 f90d 	bl	1432c <__gnu_Unwind_Save_WMMXD>
   14112:	eb04 01c6 	add.w	r1, r4, r6, lsl #3
   14116:	6bab      	ldr	r3, [r5, #56]	; 0x38
   14118:	b13f      	cbz	r7, 1412a <_Unwind_VRS_Pop+0x10a>
   1411a:	eb03 02c7 	add.w	r2, r3, r7, lsl #3
   1411e:	6818      	ldr	r0, [r3, #0]
   14120:	f841 0b04 	str.w	r0, [r1], #4
   14124:	3304      	adds	r3, #4
   14126:	4293      	cmp	r3, r2
   14128:	d1f9      	bne.n	1411e <_Unwind_VRS_Pop+0xfe>
   1412a:	4620      	mov	r0, r4
   1412c:	63ab      	str	r3, [r5, #56]	; 0x38
   1412e:	f000 f8db 	bl	142e8 <__gnu_Unwind_Restore_WMMXD>
   14132:	2000      	movs	r0, #0
   14134:	e782      	b.n	1403c <_Unwind_VRS_Pop+0x1c>
   14136:	19f2      	adds	r2, r6, r7
   14138:	2a10      	cmp	r2, #16
   1413a:	f63f af7e 	bhi.w	1403a <_Unwind_VRS_Pop+0x1a>
   1413e:	2e0f      	cmp	r6, #15
   14140:	f63f af7b 	bhi.w	1403a <_Unwind_VRS_Pop+0x1a>
   14144:	682a      	ldr	r2, [r5, #0]
   14146:	07d1      	lsls	r1, r2, #31
   14148:	d508      	bpl.n	1415c <_Unwind_VRS_Pop+0x13c>
   1414a:	4628      	mov	r0, r5
   1414c:	f022 0203 	bic.w	r2, r2, #3
   14150:	f840 2b48 	str.w	r2, [r0], #72
   14154:	9301      	str	r3, [sp, #4]
   14156:	f000 f8b3 	bl	142c0 <__gnu_Unwind_Save_VFP>
   1415a:	9b01      	ldr	r3, [sp, #4]
   1415c:	9301      	str	r3, [sp, #4]
   1415e:	ac22      	add	r4, sp, #136	; 0x88
   14160:	4620      	mov	r0, r4
   14162:	f000 f8ad 	bl	142c0 <__gnu_Unwind_Save_VFP>
   14166:	6ba9      	ldr	r1, [r5, #56]	; 0x38
   14168:	9b01      	ldr	r3, [sp, #4]
   1416a:	2f00      	cmp	r7, #0
   1416c:	f000 8095 	beq.w	1429a <_Unwind_VRS_Pop+0x27a>
   14170:	007f      	lsls	r7, r7, #1
   14172:	eb04 04c6 	add.w	r4, r4, r6, lsl #3
   14176:	f04f 0800 	mov.w	r8, #0
   1417a:	3c04      	subs	r4, #4
   1417c:	eb01 0287 	add.w	r2, r1, r7, lsl #2
   14180:	f851 0b04 	ldr.w	r0, [r1], #4
   14184:	f844 0f04 	str.w	r0, [r4, #4]!
   14188:	4291      	cmp	r1, r2
   1418a:	d1f9      	bne.n	14180 <_Unwind_VRS_Pop+0x160>
   1418c:	f1b8 0f00 	cmp.w	r8, #0
   14190:	d00f      	beq.n	141b2 <_Unwind_VRS_Pop+0x192>
   14192:	ac02      	add	r4, sp, #8
   14194:	2e10      	cmp	r6, #16
   14196:	4631      	mov	r1, r6
   14198:	bf38      	it	cc
   1419a:	2110      	movcc	r1, #16
   1419c:	eb04 01c1 	add.w	r1, r4, r1, lsl #3
   141a0:	3984      	subs	r1, #132	; 0x84
   141a2:	eb02 04c8 	add.w	r4, r2, r8, lsl #3
   141a6:	f852 0b04 	ldr.w	r0, [r2], #4
   141aa:	f841 0f04 	str.w	r0, [r1, #4]!
   141ae:	4294      	cmp	r4, r2
   141b0:	d1f9      	bne.n	141a6 <_Unwind_VRS_Pop+0x186>
   141b2:	2b01      	cmp	r3, #1
   141b4:	f47f af7b 	bne.w	140ae <_Unwind_VRS_Pop+0x8e>
   141b8:	ac22      	add	r4, sp, #136	; 0x88
   141ba:	3204      	adds	r2, #4
   141bc:	63aa      	str	r2, [r5, #56]	; 0x38
   141be:	4620      	mov	r0, r4
   141c0:	f000 f87a 	bl	142b8 <__gnu_Unwind_Restore_VFP>
   141c4:	e77d      	b.n	140c2 <_Unwind_VRS_Pop+0xa2>
   141c6:	f023 0308 	bic.w	r3, r3, #8
   141ca:	602b      	str	r3, [r5, #0]
   141cc:	f505 70a8 	add.w	r0, r5, #336	; 0x150
   141d0:	f000 f8ac 	bl	1432c <__gnu_Unwind_Save_WMMXD>
   141d4:	e799      	b.n	1410a <_Unwind_VRS_Pop+0xea>
   141d6:	f1b8 0f10 	cmp.w	r8, #16
   141da:	682a      	ldr	r2, [r5, #0]
   141dc:	d943      	bls.n	14266 <_Unwind_VRS_Pop+0x246>
   141de:	07d0      	lsls	r0, r2, #31
   141e0:	f1a8 0810 	sub.w	r8, r8, #16
   141e4:	d50b      	bpl.n	141fe <_Unwind_VRS_Pop+0x1de>
   141e6:	4628      	mov	r0, r5
   141e8:	f022 0201 	bic.w	r2, r2, #1
   141ec:	f042 0202 	orr.w	r2, r2, #2
   141f0:	f840 2b48 	str.w	r2, [r0], #72
   141f4:	9301      	str	r3, [sp, #4]
   141f6:	f000 f86b 	bl	142d0 <__gnu_Unwind_Save_VFP_D>
   141fa:	682a      	ldr	r2, [r5, #0]
   141fc:	9b01      	ldr	r3, [sp, #4]
   141fe:	0751      	lsls	r1, r2, #29
   14200:	d425      	bmi.n	1424e <_Unwind_VRS_Pop+0x22e>
   14202:	2e0f      	cmp	r6, #15
   14204:	d804      	bhi.n	14210 <_Unwind_VRS_Pop+0x1f0>
   14206:	a822      	add	r0, sp, #136	; 0x88
   14208:	9301      	str	r3, [sp, #4]
   1420a:	f000 f861 	bl	142d0 <__gnu_Unwind_Save_VFP_D>
   1420e:	9b01      	ldr	r3, [sp, #4]
   14210:	9301      	str	r3, [sp, #4]
   14212:	ac02      	add	r4, sp, #8
   14214:	4620      	mov	r0, r4
   14216:	f000 f863 	bl	142e0 <__gnu_Unwind_Save_VFP_D_16_to_31>
   1421a:	f1c6 0110 	rsb	r1, r6, #16
   1421e:	2900      	cmp	r1, #0
   14220:	6baa      	ldr	r2, [r5, #56]	; 0x38
   14222:	9b01      	ldr	r3, [sp, #4]
   14224:	ddb6      	ble.n	14194 <_Unwind_VRS_Pop+0x174>
   14226:	ac22      	add	r4, sp, #136	; 0x88
   14228:	004f      	lsls	r7, r1, #1
   1422a:	eb04 04c6 	add.w	r4, r4, r6, lsl #3
   1422e:	4611      	mov	r1, r2
   14230:	e7a3      	b.n	1417a <_Unwind_VRS_Pop+0x15a>
   14232:	a822      	add	r0, sp, #136	; 0x88
   14234:	f000 f848 	bl	142c8 <__gnu_Unwind_Restore_VFP_D>
   14238:	e73d      	b.n	140b6 <_Unwind_VRS_Pop+0x96>
   1423a:	f023 0310 	bic.w	r3, r3, #16
   1423e:	602b      	str	r3, [r5, #0]
   14240:	f505 70e8 	add.w	r0, r5, #464	; 0x1d0
   14244:	9201      	str	r2, [sp, #4]
   14246:	f000 f89d 	bl	14384 <__gnu_Unwind_Save_WMMXC>
   1424a:	9a01      	ldr	r2, [sp, #4]
   1424c:	e701      	b.n	14052 <_Unwind_VRS_Pop+0x32>
   1424e:	4628      	mov	r0, r5
   14250:	f022 0204 	bic.w	r2, r2, #4
   14254:	f840 2bd0 	str.w	r2, [r0], #208
   14258:	9301      	str	r3, [sp, #4]
   1425a:	f000 f841 	bl	142e0 <__gnu_Unwind_Save_VFP_D_16_to_31>
   1425e:	9b01      	ldr	r3, [sp, #4]
   14260:	e7cf      	b.n	14202 <_Unwind_VRS_Pop+0x1e2>
   14262:	682a      	ldr	r2, [r5, #0]
   14264:	e7cb      	b.n	141fe <_Unwind_VRS_Pop+0x1de>
   14266:	07d0      	lsls	r0, r2, #31
   14268:	d50a      	bpl.n	14280 <_Unwind_VRS_Pop+0x260>
   1426a:	4628      	mov	r0, r5
   1426c:	f022 0201 	bic.w	r2, r2, #1
   14270:	f042 0202 	orr.w	r2, r2, #2
   14274:	f840 2b48 	str.w	r2, [r0], #72
   14278:	9301      	str	r3, [sp, #4]
   1427a:	f000 f829 	bl	142d0 <__gnu_Unwind_Save_VFP_D>
   1427e:	9b01      	ldr	r3, [sp, #4]
   14280:	9301      	str	r3, [sp, #4]
   14282:	ac22      	add	r4, sp, #136	; 0x88
   14284:	4620      	mov	r0, r4
   14286:	f000 f823 	bl	142d0 <__gnu_Unwind_Save_VFP_D>
   1428a:	46b8      	mov	r8, r7
   1428c:	6ba9      	ldr	r1, [r5, #56]	; 0x38
   1428e:	9b01      	ldr	r3, [sp, #4]
   14290:	2f00      	cmp	r7, #0
   14292:	f47f af6d 	bne.w	14170 <_Unwind_VRS_Pop+0x150>
   14296:	460a      	mov	r2, r1
   14298:	e709      	b.n	140ae <_Unwind_VRS_Pop+0x8e>
   1429a:	460a      	mov	r2, r1
   1429c:	e78d      	b.n	141ba <_Unwind_VRS_Pop+0x19a>
   1429e:	bf00      	nop

000142a0 <__restore_core_regs>:
   142a0:	f100 0134 	add.w	r1, r0, #52	; 0x34
   142a4:	e891 0038 	ldmia.w	r1, {r3, r4, r5}
   142a8:	469c      	mov	ip, r3
   142aa:	46a6      	mov	lr, r4
   142ac:	f84c 5d04 	str.w	r5, [ip, #-4]!
   142b0:	e890 0fff 	ldmia.w	r0, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp}
   142b4:	46e5      	mov	sp, ip
   142b6:	bd00      	pop	{pc}

000142b8 <__gnu_Unwind_Restore_VFP>:
   142b8:	ec90 0b21 	fldmiax	r0, {d0-d15}	;@ Deprecated
   142bc:	4770      	bx	lr
   142be:	bf00      	nop

000142c0 <__gnu_Unwind_Save_VFP>:
   142c0:	ec80 0b21 	fstmiax	r0, {d0-d15}	;@ Deprecated
   142c4:	4770      	bx	lr
   142c6:	bf00      	nop

000142c8 <__gnu_Unwind_Restore_VFP_D>:
   142c8:	ec90 0b20 	vldmia	r0, {d0-d15}
   142cc:	4770      	bx	lr
   142ce:	bf00      	nop

000142d0 <__gnu_Unwind_Save_VFP_D>:
   142d0:	ec80 0b20 	vstmia	r0, {d0-d15}
   142d4:	4770      	bx	lr
   142d6:	bf00      	nop

000142d8 <__gnu_Unwind_Restore_VFP_D_16_to_31>:
   142d8:	ecd0 0b20 	vldmia	r0, {d16-d31}
   142dc:	4770      	bx	lr
   142de:	bf00      	nop

000142e0 <__gnu_Unwind_Save_VFP_D_16_to_31>:
   142e0:	ecc0 0b20 	vstmia	r0, {d16-d31}
   142e4:	4770      	bx	lr
   142e6:	bf00      	nop

000142e8 <__gnu_Unwind_Restore_WMMXD>:
   142e8:	ecf0 0102 	ldfe	f0, [r0], #8
   142ec:	ecf0 1102 	ldfe	f1, [r0], #8
   142f0:	ecf0 2102 	ldfe	f2, [r0], #8
   142f4:	ecf0 3102 	ldfe	f3, [r0], #8
   142f8:	ecf0 4102 	ldfe	f4, [r0], #8
   142fc:	ecf0 5102 	ldfe	f5, [r0], #8
   14300:	ecf0 6102 	ldfe	f6, [r0], #8
   14304:	ecf0 7102 	ldfe	f7, [r0], #8
   14308:	ecf0 8102 	ldfp	f0, [r0], #8
   1430c:	ecf0 9102 	ldfp	f1, [r0], #8
   14310:	ecf0 a102 	ldfp	f2, [r0], #8
   14314:	ecf0 b102 	ldfp	f3, [r0], #8
   14318:	ecf0 c102 	ldfp	f4, [r0], #8
   1431c:	ecf0 d102 	ldfp	f5, [r0], #8
   14320:	ecf0 e102 	ldfp	f6, [r0], #8
   14324:	ecf0 f102 	ldfp	f7, [r0], #8
   14328:	4770      	bx	lr
   1432a:	bf00      	nop

0001432c <__gnu_Unwind_Save_WMMXD>:
   1432c:	ece0 0102 	stfe	f0, [r0], #8
   14330:	ece0 1102 	stfe	f1, [r0], #8
   14334:	ece0 2102 	stfe	f2, [r0], #8
   14338:	ece0 3102 	stfe	f3, [r0], #8
   1433c:	ece0 4102 	stfe	f4, [r0], #8
   14340:	ece0 5102 	stfe	f5, [r0], #8
   14344:	ece0 6102 	stfe	f6, [r0], #8
   14348:	ece0 7102 	stfe	f7, [r0], #8
   1434c:	ece0 8102 	stfp	f0, [r0], #8
   14350:	ece0 9102 	stfp	f1, [r0], #8
   14354:	ece0 a102 	stfp	f2, [r0], #8
   14358:	ece0 b102 	stfp	f3, [r0], #8
   1435c:	ece0 c102 	stfp	f4, [r0], #8
   14360:	ece0 d102 	stfp	f5, [r0], #8
   14364:	ece0 e102 	stfp	f6, [r0], #8
   14368:	ece0 f102 	stfp	f7, [r0], #8
   1436c:	4770      	bx	lr
   1436e:	bf00      	nop

00014370 <__gnu_Unwind_Restore_WMMXC>:
   14370:	fcb0 8101 	ldc2	1, cr8, [r0], #4
   14374:	fcb0 9101 	ldc2	1, cr9, [r0], #4
   14378:	fcb0 a101 	ldc2	1, cr10, [r0], #4
   1437c:	fcb0 b101 	ldc2	1, cr11, [r0], #4
   14380:	4770      	bx	lr
   14382:	bf00      	nop

00014384 <__gnu_Unwind_Save_WMMXC>:
   14384:	fca0 8101 	stc2	1, cr8, [r0], #4
   14388:	fca0 9101 	stc2	1, cr9, [r0], #4
   1438c:	fca0 a101 	stc2	1, cr10, [r0], #4
   14390:	fca0 b101 	stc2	1, cr11, [r0], #4
   14394:	4770      	bx	lr
   14396:	bf00      	nop

00014398 <_Unwind_RaiseException>:
   14398:	46ec      	mov	ip, sp
   1439a:	b500      	push	{lr}
   1439c:	e92d 5000 	stmdb	sp!, {ip, lr}
   143a0:	e92d 1fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
   143a4:	f04f 0300 	mov.w	r3, #0
   143a8:	e92d 000c 	stmdb	sp!, {r2, r3}
   143ac:	a901      	add	r1, sp, #4
   143ae:	f7ff fbdd 	bl	13b6c <__gnu_Unwind_RaiseException>
   143b2:	f8dd e040 	ldr.w	lr, [sp, #64]	; 0x40
   143b6:	b012      	add	sp, #72	; 0x48
   143b8:	4770      	bx	lr
   143ba:	bf00      	nop

000143bc <_Unwind_Resume>:
   143bc:	46ec      	mov	ip, sp
   143be:	b500      	push	{lr}
   143c0:	e92d 5000 	stmdb	sp!, {ip, lr}
   143c4:	e92d 1fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
   143c8:	f04f 0300 	mov.w	r3, #0
   143cc:	e92d 000c 	stmdb	sp!, {r2, r3}
   143d0:	a901      	add	r1, sp, #4
   143d2:	f7ff fc05 	bl	13be0 <__gnu_Unwind_Resume>
   143d6:	f8dd e040 	ldr.w	lr, [sp, #64]	; 0x40
   143da:	b012      	add	sp, #72	; 0x48
   143dc:	4770      	bx	lr
   143de:	bf00      	nop

000143e0 <_Unwind_Resume_or_Rethrow>:
   143e0:	46ec      	mov	ip, sp
   143e2:	b500      	push	{lr}
   143e4:	e92d 5000 	stmdb	sp!, {ip, lr}
   143e8:	e92d 1fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
   143ec:	f04f 0300 	mov.w	r3, #0
   143f0:	e92d 000c 	stmdb	sp!, {r2, r3}
   143f4:	a901      	add	r1, sp, #4
   143f6:	f7ff fc15 	bl	13c24 <__gnu_Unwind_Resume_or_Rethrow>
   143fa:	f8dd e040 	ldr.w	lr, [sp, #64]	; 0x40
   143fe:	b012      	add	sp, #72	; 0x48
   14400:	4770      	bx	lr
   14402:	bf00      	nop

00014404 <_Unwind_ForcedUnwind>:
   14404:	46ec      	mov	ip, sp
   14406:	b500      	push	{lr}
   14408:	e92d 5000 	stmdb	sp!, {ip, lr}
   1440c:	e92d 1fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
   14410:	f04f 0300 	mov.w	r3, #0
   14414:	e92d 000c 	stmdb	sp!, {r2, r3}
   14418:	ab01      	add	r3, sp, #4
   1441a:	f7ff fbd7 	bl	13bcc <__gnu_Unwind_ForcedUnwind>
   1441e:	f8dd e040 	ldr.w	lr, [sp, #64]	; 0x40
   14422:	b012      	add	sp, #72	; 0x48
   14424:	4770      	bx	lr
   14426:	bf00      	nop

00014428 <_Unwind_Backtrace>:
   14428:	46ec      	mov	ip, sp
   1442a:	b500      	push	{lr}
   1442c:	e92d 5000 	stmdb	sp!, {ip, lr}
   14430:	e92d 1fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
   14434:	f04f 0300 	mov.w	r3, #0
   14438:	e92d 000c 	stmdb	sp!, {r2, r3}
   1443c:	aa01      	add	r2, sp, #4
   1443e:	f7ff fc47 	bl	13cd0 <__gnu_Unwind_Backtrace>
   14442:	f8dd e040 	ldr.w	lr, [sp, #64]	; 0x40
   14446:	b012      	add	sp, #72	; 0x48
   14448:	4770      	bx	lr
   1444a:	bf00      	nop

0001444c <next_unwind_byte>:
   1444c:	7a02      	ldrb	r2, [r0, #8]
   1444e:	b982      	cbnz	r2, 14472 <next_unwind_byte+0x26>
   14450:	7a43      	ldrb	r3, [r0, #9]
   14452:	b1ab      	cbz	r3, 14480 <next_unwind_byte+0x34>
   14454:	6842      	ldr	r2, [r0, #4]
   14456:	3b01      	subs	r3, #1
   14458:	b410      	push	{r4}
   1445a:	7243      	strb	r3, [r0, #9]
   1445c:	6813      	ldr	r3, [r2, #0]
   1445e:	2103      	movs	r1, #3
   14460:	1d14      	adds	r4, r2, #4
   14462:	7201      	strb	r1, [r0, #8]
   14464:	021a      	lsls	r2, r3, #8
   14466:	6044      	str	r4, [r0, #4]
   14468:	6002      	str	r2, [r0, #0]
   1446a:	f85d 4b04 	ldr.w	r4, [sp], #4
   1446e:	0e18      	lsrs	r0, r3, #24
   14470:	4770      	bx	lr
   14472:	6803      	ldr	r3, [r0, #0]
   14474:	3a01      	subs	r2, #1
   14476:	7202      	strb	r2, [r0, #8]
   14478:	021a      	lsls	r2, r3, #8
   1447a:	6002      	str	r2, [r0, #0]
   1447c:	0e18      	lsrs	r0, r3, #24
   1447e:	4770      	bx	lr
   14480:	20b0      	movs	r0, #176	; 0xb0
   14482:	4770      	bx	lr

00014484 <_Unwind_GetGR.constprop.0>:
   14484:	b500      	push	{lr}
   14486:	b085      	sub	sp, #20
   14488:	aa03      	add	r2, sp, #12
   1448a:	2300      	movs	r3, #0
   1448c:	9200      	str	r2, [sp, #0]
   1448e:	4619      	mov	r1, r3
   14490:	220c      	movs	r2, #12
   14492:	f7ff fbd7 	bl	13c44 <_Unwind_VRS_Get>
   14496:	9803      	ldr	r0, [sp, #12]
   14498:	b005      	add	sp, #20
   1449a:	f85d fb04 	ldr.w	pc, [sp], #4
   1449e:	bf00      	nop

000144a0 <unwind_UCB_from_context>:
   144a0:	e7f0      	b.n	14484 <_Unwind_GetGR.constprop.0>
   144a2:	bf00      	nop

000144a4 <__gnu_unwind_execute>:
   144a4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   144a8:	4605      	mov	r5, r0
   144aa:	b085      	sub	sp, #20
   144ac:	460e      	mov	r6, r1
   144ae:	f04f 0800 	mov.w	r8, #0
   144b2:	4630      	mov	r0, r6
   144b4:	f7ff ffca 	bl	1444c <next_unwind_byte>
   144b8:	28b0      	cmp	r0, #176	; 0xb0
   144ba:	4604      	mov	r4, r0
   144bc:	f000 80b1 	beq.w	14622 <__gnu_unwind_execute+0x17e>
   144c0:	0607      	lsls	r7, r0, #24
   144c2:	d520      	bpl.n	14506 <__gnu_unwind_execute+0x62>
   144c4:	f000 03f0 	and.w	r3, r0, #240	; 0xf0
   144c8:	2b80      	cmp	r3, #128	; 0x80
   144ca:	d065      	beq.n	14598 <__gnu_unwind_execute+0xf4>
   144cc:	2b90      	cmp	r3, #144	; 0x90
   144ce:	d036      	beq.n	1453e <__gnu_unwind_execute+0x9a>
   144d0:	2ba0      	cmp	r3, #160	; 0xa0
   144d2:	d078      	beq.n	145c6 <__gnu_unwind_execute+0x122>
   144d4:	2bb0      	cmp	r3, #176	; 0xb0
   144d6:	d047      	beq.n	14568 <__gnu_unwind_execute+0xc4>
   144d8:	2bc0      	cmp	r3, #192	; 0xc0
   144da:	f000 808a 	beq.w	145f2 <__gnu_unwind_execute+0x14e>
   144de:	f000 03f8 	and.w	r3, r0, #248	; 0xf8
   144e2:	2bd0      	cmp	r3, #208	; 0xd0
   144e4:	d10b      	bne.n	144fe <__gnu_unwind_execute+0x5a>
   144e6:	f000 0207 	and.w	r2, r0, #7
   144ea:	3201      	adds	r2, #1
   144ec:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
   144f0:	2305      	movs	r3, #5
   144f2:	2101      	movs	r1, #1
   144f4:	4628      	mov	r0, r5
   144f6:	f7ff fd93 	bl	14020 <_Unwind_VRS_Pop>
   144fa:	2800      	cmp	r0, #0
   144fc:	d0d9      	beq.n	144b2 <__gnu_unwind_execute+0xe>
   144fe:	2009      	movs	r0, #9
   14500:	b005      	add	sp, #20
   14502:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   14506:	f10d 090c 	add.w	r9, sp, #12
   1450a:	2300      	movs	r3, #0
   1450c:	4619      	mov	r1, r3
   1450e:	0087      	lsls	r7, r0, #2
   14510:	f8cd 9000 	str.w	r9, [sp]
   14514:	220d      	movs	r2, #13
   14516:	4628      	mov	r0, r5
   14518:	f7ff fb94 	bl	13c44 <_Unwind_VRS_Get>
   1451c:	b2ff      	uxtb	r7, r7
   1451e:	9b03      	ldr	r3, [sp, #12]
   14520:	f8cd 9000 	str.w	r9, [sp]
   14524:	3704      	adds	r7, #4
   14526:	0660      	lsls	r0, r4, #25
   14528:	bf4c      	ite	mi
   1452a:	1bdf      	submi	r7, r3, r7
   1452c:	18ff      	addpl	r7, r7, r3
   1452e:	2300      	movs	r3, #0
   14530:	4619      	mov	r1, r3
   14532:	220d      	movs	r2, #13
   14534:	4628      	mov	r0, r5
   14536:	9703      	str	r7, [sp, #12]
   14538:	f7ff fba6 	bl	13c88 <_Unwind_VRS_Set>
   1453c:	e7b9      	b.n	144b2 <__gnu_unwind_execute+0xe>
   1453e:	f000 030d 	and.w	r3, r0, #13
   14542:	2b0d      	cmp	r3, #13
   14544:	d0db      	beq.n	144fe <__gnu_unwind_execute+0x5a>
   14546:	af03      	add	r7, sp, #12
   14548:	2300      	movs	r3, #0
   1454a:	f000 020f 	and.w	r2, r0, #15
   1454e:	4619      	mov	r1, r3
   14550:	9700      	str	r7, [sp, #0]
   14552:	4628      	mov	r0, r5
   14554:	f7ff fb76 	bl	13c44 <_Unwind_VRS_Get>
   14558:	2300      	movs	r3, #0
   1455a:	9700      	str	r7, [sp, #0]
   1455c:	4619      	mov	r1, r3
   1455e:	220d      	movs	r2, #13
   14560:	4628      	mov	r0, r5
   14562:	f7ff fb91 	bl	13c88 <_Unwind_VRS_Set>
   14566:	e7a4      	b.n	144b2 <__gnu_unwind_execute+0xe>
   14568:	28b1      	cmp	r0, #177	; 0xb1
   1456a:	d05f      	beq.n	1462c <__gnu_unwind_execute+0x188>
   1456c:	28b2      	cmp	r0, #178	; 0xb2
   1456e:	f000 80cc 	beq.w	1470a <__gnu_unwind_execute+0x266>
   14572:	28b3      	cmp	r0, #179	; 0xb3
   14574:	d07e      	beq.n	14674 <__gnu_unwind_execute+0x1d0>
   14576:	f000 03fc 	and.w	r3, r0, #252	; 0xfc
   1457a:	2bb4      	cmp	r3, #180	; 0xb4
   1457c:	d0bf      	beq.n	144fe <__gnu_unwind_execute+0x5a>
   1457e:	f000 0207 	and.w	r2, r0, #7
   14582:	3201      	adds	r2, #1
   14584:	2301      	movs	r3, #1
   14586:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
   1458a:	4619      	mov	r1, r3
   1458c:	4628      	mov	r0, r5
   1458e:	f7ff fd47 	bl	14020 <_Unwind_VRS_Pop>
   14592:	2800      	cmp	r0, #0
   14594:	d08d      	beq.n	144b2 <__gnu_unwind_execute+0xe>
   14596:	e7b2      	b.n	144fe <__gnu_unwind_execute+0x5a>
   14598:	4630      	mov	r0, r6
   1459a:	f7ff ff57 	bl	1444c <next_unwind_byte>
   1459e:	0224      	lsls	r4, r4, #8
   145a0:	4304      	orrs	r4, r0
   145a2:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
   145a6:	d0aa      	beq.n	144fe <__gnu_unwind_execute+0x5a>
   145a8:	0124      	lsls	r4, r4, #4
   145aa:	2300      	movs	r3, #0
   145ac:	b2a2      	uxth	r2, r4
   145ae:	4619      	mov	r1, r3
   145b0:	4628      	mov	r0, r5
   145b2:	f7ff fd35 	bl	14020 <_Unwind_VRS_Pop>
   145b6:	2800      	cmp	r0, #0
   145b8:	d1a1      	bne.n	144fe <__gnu_unwind_execute+0x5a>
   145ba:	f414 4f00 	tst.w	r4, #32768	; 0x8000
   145be:	bf18      	it	ne
   145c0:	f04f 0801 	movne.w	r8, #1
   145c4:	e775      	b.n	144b2 <__gnu_unwind_execute+0xe>
   145c6:	43c2      	mvns	r2, r0
   145c8:	f002 0307 	and.w	r3, r2, #7
   145cc:	f44f 627f 	mov.w	r2, #4080	; 0xff0
   145d0:	411a      	asrs	r2, r3
   145d2:	0701      	lsls	r1, r0, #28
   145d4:	f402 627f 	and.w	r2, r2, #4080	; 0xff0
   145d8:	f04f 0300 	mov.w	r3, #0
   145dc:	bf48      	it	mi
   145de:	f442 4280 	orrmi.w	r2, r2, #16384	; 0x4000
   145e2:	4619      	mov	r1, r3
   145e4:	4628      	mov	r0, r5
   145e6:	f7ff fd1b 	bl	14020 <_Unwind_VRS_Pop>
   145ea:	2800      	cmp	r0, #0
   145ec:	f43f af61 	beq.w	144b2 <__gnu_unwind_execute+0xe>
   145f0:	e785      	b.n	144fe <__gnu_unwind_execute+0x5a>
   145f2:	28c6      	cmp	r0, #198	; 0xc6
   145f4:	d051      	beq.n	1469a <__gnu_unwind_execute+0x1f6>
   145f6:	28c7      	cmp	r0, #199	; 0xc7
   145f8:	d05a      	beq.n	146b0 <__gnu_unwind_execute+0x20c>
   145fa:	f000 03f8 	and.w	r3, r0, #248	; 0xf8
   145fe:	2bc0      	cmp	r3, #192	; 0xc0
   14600:	d069      	beq.n	146d6 <__gnu_unwind_execute+0x232>
   14602:	28c8      	cmp	r0, #200	; 0xc8
   14604:	d075      	beq.n	146f2 <__gnu_unwind_execute+0x24e>
   14606:	28c9      	cmp	r0, #201	; 0xc9
   14608:	f47f af79 	bne.w	144fe <__gnu_unwind_execute+0x5a>
   1460c:	4630      	mov	r0, r6
   1460e:	f7ff ff1d 	bl	1444c <next_unwind_byte>
   14612:	0302      	lsls	r2, r0, #12
   14614:	f000 000f 	and.w	r0, r0, #15
   14618:	f402 2270 	and.w	r2, r2, #983040	; 0xf0000
   1461c:	3001      	adds	r0, #1
   1461e:	4302      	orrs	r2, r0
   14620:	e766      	b.n	144f0 <__gnu_unwind_execute+0x4c>
   14622:	f1b8 0f00 	cmp.w	r8, #0
   14626:	d014      	beq.n	14652 <__gnu_unwind_execute+0x1ae>
   14628:	2000      	movs	r0, #0
   1462a:	e769      	b.n	14500 <__gnu_unwind_execute+0x5c>
   1462c:	4630      	mov	r0, r6
   1462e:	f7ff ff0d 	bl	1444c <next_unwind_byte>
   14632:	2800      	cmp	r0, #0
   14634:	f43f af63 	beq.w	144fe <__gnu_unwind_execute+0x5a>
   14638:	f010 03f0 	ands.w	r3, r0, #240	; 0xf0
   1463c:	f47f af5f 	bne.w	144fe <__gnu_unwind_execute+0x5a>
   14640:	4602      	mov	r2, r0
   14642:	4619      	mov	r1, r3
   14644:	4628      	mov	r0, r5
   14646:	f7ff fceb 	bl	14020 <_Unwind_VRS_Pop>
   1464a:	2800      	cmp	r0, #0
   1464c:	f43f af31 	beq.w	144b2 <__gnu_unwind_execute+0xe>
   14650:	e755      	b.n	144fe <__gnu_unwind_execute+0x5a>
   14652:	ac03      	add	r4, sp, #12
   14654:	4643      	mov	r3, r8
   14656:	220e      	movs	r2, #14
   14658:	4641      	mov	r1, r8
   1465a:	9400      	str	r4, [sp, #0]
   1465c:	4628      	mov	r0, r5
   1465e:	f7ff faf1 	bl	13c44 <_Unwind_VRS_Get>
   14662:	9400      	str	r4, [sp, #0]
   14664:	4628      	mov	r0, r5
   14666:	4643      	mov	r3, r8
   14668:	220f      	movs	r2, #15
   1466a:	4641      	mov	r1, r8
   1466c:	f7ff fb0c 	bl	13c88 <_Unwind_VRS_Set>
   14670:	4640      	mov	r0, r8
   14672:	e745      	b.n	14500 <__gnu_unwind_execute+0x5c>
   14674:	4630      	mov	r0, r6
   14676:	f7ff fee9 	bl	1444c <next_unwind_byte>
   1467a:	0301      	lsls	r1, r0, #12
   1467c:	f000 000f 	and.w	r0, r0, #15
   14680:	f401 2170 	and.w	r1, r1, #983040	; 0xf0000
   14684:	1c42      	adds	r2, r0, #1
   14686:	2301      	movs	r3, #1
   14688:	430a      	orrs	r2, r1
   1468a:	4628      	mov	r0, r5
   1468c:	4619      	mov	r1, r3
   1468e:	f7ff fcc7 	bl	14020 <_Unwind_VRS_Pop>
   14692:	2800      	cmp	r0, #0
   14694:	f43f af0d 	beq.w	144b2 <__gnu_unwind_execute+0xe>
   14698:	e731      	b.n	144fe <__gnu_unwind_execute+0x5a>
   1469a:	4630      	mov	r0, r6
   1469c:	f7ff fed6 	bl	1444c <next_unwind_byte>
   146a0:	0301      	lsls	r1, r0, #12
   146a2:	f000 000f 	and.w	r0, r0, #15
   146a6:	f401 2170 	and.w	r1, r1, #983040	; 0xf0000
   146aa:	1c42      	adds	r2, r0, #1
   146ac:	2303      	movs	r3, #3
   146ae:	e7eb      	b.n	14688 <__gnu_unwind_execute+0x1e4>
   146b0:	4630      	mov	r0, r6
   146b2:	f7ff fecb 	bl	1444c <next_unwind_byte>
   146b6:	4602      	mov	r2, r0
   146b8:	2800      	cmp	r0, #0
   146ba:	f43f af20 	beq.w	144fe <__gnu_unwind_execute+0x5a>
   146be:	f010 03f0 	ands.w	r3, r0, #240	; 0xf0
   146c2:	f47f af1c 	bne.w	144fe <__gnu_unwind_execute+0x5a>
   146c6:	2104      	movs	r1, #4
   146c8:	4628      	mov	r0, r5
   146ca:	f7ff fca9 	bl	14020 <_Unwind_VRS_Pop>
   146ce:	2800      	cmp	r0, #0
   146d0:	f43f aeef 	beq.w	144b2 <__gnu_unwind_execute+0xe>
   146d4:	e713      	b.n	144fe <__gnu_unwind_execute+0x5a>
   146d6:	f000 020f 	and.w	r2, r0, #15
   146da:	3201      	adds	r2, #1
   146dc:	2303      	movs	r3, #3
   146de:	f442 2220 	orr.w	r2, r2, #655360	; 0xa0000
   146e2:	4619      	mov	r1, r3
   146e4:	4628      	mov	r0, r5
   146e6:	f7ff fc9b 	bl	14020 <_Unwind_VRS_Pop>
   146ea:	2800      	cmp	r0, #0
   146ec:	f43f aee1 	beq.w	144b2 <__gnu_unwind_execute+0xe>
   146f0:	e705      	b.n	144fe <__gnu_unwind_execute+0x5a>
   146f2:	4630      	mov	r0, r6
   146f4:	f7ff feaa 	bl	1444c <next_unwind_byte>
   146f8:	f000 02f0 	and.w	r2, r0, #240	; 0xf0
   146fc:	f000 030f 	and.w	r3, r0, #15
   14700:	3210      	adds	r2, #16
   14702:	3301      	adds	r3, #1
   14704:	ea43 3202 	orr.w	r2, r3, r2, lsl #12
   14708:	e6f2      	b.n	144f0 <__gnu_unwind_execute+0x4c>
   1470a:	2300      	movs	r3, #0
   1470c:	f10d 090c 	add.w	r9, sp, #12
   14710:	220d      	movs	r2, #13
   14712:	4619      	mov	r1, r3
   14714:	f8cd 9000 	str.w	r9, [sp]
   14718:	4628      	mov	r0, r5
   1471a:	f7ff fa93 	bl	13c44 <_Unwind_VRS_Get>
   1471e:	4630      	mov	r0, r6
   14720:	f7ff fe94 	bl	1444c <next_unwind_byte>
   14724:	0602      	lsls	r2, r0, #24
   14726:	f04f 0702 	mov.w	r7, #2
   1472a:	d50c      	bpl.n	14746 <__gnu_unwind_execute+0x2a2>
   1472c:	9b03      	ldr	r3, [sp, #12]
   1472e:	f000 007f 	and.w	r0, r0, #127	; 0x7f
   14732:	40b8      	lsls	r0, r7
   14734:	4403      	add	r3, r0
   14736:	4630      	mov	r0, r6
   14738:	9303      	str	r3, [sp, #12]
   1473a:	f7ff fe87 	bl	1444c <next_unwind_byte>
   1473e:	0603      	lsls	r3, r0, #24
   14740:	f107 0707 	add.w	r7, r7, #7
   14744:	d4f2      	bmi.n	1472c <__gnu_unwind_execute+0x288>
   14746:	9b03      	ldr	r3, [sp, #12]
   14748:	f8cd 9000 	str.w	r9, [sp]
   1474c:	f000 047f 	and.w	r4, r0, #127	; 0x7f
   14750:	f503 7201 	add.w	r2, r3, #516	; 0x204
   14754:	40bc      	lsls	r4, r7
   14756:	2300      	movs	r3, #0
   14758:	4414      	add	r4, r2
   1475a:	4619      	mov	r1, r3
   1475c:	220d      	movs	r2, #13
   1475e:	4628      	mov	r0, r5
   14760:	9403      	str	r4, [sp, #12]
   14762:	f7ff fa91 	bl	13c88 <_Unwind_VRS_Set>
   14766:	e6a4      	b.n	144b2 <__gnu_unwind_execute+0xe>

00014768 <__gnu_unwind_frame>:
   14768:	b510      	push	{r4, lr}
   1476a:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
   1476c:	b084      	sub	sp, #16
   1476e:	685a      	ldr	r2, [r3, #4]
   14770:	2003      	movs	r0, #3
   14772:	f88d 000c 	strb.w	r0, [sp, #12]
   14776:	79dc      	ldrb	r4, [r3, #7]
   14778:	f88d 400d 	strb.w	r4, [sp, #13]
   1477c:	0212      	lsls	r2, r2, #8
   1477e:	3308      	adds	r3, #8
   14780:	4608      	mov	r0, r1
   14782:	a901      	add	r1, sp, #4
   14784:	9201      	str	r2, [sp, #4]
   14786:	9302      	str	r3, [sp, #8]
   14788:	f7ff fe8c 	bl	144a4 <__gnu_unwind_execute>
   1478c:	b004      	add	sp, #16
   1478e:	bd10      	pop	{r4, pc}

00014790 <_Unwind_GetRegionStart>:
   14790:	b508      	push	{r3, lr}
   14792:	f7ff fe85 	bl	144a0 <unwind_UCB_from_context>
   14796:	6c80      	ldr	r0, [r0, #72]	; 0x48
   14798:	bd08      	pop	{r3, pc}
   1479a:	bf00      	nop

0001479c <_Unwind_GetLanguageSpecificData>:
   1479c:	b508      	push	{r3, lr}
   1479e:	f7ff fe7f 	bl	144a0 <unwind_UCB_from_context>
   147a2:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
   147a4:	79c3      	ldrb	r3, [r0, #7]
   147a6:	eb00 0083 	add.w	r0, r0, r3, lsl #2
   147aa:	3008      	adds	r0, #8
   147ac:	bd08      	pop	{r3, pc}
   147ae:	bf00      	nop

000147b0 <_Unwind_GetDataRelBase>:
   147b0:	b508      	push	{r3, lr}
   147b2:	f000 f807 	bl	147c4 <abort>
   147b6:	bf00      	nop

000147b8 <_Unwind_GetTextRelBase>:
   147b8:	b508      	push	{r3, lr}
   147ba:	f7ff fff9 	bl	147b0 <_Unwind_GetDataRelBase>
   147be:	bf00      	nop

000147c0 <__aeabi_idiv0>:
   147c0:	4770      	bx	lr
   147c2:	bf00      	nop

000147c4 <abort>:
   147c4:	b508      	push	{r3, lr}
   147c6:	2006      	movs	r0, #6
   147c8:	f000 f85c 	bl	14884 <raise>
   147cc:	2001      	movs	r0, #1
   147ce:	f7fd fc75 	bl	120bc <_exit>
   147d2:	Address 0x00000000000147d2 is out of bounds.


000147d4 <__libc_init_array>:
   147d4:	b570      	push	{r4, r5, r6, lr}
   147d6:	4e0d      	ldr	r6, [pc, #52]	; (1480c <__libc_init_array+0x38>)
   147d8:	4c0d      	ldr	r4, [pc, #52]	; (14810 <__libc_init_array+0x3c>)
   147da:	1ba4      	subs	r4, r4, r6
   147dc:	10a4      	asrs	r4, r4, #2
   147de:	2500      	movs	r5, #0
   147e0:	42a5      	cmp	r5, r4
   147e2:	d109      	bne.n	147f8 <__libc_init_array+0x24>
   147e4:	4e0b      	ldr	r6, [pc, #44]	; (14814 <__libc_init_array+0x40>)
   147e6:	4c0c      	ldr	r4, [pc, #48]	; (14818 <__libc_init_array+0x44>)
   147e8:	f7fb fd8a 	bl	10300 <_init>
   147ec:	1ba4      	subs	r4, r4, r6
   147ee:	10a4      	asrs	r4, r4, #2
   147f0:	2500      	movs	r5, #0
   147f2:	42a5      	cmp	r5, r4
   147f4:	d105      	bne.n	14802 <__libc_init_array+0x2e>
   147f6:	bd70      	pop	{r4, r5, r6, pc}
   147f8:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
   147fc:	4798      	blx	r3
   147fe:	3501      	adds	r5, #1
   14800:	e7ee      	b.n	147e0 <__libc_init_array+0xc>
   14802:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
   14806:	4798      	blx	r3
   14808:	3501      	adds	r5, #1
   1480a:	e7f2      	b.n	147f2 <__libc_init_array+0x1e>
   1480c:	0001030c 	.word	0x0001030c
   14810:	0001030c 	.word	0x0001030c
   14814:	0001030c 	.word	0x0001030c
   14818:	00010318 	.word	0x00010318

0001481c <memcpy>:
   1481c:	b510      	push	{r4, lr}
   1481e:	1e43      	subs	r3, r0, #1
   14820:	440a      	add	r2, r1
   14822:	4291      	cmp	r1, r2
   14824:	d100      	bne.n	14828 <memcpy+0xc>
   14826:	bd10      	pop	{r4, pc}
   14828:	f811 4b01 	ldrb.w	r4, [r1], #1
   1482c:	f803 4f01 	strb.w	r4, [r3, #1]!
   14830:	e7f7      	b.n	14822 <memcpy+0x6>

00014832 <_raise_r>:
   14832:	291f      	cmp	r1, #31
   14834:	b538      	push	{r3, r4, r5, lr}
   14836:	4604      	mov	r4, r0
   14838:	460d      	mov	r5, r1
   1483a:	d904      	bls.n	14846 <_raise_r+0x14>
   1483c:	2316      	movs	r3, #22
   1483e:	6003      	str	r3, [r0, #0]
   14840:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   14844:	bd38      	pop	{r3, r4, r5, pc}
   14846:	6c42      	ldr	r2, [r0, #68]	; 0x44
   14848:	b112      	cbz	r2, 14850 <_raise_r+0x1e>
   1484a:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
   1484e:	b94b      	cbnz	r3, 14864 <_raise_r+0x32>
   14850:	4620      	mov	r0, r4
   14852:	f000 f831 	bl	148b8 <_getpid_r>
   14856:	462a      	mov	r2, r5
   14858:	4601      	mov	r1, r0
   1485a:	4620      	mov	r0, r4
   1485c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   14860:	f000 b818 	b.w	14894 <_kill_r>
   14864:	2b01      	cmp	r3, #1
   14866:	d00a      	beq.n	1487e <_raise_r+0x4c>
   14868:	1c59      	adds	r1, r3, #1
   1486a:	d103      	bne.n	14874 <_raise_r+0x42>
   1486c:	2316      	movs	r3, #22
   1486e:	6003      	str	r3, [r0, #0]
   14870:	2001      	movs	r0, #1
   14872:	e7e7      	b.n	14844 <_raise_r+0x12>
   14874:	2400      	movs	r4, #0
   14876:	f842 4025 	str.w	r4, [r2, r5, lsl #2]
   1487a:	4628      	mov	r0, r5
   1487c:	4798      	blx	r3
   1487e:	2000      	movs	r0, #0
   14880:	e7e0      	b.n	14844 <_raise_r+0x12>
   14882:	Address 0x0000000000014882 is out of bounds.


00014884 <raise>:
   14884:	4b02      	ldr	r3, [pc, #8]	; (14890 <raise+0xc>)
   14886:	4601      	mov	r1, r0
   14888:	6818      	ldr	r0, [r3, #0]
   1488a:	f7ff bfd2 	b.w	14832 <_raise_r>
   1488e:	bf00      	nop
   14890:	1000018c 	.word	0x1000018c

00014894 <_kill_r>:
   14894:	b538      	push	{r3, r4, r5, lr}
   14896:	4c07      	ldr	r4, [pc, #28]	; (148b4 <_kill_r+0x20>)
   14898:	2300      	movs	r3, #0
   1489a:	4605      	mov	r5, r0
   1489c:	4608      	mov	r0, r1
   1489e:	4611      	mov	r1, r2
   148a0:	6023      	str	r3, [r4, #0]
   148a2:	f7fd fc19 	bl	120d8 <_kill>
   148a6:	1c43      	adds	r3, r0, #1
   148a8:	d102      	bne.n	148b0 <_kill_r+0x1c>
   148aa:	6823      	ldr	r3, [r4, #0]
   148ac:	b103      	cbz	r3, 148b0 <_kill_r+0x1c>
   148ae:	602b      	str	r3, [r5, #0]
   148b0:	bd38      	pop	{r3, r4, r5, pc}
   148b2:	bf00      	nop
   148b4:	100003ac 	.word	0x100003ac

000148b8 <_getpid_r>:
   148b8:	f7fd bc06 	b.w	120c8 <_getpid>
   148bc:	00000000 	.word	0x00000000
   148c0:	746f6f62 	.word	0x746f6f62
   148c4:	64616f6c 	.word	0x64616f6c
   148c8:	00007265 	.word	0x00007265
   148cc:	6c707061 	.word	0x6c707061
   148d0:	74616369 	.word	0x74616369
   148d4:	006e6f69 	.word	0x006e6f69
   148d8:	74736f68 	.word	0x74736f68
   148dc:	73657420 	.word	0x73657420
   148e0:	00000074 	.word	0x00000074
   148e4:	64252020 	.word	0x64252020
   148e8:	78302029 	.word	0x78302029
   148ec:	58383025 	.word	0x58383025
   148f0:	0000000a 	.word	0x0000000a
   148f4:	25783020 	.word	0x25783020
   148f8:	00583830 	.word	0x00583830
   148fc:	64252020 	.word	0x64252020
   14900:	78302029 	.word	0x78302029
   14904:	000a7025 	.word	0x000a7025
   14908:	6e75520a 	.word	0x6e75520a
   1490c:	6874203a 	.word	0x6874203a
   14910:	6f662065 	.word	0x6f662065
   14914:	776f6c6c 	.word	0x776f6c6c
   14918:	20676e69 	.word	0x20676e69
   1491c:	6d6d6f63 	.word	0x6d6d6f63
   14920:	20646e61 	.word	0x20646e61
   14924:	79206e69 	.word	0x79206e69
   14928:	2072756f 	.word	0x2072756f
   1492c:	6a6f7270 	.word	0x6a6f7270
   14930:	20746365 	.word	0x20746365
   14934:	65726964 	.word	0x65726964
   14938:	726f7463 	.word	0x726f7463
   1493c:	00000079 	.word	0x00000079
   14940:	20200a0a 	.word	0x20200a0a
   14944:	3b315b1b 	.word	0x3b315b1b
   14948:	006d3733 	.word	0x006d3733
   1494c:	656b616d 	.word	0x656b616d
   14950:	61747320 	.word	0x61747320
   14954:	72746b63 	.word	0x72746b63
   14958:	2d656361 	.word	0x2d656361
   1495c:	54207325 	.word	0x54207325
   14960:	45434152 	.word	0x45434152
   14964:	00223d53 	.word	0x00223d53
   14968:	25783020 	.word	0x25783020
   1496c:	00000070 	.word	0x00000070
   14970:	1b0a0a22 	.word	0x1b0a0a22
   14974:	006d305b 	.word	0x006d305b
   14978:	73696854 	.word	0x73696854
   1497c:	6c697720 	.word	0x6c697720
   14980:	6572206c 	.word	0x6572206c
   14984:	74726f70 	.word	0x74726f70
   14988:	65687420 	.word	0x65687420
   1498c:	6c696620 	.word	0x6c696620
   14990:	6e612065 	.word	0x6e612065
   14994:	696c2064 	.word	0x696c2064
   14998:	6e20656e 	.word	0x6e20656e
   1499c:	65626d75 	.word	0x65626d75
   149a0:	68742072 	.word	0x68742072
   149a4:	6c207461 	.word	0x6c207461
   149a8:	74206465 	.word	0x74206465
   149ac:	6874206f 	.word	0x6874206f
   149b0:	66207369 	.word	0x66207369
   149b4:	74636e75 	.word	0x74636e75
   149b8:	206e6f69 	.word	0x206e6f69
   149bc:	6e696562 	.word	0x6e696562
   149c0:	61632067 	.word	0x61632067
   149c4:	64656c6c 	.word	0x64656c6c
   149c8:	0000002e 	.word	0x0000002e
   149cc:	33345b1b 	.word	0x33345b1b
   149d0:	4157206d 	.word	0x4157206d
   149d4:	4e494e52 	.word	0x4e494e52
   149d8:	305b1b47 	.word	0x305b1b47
   149dc:	6d34393b 	.word	0x6d34393b
   149e0:	3a73253a 	.word	0x3a73253a
   149e4:	3b305b1b 	.word	0x3b305b1b
   149e8:	256d3239 	.word	0x256d3239
   149ec:	5b1b3a73 	.word	0x5b1b3a73
   149f0:	33393b30 	.word	0x33393b30
   149f4:	3e64256d 	.word	0x3e64256d
   149f8:	305b1b20 	.word	0x305b1b20
   149fc:	6d37333b 	.word	0x6d37333b
   14a00:	74726f50 	.word	0x74726f50
   14a04:	20642520 	.word	0x20642520
   14a08:	6e6e6163 	.word	0x6e6e6163
   14a0c:	6220746f 	.word	0x6220746f
   14a10:	73752065 	.word	0x73752065
   14a14:	66206465 	.word	0x66206465
   14a18:	4520726f 	.word	0x4520726f
   14a1c:	72657478 	.word	0x72657478
   14a20:	206c616e 	.word	0x206c616e
   14a24:	65746e49 	.word	0x65746e49
   14a28:	70757272 	.word	0x70757272
   14a2c:	202e7374 	.word	0x202e7374
   14a30:	6465654e 	.word	0x6465654e
   14a34:	206f7420 	.word	0x206f7420
   14a38:	20657375 	.word	0x20657375
   14a3c:	4f495047 	.word	0x4f495047
   14a40:	206e6f20 	.word	0x206e6f20
   14a44:	74726f50 	.word	0x74726f50
   14a48:	6f203020 	.word	0x6f203020
   14a4c:	2e322072 	.word	0x2e322072
   14a50:	6d305b1b 	.word	0x6d305b1b
   14a54:	6d305b1b 	.word	0x6d305b1b
   14a58:	0000000a 	.word	0x0000000a
   14a5c:	33345b1b 	.word	0x33345b1b
   14a60:	4157206d 	.word	0x4157206d
   14a64:	4e494e52 	.word	0x4e494e52
   14a68:	305b1b47 	.word	0x305b1b47
   14a6c:	6d34393b 	.word	0x6d34393b
   14a70:	3a73253a 	.word	0x3a73253a
   14a74:	3b305b1b 	.word	0x3b305b1b
   14a78:	256d3239 	.word	0x256d3239
   14a7c:	5b1b3a73 	.word	0x5b1b3a73
   14a80:	33393b30 	.word	0x33393b30
   14a84:	3e64256d 	.word	0x3e64256d
   14a88:	305b1b20 	.word	0x305b1b20
   14a8c:	6d37333b 	.word	0x6d37333b
   14a90:	65676445 	.word	0x65676445
   14a94:	20642520 	.word	0x20642520
   14a98:	6e6e6163 	.word	0x6e6e6163
   14a9c:	6220746f 	.word	0x6220746f
   14aa0:	73752065 	.word	0x73752065
   14aa4:	66206465 	.word	0x66206465
   14aa8:	4520726f 	.word	0x4520726f
   14aac:	72657478 	.word	0x72657478
   14ab0:	206c616e 	.word	0x206c616e
   14ab4:	65746e49 	.word	0x65746e49
   14ab8:	70757272 	.word	0x70757272
   14abc:	4e2e7374 	.word	0x4e2e7374
   14ac0:	20646565 	.word	0x20646565
   14ac4:	75206f74 	.word	0x75206f74
   14ac8:	61206573 	.word	0x61206573
   14acc:	73697220 	.word	0x73697220
   14ad0:	2c676e69 	.word	0x2c676e69
   14ad4:	6c616620 	.word	0x6c616620
   14ad8:	676e696c 	.word	0x676e696c
   14adc:	726f202c 	.word	0x726f202c
   14ae0:	746f6220 	.word	0x746f6220
   14ae4:	6f632068 	.word	0x6f632068
   14ae8:	6769666e 	.word	0x6769666e
   14aec:	74617275 	.word	0x74617275
   14af0:	2e6e6f69 	.word	0x2e6e6f69
   14af4:	6d305b1b 	.word	0x6d305b1b
   14af8:	0000000a 	.word	0x0000000a
   14afc:	44202020 	.word	0x44202020
   14b00:	47554245 	.word	0x47554245
   14b04:	3b305b1b 	.word	0x3b305b1b
   14b08:	3a6d3439 	.word	0x3a6d3439
   14b0c:	1b3a7325 	.word	0x1b3a7325
   14b10:	393b305b 	.word	0x393b305b
   14b14:	73256d32 	.word	0x73256d32
   14b18:	305b1b3a 	.word	0x305b1b3a
   14b1c:	6d33393b 	.word	0x6d33393b
   14b20:	203e6425 	.word	0x203e6425
   14b24:	3b305b1b 	.word	0x3b305b1b
   14b28:	736d3733 	.word	0x736d3733
   14b2c:	20646e65 	.word	0x20646e65
   14b30:	7830203d 	.word	0x7830203d
   14b34:	5b1b5825 	.word	0x5b1b5825
   14b38:	000a6d30 	.word	0x000a6d30
   14b3c:	31345b1b 	.word	0x31345b1b
   14b40:	4952436d 	.word	0x4952436d
   14b44:	41434954 	.word	0x41434954
   14b48:	305b1b4c 	.word	0x305b1b4c
   14b4c:	6d34393b 	.word	0x6d34393b
   14b50:	3a73253a 	.word	0x3a73253a
   14b54:	3b305b1b 	.word	0x3b305b1b
   14b58:	256d3239 	.word	0x256d3239
   14b5c:	5b1b3a73 	.word	0x5b1b3a73
   14b60:	33393b30 	.word	0x33393b30
   14b64:	3e64256d 	.word	0x3e64256d
   14b68:	305b1b20 	.word	0x305b1b20
   14b6c:	6d37333b 	.word	0x6d37333b
   14b70:	65737341 	.word	0x65737341
   14b74:	6f697472 	.word	0x6f697472
   14b78:	6146206e 	.word	0x6146206e
   14b7c:	72756c69 	.word	0x72756c69
   14b80:	43202c65 	.word	0x43202c65
   14b84:	69646e6f 	.word	0x69646e6f
   14b88:	6e6f6974 	.word	0x6e6f6974
   14b8c:	73655420 	.word	0x73655420
   14b90:	3a646574 	.word	0x3a646574
   14b94:	656c2820 	.word	0x656c2820
   14b98:	756e5f64 	.word	0x756e5f64
   14b9c:	7265626d 	.word	0x7265626d
   14ba0:	34203c20 	.word	0x34203c20
   14ba4:	20200a29 	.word	0x20200a29
   14ba8:	20202020 	.word	0x20202020
   14bac:	20202020 	.word	0x20202020
   14bb0:	75706e49 	.word	0x75706e49
   14bb4:	654c2074 	.word	0x654c2074
   14bb8:	756e2064 	.word	0x756e2064
   14bbc:	7265626d 	.word	0x7265626d
   14bc0:	6e616320 	.word	0x6e616320
   14bc4:	62207427 	.word	0x62207427
   14bc8:	72672065 	.word	0x72672065
   14bcc:	65746165 	.word	0x65746165
   14bd0:	68742072 	.word	0x68742072
   14bd4:	33206e61 	.word	0x33206e61
   14bd8:	6e69202c 	.word	0x6e69202c
   14bdc:	20747570 	.word	0x20747570
   14be0:	6425203d 	.word	0x6425203d
   14be4:	5b1b0a2e 	.word	0x5b1b0a2e
   14be8:	5b1b6d30 	.word	0x5b1b6d30
   14bec:	000a6d30 	.word	0x000a6d30
   14bf0:	6972500a 	.word	0x6972500a
   14bf4:	6e69746e 	.word	0x6e69746e
   14bf8:	74532067 	.word	0x74532067
   14bfc:	206b6361 	.word	0x206b6361
   14c00:	63617254 	.word	0x63617254
   14c04:	000a3a65 	.word	0x000a3a65
   14c08:	32345b1b 	.word	0x32345b1b
   14c0c:	2020206d 	.word	0x2020206d
   14c10:	464e4920 	.word	0x464e4920
   14c14:	305b1b4f 	.word	0x305b1b4f
   14c18:	6d34393b 	.word	0x6d34393b
   14c1c:	3a73253a 	.word	0x3a73253a
   14c20:	3b305b1b 	.word	0x3b305b1b
   14c24:	256d3239 	.word	0x256d3239
   14c28:	5b1b3a73 	.word	0x5b1b3a73
   14c2c:	33393b30 	.word	0x33393b30
   14c30:	3e64256d 	.word	0x3e64256d
   14c34:	305b1b20 	.word	0x305b1b20
   14c38:	6d37333b 	.word	0x6d37333b
   14c3c:	72617453 	.word	0x72617453
   14c40:	20676e69 	.word	0x20676e69
   14c44:	6c6c6548 	.word	0x6c6c6548
   14c48:	6f57206f 	.word	0x6f57206f
   14c4c:	20646c72 	.word	0x20646c72
   14c50:	6c707041 	.word	0x6c707041
   14c54:	74616369 	.word	0x74616369
   14c58:	1b6e6f69 	.word	0x1b6e6f69
   14c5c:	0a6d305b 	.word	0x0a6d305b
   14c60:	00000000 	.word	0x00000000
   14c64:	32345b1b 	.word	0x32345b1b
   14c68:	2020206d 	.word	0x2020206d
   14c6c:	464e4920 	.word	0x464e4920
   14c70:	305b1b4f 	.word	0x305b1b4f
   14c74:	6d34393b 	.word	0x6d34393b
   14c78:	3a73253a 	.word	0x3a73253a
   14c7c:	3b305b1b 	.word	0x3b305b1b
   14c80:	256d3239 	.word	0x256d3239
   14c84:	5b1b3a73 	.word	0x5b1b3a73
   14c88:	33393b30 	.word	0x33393b30
   14c8c:	3e64256d 	.word	0x3e64256d
   14c90:	305b1b20 	.word	0x305b1b20
   14c94:	6d37333b 	.word	0x6d37333b
   14c98:	74696e49 	.word	0x74696e49
   14c9c:	696c6169 	.word	0x696c6169
   14ca0:	676e697a 	.word	0x676e697a
   14ca4:	44454c20 	.word	0x44454c20
   14ca8:	2e2e2e73 	.word	0x2e2e2e73
   14cac:	6d305b1b 	.word	0x6d305b1b
   14cb0:	0000000a 	.word	0x0000000a
   14cb4:	32345b1b 	.word	0x32345b1b
   14cb8:	2020206d 	.word	0x2020206d
   14cbc:	464e4920 	.word	0x464e4920
   14cc0:	305b1b4f 	.word	0x305b1b4f
   14cc4:	6d34393b 	.word	0x6d34393b
   14cc8:	3a73253a 	.word	0x3a73253a
   14ccc:	3b305b1b 	.word	0x3b305b1b
   14cd0:	256d3239 	.word	0x256d3239
   14cd4:	5b1b3a73 	.word	0x5b1b3a73
   14cd8:	33393b30 	.word	0x33393b30
   14cdc:	3e64256d 	.word	0x3e64256d
   14ce0:	305b1b20 	.word	0x305b1b20
   14ce4:	6d37333b 	.word	0x6d37333b
   14ce8:	7344454c 	.word	0x7344454c
   14cec:	696e4920 	.word	0x696e4920
   14cf0:	6c616974 	.word	0x6c616974
   14cf4:	64657a69 	.word	0x64657a69
   14cf8:	305b1b21 	.word	0x305b1b21
   14cfc:	00000a6d 	.word	0x00000a6d
   14d00:	32345b1b 	.word	0x32345b1b
   14d04:	2020206d 	.word	0x2020206d
   14d08:	464e4920 	.word	0x464e4920
   14d0c:	305b1b4f 	.word	0x305b1b4f
   14d10:	6d34393b 	.word	0x6d34393b
   14d14:	3a73253a 	.word	0x3a73253a
   14d18:	3b305b1b 	.word	0x3b305b1b
   14d1c:	256d3239 	.word	0x256d3239
   14d20:	5b1b3a73 	.word	0x5b1b3a73
   14d24:	33393b30 	.word	0x33393b30
   14d28:	3e64256d 	.word	0x3e64256d
   14d2c:	305b1b20 	.word	0x305b1b20
   14d30:	6d37333b 	.word	0x6d37333b
   14d34:	6c6c6548 	.word	0x6c6c6548
   14d38:	6f57206f 	.word	0x6f57206f
   14d3c:	20646c72 	.word	0x20646c72
   14d40:	58257830 	.word	0x58257830
   14d44:	6d305b1b 	.word	0x6d305b1b
   14d48:	ffff000a 	.word	0xffff000a

00014d4c <sjsu::lpc40xx::Gpio::ValidPortCheck() const::file>:
   14d4c:	6f697067 7070682e ffffff00              gpio.hpp....

00014d58 <sjsu::lpc40xx::Gpio::SetInterruptEdge(sjsu::Gpio::Edge) const::file>:
   14d58:	6f697067 7070682e ffffff00              gpio.hpp....

00014d64 <sjsu::OnBoardLed::On(unsigned char)::file>:
   14d64:	6f626e6f 5f647261 2e64656c 00707068     onboard_led.hpp.

00014d74 <sjsu::OnBoardLed::Off(unsigned char)::file>:
   14d74:	6f626e6f 5f647261 2e64656c 00707068     onboard_led.hpp.

00014d84 <sjsu::OnBoardLed::Set(unsigned char, sjsu::OnBoardLed::LightState)::file>:
   14d84:	6f626e6f 5f647261 2e64656c 00707068     onboard_led.hpp.

00014d94 <main::file>:
   14d94:	6e69616d 7070632e ffffff00              main.cpp....

00014da0 <main::file>:
   14da0:	6e69616d 7070632e ffffff00              main.cpp....

00014dac <main::file>:
   14dac:	6e69616d 7070632e ffffff00              main.cpp....

00014db8 <main::file>:
   14db8:	6e69616d 7070632e ffffff00              main.cpp....

00014dc4 <vtable for sjsu::lpc40xx::Gpio>:
	...
   14dcc:	000108cd 00010975 0001099d 000109e1     ....u...........
   14ddc:	000109f9 00010a41 00010ba5 00010bd3     ....A...........

00014dec <vtable for sjsu::lpc40xx::Pin>:
	...
   14df4:	0001037d 000103f9 00010505 00010481     }...............

00014e04 <main::__PRETTY_FUNCTION__>:
   14e04:	20746e69 6e69616d ff002928              int main()..

00014e10 <sjsu::lpc40xx::Gpio::ValidPortCheck() const::__PRETTY_FUNCTION__>:
   14e10:	6c6f6f62 736a7320 6c3a3a75 30346370     bool sjsu::lpc40
   14e20:	3a3a7878 6f697047 61563a3a 5064696c     xx::Gpio::ValidP
   14e30:	4374726f 6b636568 63202928 74736e6f     ortCheck() const
   14e40:	ffffff00                                ....

00014e44 <sjsu::lpc40xx::Gpio::SetInterruptEdge(sjsu::Gpio::Edge) const::__PRETTY_FUNCTION__>:
   14e44:	64696f76 736a7320 6c3a3a75 30346370     void sjsu::lpc40
   14e54:	3a3a7878 6f697047 65533a3a 746e4974     xx::Gpio::SetInt
   14e64:	75727265 64457470 73286567 3a75736a     erruptEdge(sjsu:
   14e74:	6970473a 453a3a6f 29656764 6e6f6320     :Gpio::Edge) con
   14e84:	ff007473                                st..

00014e88 <sjsu::OnBoardLed::Set(unsigned char, sjsu::OnBoardLed::LightState)::__PRETTY_FUNCTION__>:
   14e88:	64696f76 736a7320 4f3a3a75 616f426e     void sjsu::OnBoa
   14e98:	654c6472 533a3a64 75287465 38746e69     rdLed::Set(uint8
   14ea8:	202c745f 75736a73 6e4f3a3a 72616f42     _t, sjsu::OnBoar
   14eb8:	64654c64 694c3a3a 53746867 65746174     dLed::LightState
   14ec8:	ffff0029                                )...

00014ecc <sjsu::OnBoardLed::On(unsigned char)::__PRETTY_FUNCTION__>:
   14ecc:	64696f76 736a7320 4f3a3a75 616f426e     void sjsu::OnBoa
   14edc:	654c6472 4f3a3a64 6975286e 5f38746e     rdLed::On(uint8_
   14eec:	ff002974                                t)..

00014ef0 <sjsu::OnBoardLed::Off(unsigned char)::__PRETTY_FUNCTION__>:
   14ef0:	64696f76 736a7320 4f3a3a75 616f426e     void sjsu::OnBoa
   14f00:	654c6472 4f3a3a64 75286666 38746e69     rdLed::Off(uint8
   14f10:	0029745f 00000000 746f6f62 64616f6c     _t).....bootload
   14f20:	00007265 6c707061 74616369 006e6f69     er..application.
   14f30:	74736f68 73657420 00000074 64252020     host test...  %d
   14f40:	78302029 58383025 0000000a 25783020     ) 0x%08X.... 0x%
   14f50:	00583830 64252020 78302029 000a7025     08X.  %d) 0x%p..
   14f60:	6e75520a 6874203a 6f662065 776f6c6c     .Run: the follow
   14f70:	20676e69 6d6d6f63 20646e61 79206e69     ing command in y
   14f80:	2072756f 6a6f7270 20746365 65726964     our project dire
   14f90:	726f7463 00000079 20200a0a 3b315b1b     ctory.....  .[1;
   14fa0:	006d3733 656b616d 61747320 72746b63     37m.make stacktr
   14fb0:	2d656361 54207325 45434152 00223d53     ace-%s TRACES=".
   14fc0:	25783020 00000070 1b0a0a22 006d305b      0x%p..."...[0m.
   14fd0:	73696854 6c697720 6572206c 74726f70     This will report
   14fe0:	65687420 6c696620 6e612065 696c2064      the file and li
   14ff0:	6e20656e 65626d75 68742072 6c207461     ne number that l
   15000:	74206465 6874206f 66207369 74636e75     ed to this funct
   15010:	206e6f69 6e696562 61632067 64656c6c     ion being called
   15020:	0000002e 31345b1b 4952436d 41434954     .....[41mCRITICA
   15030:	305b1b4c 6d34393b 3a73253a 3b305b1b     L.[0;94m:%s:.[0;
   15040:	256d3239 5b1b3a73 33393b30 3e64256d     92m%s:.[0;93m%d>
   15050:	305b1b20 6d37333b 65737341 6f697472      .[0;37mAssertio
   15060:	6146206e 72756c69 43202c65 69646e6f     n Failure, Condi
   15070:	6e6f6974 73655420 3a646574 65702820     tion Tested: (pe
   15080:	68706972 6c617265 7669645f 72656469     ripheral_divider
   15090:	203d3c20 200a2934 20202020 20202020      <= 4).         
   150a0:	76694420 72656469 73756d20 74276e74      Divider mustn't
   150b0:	63786520 20646565 5b1b3233 5b1b6d30      exceed 32.[0m.[
   150c0:	000a6d30 6972500a 6e69746e 74532067     0m...Printing St
   150d0:	206b6361 63617254 000a3a65 31345b1b     ack Trace:...[41
   150e0:	4952436d 41434954 305b1b4c 6d34393b     mCRITICAL.[0;94m
   150f0:	3a73253a 3b305b1b 256d3239 5b1b3a73     :%s:.[0;92m%s:.[
   15100:	33393b30 3e64256d 305b1b20 6d37333b     0;93m%d> .[0;37m
   15110:	65737341 6f697472 6146206e 72756c69     Assertion Failur
   15120:	43202c65 69646e6f 6e6f6974 73655420     e, Condition Tes
   15130:	3a646574 65642820 65726973 70735f64     ted: (desired_sp
   15140:	5f646565 6d5f6e69 3c207a68 34383320     eed_in_mhz < 384
   15150:	20262620 69736564 5f646572 65657073      && desired_spee
   15160:	6e695f64 7a686d5f 31203e20 200a2932     d_in_mhz > 12). 
   15170:	20202020 20202020 65724620 6e657571              Frequen
   15180:	6d207963 20747375 6c206562 7265776f     cy must be lower
   15190:	61687420 3833206e 484d2034 646e617a      than 384 MHzand
   151a0:	65726720 72657461 61687420 726f206e      greater than or
   151b0:	75716520 74206c61 3231206f 7a484d20      equal to 12 MHz
   151c0:	6d305b1b 6d305b1b 0000000a 31345b1b     .[0m.[0m.....[41
   151d0:	4952436d 41434954 305b1b4c 6d34393b     mCRITICAL.[0;94m
   151e0:	3a73253a 3b305b1b 256d3239 5b1b3a73     :%s:.[0;92m%s:.[
   151f0:	33393b30 3e64256d 305b1b20 6d37333b     0;93m%d> .[0;37m
   15200:	65737341 6f697472 6146206e 72756c69     Assertion Failur
   15210:	43202c65 69646e6f 6e6f6974 73655420     e, Condition Tes
   15220:	3a646574 69642820 65646976 61765f72     ted: (divider_va
   15230:	2065756c 2938203c 2020200a 20202020     lue < 8).       
   15240:	50202020 64204c4c 64697669 76207265        PLL divider v
   15250:	65756c61 6e657720 756f2074 666f2074     alue went out of
   15260:	756f6220 1b73646e 1b6d305b 0a6d305b      bounds.[0m.[0m.
   15270:	00000000 31345b1b 4952436d 41434954     .....[41mCRITICA
   15280:	305b1b4c 6d34393b 3a73253a 3b305b1b     L.[0;94m:%s:.[0;
   15290:	256d3239 5b1b3a73 33393b30 3e64256d     92m%s:.[0;93m%d>
   152a0:	305b1b20 6d37333b 65737341 6f697472      .[0;37mAssertio
   152b0:	6146206e 72756c69 43202c65 69646e6f     n Failure, Condi
   152c0:	6e6f6974 73655420 3a646574 61662820     tion Tested: (fa
   152d0:	2965736c 2020200a 20202020 50202020     lse).          P
   152e0:	6c204c4c 206b636f 6c756f63 6f6e2064     LL lock could no
   152f0:	65622074 74736520 696c6261 64656873     t be established
   15300:	66656220 2065726f 656d6974 1b74756f      before timeout.
   15310:	1b6d305b 0a6d305b 00000000 31345b1b     [0m.[0m......[41
   15320:	4952436d 41434954 305b1b4c 6d34393b     mCRITICAL.[0;94m
   15330:	3a73253a 3b305b1b 256d3239 5b1b3a73     :%s:.[0;92m%s:.[
   15340:	33393b30 3e64256d 305b1b20 6d37333b     0;93m%d> .[0;37m
   15350:	65737341 6f697472 6146206e 72756c69     Assertion Failur
   15360:	43202c65 69646e6f 6e6f6974 73655420     e, Condition Tes
   15370:	3a646574 70632820 69645f75 65646976     ted: (cpu_divide
   15380:	203c2072 0a293233 20202020 20202020     r < 32).        
   15390:	69442020 65646976 756d2072 276e7473       Divider mustn'
   153a0:	78652074 64656563 1b323320 1b6d305b     t exceed 32.[0m.
   153b0:	0a6d305b 00000000 31345b1b 4952436d     [0m......[41mCRI
   153c0:	41434954 305b1b4c 6d34393b 3a73253a     TICAL.[0;94m:%s:
   153d0:	3b305b1b 256d3239 5b1b3a73 33393b30     .[0;92m%s:.[0;93
   153e0:	3e64256d 305b1b20 6d37333b 65737341     m%d> .[0;37mAsse
   153f0:	6f697472 6146206e 72756c69 43202c65     rtion Failure, C
   15400:	69646e6f 6e6f6974 73655420 3a646574     ondition Tested:
   15410:	72662820 65757165 2079636e 30203d21      (frequency != 0
   15420:	20200a29 20202020 20202020 6e6e6143     ).          Cann
   15430:	6820746f 20657661 6f72657a 63697420     ot have zero tic
   15440:	7020736b 6d207265 6f726369 6f636573     ks per microseco
   15450:	202c646e 61656c70 63206573 736f6f68     nd, please choos
   15460:	20312065 6d20726f 2e65726f 6d305b1b     e 1 or more..[0m
   15470:	6d305b1b 0000000a 31345b1b 4952436d     .[0m.....[41mCRI
   15480:	41434954 305b1b4c 6d34393b 3a73253a     TICAL.[0;94m:%s:
   15490:	3b305b1b 256d3239 5b1b3a73 33393b30     .[0;92m%s:.[0;93
   154a0:	3e64256d 305b1b20 6d37333b 65737341     m%d> .[0;37mAsse
   154b0:	6f697472 6146206e 72756c69 43202c65     rtion Failure, C
   154c0:	69646e6f 6e6f6974 73655420 3a646574     ondition Tested:
   154d0:	616d2820 5f686374 69676572 72657473      (match_register
   154e0:	33203e20 20200a29 20202020 20202020      > 3).          
   154f0:	20656854 3443504c 20787830 206e6163     The LPC40xx can 
   15500:	796c6e6f 73616820 6d203320 68637461     only has 3 match
   15510:	67657220 65747369 202e7372 61206e41      registers. An a
   15520:	6d657474 74207470 6573206f 616d2074     ttempt to set ma
   15530:	20686374 69676572 72657473 20642520     tch register %d 
   15540:	20736177 65747461 6574706d 5b1b2e64     was attempted..[
   15550:	5b1b6d30 000a6d30 31345b1b 4952436d     0m.[0m...[41mCRI
   15560:	41434954 305b1b4c 6d34393b 3a73253a     TICAL.[0;94m:%s:
   15570:	3b305b1b 256d3239 5b1b3a73 33393b30     .[0;92m%s:.[0;93
   15580:	3e64256d 305b1b20 6d37333b 65737341     m%d> .[0;37mAsse
   15590:	6f697472 6146206e 72756c69 43202c65     rtion Failure, C
   155a0:	69646e6f 6e6f6974 73655420 3a646574     ondition Tested:
   155b0:	69742820 5f72656d 72617473 74735f74      (timer_start_st
   155c0:	73757461 203d3d20 75736a73 74533a3a     atus == sjsu::St
   155d0:	73757461 536b3a3a 65636375 0a297373     atus::kSuccess).
   155e0:	20202020 20202020 79532020 6d657473               System
   155f0:	6d695420 28207265 64657375 20796220      Timer (used by 
   15600:	65657246 534f5452 61682029 41462073     FreeRTOS) has FA
   15610:	44454c49 206f7420 72617473 5b1b2174     ILED to start!.[
   15620:	5b1b6d30 000a6d30                       0m.[0m..

00015628 <sjsu::lpc40xx::SystemController::SetPeripheralClockDivider(unsigned char) const::file>:
   15628:	74737973 635f6d65 72746e6f 656c6c6f     system_controlle
   15638:	70682e72 ffff0070                       r.hpp...

00015640 <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const::file>:
   15640:	74737973 635f6d65 72746e6f 656c6c6f     system_controlle
   15650:	70682e72 ffff0070                       r.hpp...

00015658 <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const::file>:
   15658:	74737973 635f6d65 72746e6f 656c6c6f     system_controlle
   15668:	70682e72 ffff0070                       r.hpp...

00015670 <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const::file>:
   15670:	74737973 635f6d65 72746e6f 656c6c6f     system_controlle
   15680:	70682e72 ffff0070                       r.hpp...

00015688 <sjsu::lpc40xx::SystemController::SetCpuClockDivider(unsigned char) const::file>:
   15688:	74737973 635f6d65 72746e6f 656c6c6f     system_controlle
   15698:	70682e72 ffff0070                       r.hpp...

000156a0 <sjsu::lpc40xx::Timer::Channel::kTimerPartial0>:
   156a0:	40004000 00000001 00000001 10000320     .@.@........ ...

000156b0 <sjsu::lpc40xx::Timer::Channel::kTimer0>:
   156b0:	000156a0 00011e71                       .V..q...

000156b8 <sjsu::lpc40xx::Timer::Initialize(unsigned long, void (*)(), long) const::file>:
   156b8:	656d6974 70682e72 ffff0070              timer.hpp...

000156c4 <sjsu::lpc40xx::Timer::SetTimer(unsigned long, sjsu::Timer::TimerIsrCondition, unsigned char) const::file>:
   156c4:	656d6974 70682e72 ffff0070              timer.hpp...

000156d0 <sjsu::lpc40xx::Uart::kBaudRateLUT>:
   156d0:	00000271 00000000 00000001 000000d0     q...............
   156e0:	00000001 00000002 00000068 00000001     ........h.......
   156f0:	00000002 00000034 00000001 00000002     ....4...........
   15700:	00000023 00000001 00000002 0000001a     #...............
   15710:	00000000 00000001 0000000d 00000000     ................
   15720:	00000001 00000004 00000002 00000003     ................
   15730:	00000002 00000002 00000003              ............

0001573c <sjsu::lpc40xx::Uart::Port::kUart0Tx>:
   1573c:	00014df4 00000200                       .M......

00015744 <sjsu::lpc40xx::Uart::Port::kUart0Rx>:
   15744:	00014df4 00000300                       .M......

0001574c <sjsu::lpc40xx::Uart::Port::kUart0>:
   1574c:	4000c000 00000003 0001573c 00015744     ...@....<W..DW..
   1575c:	00000009                                ....

00015760 <vtable for sjsu::lpc40xx::Uart>:
	...
   15768:	00011b15 000119b1 00011bfd 00011cd3     ................
   15778:	fffffffc 00000000 00011165 000111e9     ........e.......
   15788:	0001123d 0001125d 00011279 000112ad     =...]...y.......
   15798:	000112e9 00011325                       ....%...

000157a0 <vtable for sjsu::lpc40xx::Timer>:
	...
   157a8:	000117f5 000118dd 00011991 fffffffc     ................
   157b8:	00000000 00011165 000111e9 0001123d     ....e.......=...
   157c8:	0001125d 00011279 000112ad 000112e9     ]...y...........
   157d8:	00011325                                %...

000157dc <vtable for sjsu::Timer>:
	...
   157e4:	000134ed 000134ed 000134ed              .4...4...4..

000157f0 <vtable for sjsu::lpc40xx::SystemController>:
	...
   157f8:	00011165 000111e9 0001123d 0001125d     e.......=...]...
   15808:	00011279 000112ad 000112e9 00011325     y...........%...

00015818 <vtable for sjsu::SystemController>:
	...
   15820:	000134ed 000134ed 000134ed 000134ed     .4...4...4...4..
   15830:	000134ed 000134ed 000134ed 000134ed     .4...4...4...4..

00015840 <sjsu::lpc40xx::SystemController::SetPeripheralClockDivider(unsigned char) const::__PRETTY_FUNCTION__>:
   15840:	74726976 206c6175 64696f76 736a7320     virtual void sjs
   15850:	6c3a3a75 30346370 3a3a7878 74737953     u::lpc40xx::Syst
   15860:	6f436d65 6f72746e 72656c6c 65533a3a     emController::Se
   15870:	72655074 65687069 436c6172 6b636f6c     tPeripheralClock
   15880:	69766944 28726564 746e6975 29745f38     Divider(uint8_t)
   15890:	6e6f6320 ff007473                        const..

00015898 <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const::__PRETTY_FUNCTION__>:
   15898:	746e6975 745f3233 736a7320 6c3a3a75     uint32_t sjsu::l
   158a8:	30346370 3a3a7878 74737953 6f436d65     pc40xx::SystemCo
   158b8:	6f72746e 72656c6c 65533a3a 69614d74     ntroller::SetMai
   158c8:	6c6c506e 736a7328 6c3a3a75 30346370     nPll(sjsu::lpc40
   158d8:	3a3a7878 74737953 6f436d65 6f72746e     xx::SystemContro
   158e8:	72656c6c 6c503a3a 706e496c 202c7475     ller::PllInput, 
   158f8:	746e6975 745f3631 6f632029 0074736e     uint16_t) const.

00015908 <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const::__PRETTY_FUNCTION__>:
   15908:	746e6975 745f3233 736a7320 6c3a3a75     uint32_t sjsu::l
   15918:	30346370 3a3a7878 74737953 6f436d65     pc40xx::SystemCo
   15928:	6f72746e 72656c6c 61433a3a 6c75636c     ntroller::Calcul
   15938:	50657461 73286c6c 3a75736a 63706c3a     atePll(sjsu::lpc
   15948:	78783034 79533a3a 6d657473 746e6f43     40xx::SystemCont
   15958:	6c6c6f72 3a3a7265 496c6c50 7475706e     roller::PllInput
   15968:	6975202c 3631746e 2029745f 736e6f63     , uint16_t) cons
   15978:	ffff0074                                t...

0001597c <sjsu::lpc40xx::SystemController::SetCpuClockDivider(unsigned char) const::__PRETTY_FUNCTION__>:
   1597c:	64696f76 736a7320 6c3a3a75 30346370     void sjsu::lpc40
   1598c:	3a3a7878 74737953 6f436d65 6f72746e     xx::SystemContro
   1599c:	72656c6c 65533a3a 75704374 636f6c43     ller::SetCpuCloc
   159ac:	7669446b 72656469 6e697528 745f3874     kDivider(uint8_t
   159bc:	6f632029 0074736e                       ) const.

000159c4 <sjsu::lpc40xx::Timer::Initialize(unsigned long, void (*)(), long) const::__PRETTY_FUNCTION__>:
   159c4:	74726976 206c6175 75736a73 74533a3a     virtual sjsu::St
   159d4:	73757461 736a7320 6c3a3a75 30346370     atus sjsu::lpc40
   159e4:	3a3a7878 656d6954 493a3a72 6974696e     xx::Timer::Initi
   159f4:	7a696c61 69752865 3233746e 202c745f     alize(uint32_t, 
   15a04:	50727349 746e696f 202c7265 33746e69     IsrPointer, int3
   15a14:	29745f32 6e6f6320 ff007473              2_t) const..

00015a20 <sjsu::lpc40xx::Timer::SetTimer(unsigned long, sjsu::Timer::TimerIsrCondition, unsigned char) const::__PRETTY_FUNCTION__>:
   15a20:	74726976 206c6175 64696f76 736a7320     virtual void sjs
   15a30:	6c3a3a75 30346370 3a3a7878 656d6954     u::lpc40xx::Time
   15a40:	533a3a72 69547465 2872656d 746e6975     r::SetTimer(uint
   15a50:	745f3233 6a73202c 3a3a7573 656d6954     32_t, sjsu::Time
   15a60:	543a3a72 72656d69 43727349 69646e6f     r::TimerIsrCondi
   15a70:	6e6f6974 6975202c 5f38746e 63202974     tion, uint8_t) c
   15a80:	74736e6f ffffff00 00000000 746f6f62     onst........boot
   15a90:	64616f6c 00007265 6c707061 74616369     loader..applicat
   15aa0:	006e6f69 74736f68 73657420 00000074     ion.host test...
   15ab0:	64252020 78302029 58383025 0000000a       %d) 0x%08X....
   15ac0:	25783020 00583830 64252020 78302029      0x%08X.  %d) 0x
   15ad0:	000a7025 6e75520a 6874203a 6f662065     %p...Run: the fo
   15ae0:	776f6c6c 20676e69 6d6d6f63 20646e61     llowing command 
   15af0:	79206e69 2072756f 6a6f7270 20746365     in your project 
   15b00:	65726964 726f7463 00000079 20200a0a     directory.....  
   15b10:	3b315b1b 006d3733 656b616d 61747320     .[1;37m.make sta
   15b20:	72746b63 2d656361 54207325 45434152     cktrace-%s TRACE
   15b30:	00223d53 25783020 00000070 1b0a0a22     S=". 0x%p..."...
   15b40:	006d305b 73696854 6c697720 6572206c     [0m.This will re
   15b50:	74726f70 65687420 6c696620 6e612065     port the file an
   15b60:	696c2064 6e20656e 65626d75 68742072     d line number th
   15b70:	6c207461 74206465 6874206f 66207369     at led to this f
   15b80:	74636e75 206e6f69 6e696562 61632067     unction being ca
   15b90:	64656c6c 0000002e 31345b1b 4952436d     lled.....[41mCRI
   15ba0:	41434954 305b1b4c 6d34393b 3a73253a     TICAL.[0;94m:%s:
   15bb0:	3b305b1b 256d3239 5b1b3a73 33393b30     .[0;92m%s:.[0;93
   15bc0:	3e64256d 305b1b20 6d37333b 65737341     m%d> .[0;37mAsse
   15bd0:	6f697472 6146206e 72756c69 43202c65     rtion Failure, C
   15be0:	69646e6f 6e6f6974 73655420 3a646574     ondition Tested:
   15bf0:	73692820 3d212072 746e4920 75727265      (isr != Interru
   15c00:	6f4c7470 70756b6f 646e6148 2972656c     ptLookupHandler)
   15c10:	2020200a 20202020 4e202020 5349206f     .          No IS
   15c20:	6f662052 20646e75 20726f66 20656874     R found for the 
   15c30:	74636576 2520726f 305b1b75 305b1b6d     vector %u.[0m.[0
   15c40:	00000a6d 6972500a 6e69746e 74532067     m....Printing St
   15c50:	206b6361 63617254 000a3a65 31345b1b     ack Trace:...[41
   15c60:	7261486d 61462064 20746c75 65637845     mHard Fault Exce
   15c70:	6f697470 634f206e 72727563 0a216465     ption Occurred!.
   15c80:	6d305b1b 00000000 203a3072 30257830     .[0m....r0: 0x%0
   15c90:	2c586c38 3a317220 25783020 586c3830     8lX, r1: 0x%08lX
   15ca0:	3272202c 7830203a 6c383025 72202c58     , r2: 0x%08lX, r
   15cb0:	30203a33 38302578 000a586c 3a323172     3: 0x%08lX..r12:
   15cc0:	25783020 586c3830 726c202c 7830203a      0x%08lX, lr: 0x
   15cd0:	6c383025 70202c58 30203a63 38302578     %08lX, pc: 0x%08
   15ce0:	202c586c 3a727370 25783020 586c3830     lX, psr: 0x%08lX
   15cf0:	ffff000a                                ....

00015cf4 <InterruptLookupHandler::file>:
   15cf4:	65746e69 70757272 70632e74 ffff0070     interrupt.cpp...

00015d04 <InterruptLookupHandler::__PRETTY_FUNCTION__>:
   15d04:	64696f76 746e4920 75727265 6f4c7470     void InterruptLo
   15d14:	70756b6f 646e6148 2872656c ffff0029     okupHandler()...

00015d24 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)::pow10>:
   15d24:	3f800000 41200000 42c80000 447a0000     ...?.. A...B..zD
   15d34:	461c4000 47c35000 49742400 4b189680     .@.F.P.G.$tI...K
   15d44:	4cbebc20 4e6e6b28                        ..L(knN

00015d4c <__sf_fake_stderr>:
	...

00015d6c <__sf_fake_stdin>:
	...

00015d8c <__sf_fake_stdout>:
	...
