
build/application/firmware.elf:     file format elf32-littlearm
build/application/firmware.elf
architecture: arm, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00011db1

Program Header:
0x70000001 off    0x000161e4 vaddr 0x000161e4 paddr 0x000161e4 align 2**2
         filesz 0x00000438 memsz 0x00000438 flags r--
    LOAD off    0x00010000 vaddr 0x00010000 paddr 0x00010000 align 2**16
         filesz 0x0000661c memsz 0x0000661c flags r-x
    LOAD off    0x00020000 vaddr 0x10000000 paddr 0x0001661c align 2**16
         filesz 0x000001f0 memsz 0x000001f0 flags rw-
    LOAD off    0x000201f0 vaddr 0x100001f0 paddr 0x100001f0 align 2**16
         filesz 0x00000000 memsz 0x000001b8 flags rw-
private flags = 5000400: [Version5 EABI] [hard-float ABI]

Sections:
Idx Name             Size      VMA       LMA       File off  Algn  Flags
  0 .text            00005d1c  00010000  00010000  00010000  2**4  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data            000001f0  10000000  0001661c  00020000  2**2  CONTENTS, ALLOC, LOAD, DATA
  2 .data_RAM2       00000000  20000000  20000000  000201f0  2**2  CONTENTS
  3 .bss             000001b8  100001f0  100001f0  000201f0  2**3  ALLOC
  4 .ARM.extab       000004c8  00015d1c  00015d1c  00015d1c  2**2  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .ARM.exidx       00000438  000161e4  000161e4  000161e4  2**2  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .uninit_RESERVED 00000000  10000000  10000000  000201f0  2**2  CONTENTS
  7 .noinit_RAM2     00000000  20000000  20000000  000201f0  2**2  CONTENTS
  8 .noinit          00000000  100003a8  100003a8  000201f0  2**2  CONTENTS
  9 .ARM.attributes  00000030  00000000  00000000  000201f0  2**0  CONTENTS, READONLY
 10 .comment         0000007e  00000000  00000000  00020220  2**0  CONTENTS, READONLY
 11 .debug_info      000344d8  00000000  00000000  0002029e  2**0  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev    00003917  00000000  00000000  00054776  2**0  CONTENTS, READONLY, DEBUGGING
 13 .debug_aranges   00000930  00000000  00000000  0005808d  2**0  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges    000008c0  00000000  00000000  000589bd  2**0  CONTENTS, READONLY, DEBUGGING
 15 .debug_line      00005691  00000000  00000000  0005927d  2**0  CONTENTS, READONLY, DEBUGGING
 16 .debug_str       0001a850  00000000  00000000  0005e90e  2**0  CONTENTS, READONLY, DEBUGGING
 17 .debug_frame     000030d4  00000000  00000000  00079160  2**2  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
00010000 l    d  .text	00000000 .text
10000000 l    d  .data	00000000 .data
20000000 l    d  .data_RAM2	00000000 .data_RAM2
100001f0 l    d  .bss	00000000 .bss
00015d1c l    d  .ARM.extab	00000000 .ARM.extab
000161e4 l    d  .ARM.exidx	00000000 .ARM.exidx
10000000 l    d  .uninit_RESERVED	00000000 .uninit_RESERVED
20000000 l    d  .noinit_RAM2	00000000 .noinit_RAM2
100003a8 l    d  .noinit	00000000 .noinit
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 interrupt.cpp
00011e3c l     F .text	00000034 NVIC_EnableIRQ
00011e70 l     F .text	0000005c NVIC_SetPriority
00010000 l     O .text	000000e4 kInterruptVectorTable
00015c64 l     O .text	0000000e InterruptLookupHandler::file
00015c74 l     O .text	0000001e InterruptLookupHandler::__PRETTY_FUNCTION__
00010254 l       .text	00000000 handler2_address_const
00000000 l    df *ABS*	00000000 startup.cpp
000157b0 l     O .text	00000057 sjsu::lpc40xx::SystemController::SetPeripheralClockDivider(unsigned char) const::__PRETTY_FUNCTION__
00015878 l     O .text	00000072 sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const::__PRETTY_FUNCTION__
00015808 l     O .text	00000070 sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const::__PRETTY_FUNCTION__
000158ec l     O .text	00000048 sjsu::lpc40xx::SystemController::SetCpuClockDivider(unsigned char) const::__PRETTY_FUNCTION__
00015934 l     O .text	0000005b sjsu::lpc40xx::Timer::Initialize(unsigned long, void (*)(), long) const::__PRETTY_FUNCTION__
00015990 l     O .text	00000065 sjsu::lpc40xx::Timer::SetTimer(unsigned long, sjsu::Timer::TimerIsrCondition, unsigned char) const::__PRETTY_FUNCTION__
1000009c l     O .data	00000004 (anonymous namespace)::system_controller
1000031c l     O .bss	0000000c (anonymous namespace)::timer0
00011cfc l     F .text	0000001c (anonymous namespace)::Lpc40xxUptime()
000102fc l     O .text	00000004 kCrpWord
00011df4 l     F .text	00000038 __static_initialization_and_destruction_0(int, int)
00011e2c l     F .text	00000010 _GLOBAL__sub_I_UptimeRTOS
00000000 l    df *ABS*	00000000 /home/kammce/Documents/SJSU-Dev2/tools/gcc-arm-none-eabi-7-2017-q4-major/bin/../lib/gcc/arm-none-eabi/7.2.1/thumb/v7e-m/fpv4-sp/hard/crti.o
00000000 l    df *ABS*	00000000 /home/kammce/Documents/SJSU-Dev2/tools/gcc-arm-none-eabi-7-2017-q4-major/bin/../lib/gcc/arm-none-eabi/7.2.1/thumb/v7e-m/fpv4-sp/hard/crtn.o
00000000 l    df *ABS*	00000000 crtstuff.c
00010320 l     F .text	00000000 __do_global_dtors_aux
100001f0 l       .bss	00000001 completed.9929
00010344 l     F .text	00000000 frame_dummy
100001f4 l       .bss	00000018 object.9934
0001030c l     O .text	00000000 __frame_dummy_init_array_entry
00000000 l    df *ABS*	00000000 main.cpp
0001057c l     F .text	00000026 _Unwind_GetGR
000105f0 l     F .text	00000048 sjsu::debug::PrintAddressAsList(_Unwind_Context*, void*)
00010638 l     F .text	00000044 sjsu::debug::PrintAddressInRow(_Unwind_Context*, void*)
10000210 l     O .bss	00000008 sjsu::(anonymous namespace)::uptime
00010720 l     F .text	00000018 sjsu::(anonymous namespace)::DefaultUptime()
00014d80 l     O .text	00000031 sjsu::lpc40xx::Gpio::ValidPortCheck() const::__PRETTY_FUNCTION__
00014db4 l     O .text	00000043 sjsu::lpc40xx::Gpio::SetInterruptEdge(sjsu::Gpio::Edge) const::__PRETTY_FUNCTION__
00014e3c l     O .text	00000023 sjsu::OnBoardLed::On(unsigned char)::__PRETTY_FUNCTION__
00014e60 l     O .text	00000024 sjsu::OnBoardLed::Off(unsigned char)::__PRETTY_FUNCTION__
00014df8 l     O .text	00000042 sjsu::OnBoardLed::Set(unsigned char, sjsu::OnBoardLed::LightState)::__PRETTY_FUNCTION__
00014d04 l     O .text	00000009 main::file
00014d10 l     O .text	00000009 main::file
00014d1c l     O .text	00000009 main::file
00014d28 l     O .text	00000009 main::file
00014d74 l     O .text	0000000b main::__PRETTY_FUNCTION__
00000000 l    df *ABS*	00000000 newlib.cpp
00000000 l    df *ABS*	00000000 tasks.c
1000032c l     O .bss	00000064 pxReadyTasksLists
10000390 l     O .bss	00000004 uxTopReadyPriority
10000394 l     O .bss	00000004 xYieldPending
10000398 l     O .bss	00000004 uxSchedulerSuspended
1000039c l     O .bss	00000004 ulTaskSwitchedInTime
100003a0 l     O .bss	00000004 ulTotalRunTime
00000000 l    df *ABS*	00000000 port.c
000121c0 l       .text	00000000 pxCurrentTCBConst2
00012230 l       .text	00000000 pxCurrentTCBConst
00000000 l    df *ABS*	00000000 printf.cpp
00012238 l     F .text	0000001c _out_null(char, void*, unsigned int, unsigned int)
00012254 l     F .text	00000026 _out_char(char, void*, unsigned int, unsigned int)
0001227a l     F .text	0000002e _strlen(char const*)
000122a8 l     F .text	00000028 _is_digit(char)
000122d0 l     F .text	00000048 _atoi(char const**)
00012318 l     F .text	00000242 _ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)
0001255a l     F .text	000000d0 _ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)
0001262a l     F .text	000000e0 _ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)
00015c94 l     O .text	00000028 _ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)::pow10
0001270c l     F .text	00000442 _ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)
00012b50 l     F .text	000008d4 _vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)
00000000 l    df *ABS*	00000000 pure.cc
00000000 l    df *ABS*	00000000 eh_terminate.cc
00000000 l    df *ABS*	00000000 _arm_truncdfsf2.o
00000000 l    df *ABS*	00000000 _aeabi_uldivmod.o
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 unwind-arm.c
00013824 l     F .text	00000012 selfrel_offset31
00013838 l     F .text	00000060 search_EIT_table
00013898 l     F .text	00000028 __gnu_unwind_get_pr_addr
000138c0 l     F .text	000000a4 get_eit_entry
00013964 l     F .text	00000058 restore_non_core_regs
000139bc l     F .text	0000000a _Unwind_decode_typeinfo_ptr.isra.0
000139c8 l     F .text	00000004 __gnu_unwind_24bit.isra.1
000139cc l     F .text	00000002 _Unwind_DebugHook
000139d0 l     F .text	0000003e unwind_phase2
00013a10 l     F .text	000000c6 unwind_phase2_forced
00013be0 l     F .text	00000018 _Unwind_GetGR
00013c24 l     F .text	0000001a _Unwind_SetGR
00013cb0 l     F .text	000002d4 __gnu_unwind_pr_common
00000000 l    df *ABS*	00000000 libunwind.o
00000000 l    df *ABS*	00000000 pr-support.c
000143bc l     F .text	00000038 next_unwind_byte
000143f4 l     F .text	0000001a _Unwind_GetGR.constprop.0
00014410 l     F .text	00000002 unwind_UCB_from_context
00000000 l    df *ABS*	00000000 _dvmd_tls.o
00000000 l    df *ABS*	00000000 abort.c
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 memcpy-stub.c
00000000 l    df *ABS*	00000000 signal.c
00000000 l    df *ABS*	00000000 signalr.c
00000000 l    df *ABS*	00000000 findfp.c
00000000 l    df *ABS*	00000000 eh_term_handler.cc
00000000 l    df *ABS*	00000000 impure.c
10000190 l     O .data	00000060 impure_data
00000000 l    df *ABS*	00000000 reent.c
00014374 g     F .text	00000022 .hidden ___Unwind_ForcedUnwind
00013adc g     F .text	0000005e .hidden __gnu_Unwind_RaiseException
00011ecc  w    F .text	00000068 Pwm0IrqHandler
0001023c g     F .text	00000026 HardFaultHandler
00012038 g     F .text	00000010 _getpid
00012064 g     F .text	00000020 _putchar
00010360  w    F .text	00000018 unsigned char sjsu::util::Value<sjsu::lpc40xx::Pin::PinBitMap, unsigned char>(sjsu::lpc40xx::Pin::PinBitMap)
00011ecc  w    F .text	00000068 EepromIrqHandler
00011ecc  w    F .text	00000068 Timer2IrqHandler
000155f8  w    O .text	00000016 sjsu::lpc40xx::SystemController::SetCpuClockDivider(unsigned char) const::file
00011b3e  w    F .text	0000002e sjsu::lpc40xx::Uart::Send(unsigned char) const::{lambda()#1}::operator()() const
00010998  w    F .text	00000044 sjsu::lpc40xx::Gpio::Toggle() const
00014804 g     F .text	00000024 _kill_r
0001010c g       .text	00000000 bss_section_table_end
00013424 g     F .text	00000038 printf
00011ecc  w    F .text	00000068 I2c1IrqHandler
000111ac  w    F .text	00000020 sjsu::lpc40xx::SystemController::GetPeripheralClockDivider() const
00010000 g       *ABS*	00000000 __vectors_start__
00011c14  w    F .text	0000002e sjsu::lpc40xx::Uart::Receive(unsigned long) const::{lambda()#1}::operator()() const
00010ec4  w    F .text	00000050 sjsu::OnBoardLed::SetAll(unsigned char)
00011ecc  w    F .text	00000068 BusFaultHandler
00015610  w    O .text	00000010 sjsu::lpc40xx::Timer::Channel::kTimerPartial0
0001067c  w    F .text	000000a4 sjsu::debug::PrintBacktrace(bool, void*)
20000000 g       *ABS*	00000000 __base_RAM2
00014230 g     F .text	00000000 .hidden __gnu_Unwind_Save_VFP
00014350 g     F .text	00000022 .hidden _Unwind_Resume_or_Rethrow
10000090  w    O .data	0000000c sjsu::lpc40xx::uart0
0001661c g       .ARM.exidx	00000000 __exidx_end
00013f84 g     F .text	00000004 .hidden __aeabi_unwind_cpp_pr0
000109dc  w    F .text	00000018 sjsu::lpc40xx::Gpio::ReadState() const
0001574c  w    O .text	00000014 vtable for sjsu::Timer
00011258  w    F .text	0000003c sjsu::lpc40xx::SystemController::PowerUpPeripheral(sjsu::SystemController::PeripheralID const&) const
10000328 g     O .bss	00000004 pxCurrentTCB
00014700 g     F .text	0000000a .hidden _Unwind_GetRegionStart
00014350 g     F .text	00000022 .hidden ___Unwind_Resume_or_Rethrow
00010bf8  w    F .text	0000005c sjsu::lpc40xx::Gpio::SetEdgeRising() const
100003a4 g     O .bss	00000004 errno
0001661c g       .ARM.exidx	00000000 _etext
00010500  w    F .text	0000007c sjsu::lpc40xx::Pin::SetAsOpenDrain(bool) const
0001133c  w    F .text	00000034 sjsu::lpc40xx::SystemController::SelectUsbClockSource(sjsu::lpc40xx::SystemController::UsbSource) const
00014398 g     F .text	00000022 .hidden _Unwind_Backtrace
10000000  w    O .data	00000004 sjsu::lpc40xx::Pin::pin_map
00011ecc  w    F .text	00000068 LcdIrqHandler
00080000 g       *ABS*	00000000 __top_MFlash512
00014210 g     F .text	00000018 .hidden __restore_core_regs
00014250 g     F .text	00000000 .hidden __gnu_Unwind_Save_VFP_D_16_to_31
0001105a  w    F .text	0000005a unsigned long sjsu::bit::Insert<unsigned long, bool>(unsigned long, bool, unsigned long, unsigned long)
00011ecc  w    F .text	00000068 I2c2IrqHandler
000156d0  w    O .text	00000040 vtable for sjsu::lpc40xx::Uart
00011ecc  w    F .text	00000068 CanIrqHandler
00011654  w    F .text	00000034 sjsu::lpc40xx::SystemController::SetEmcClockDivider(sjsu::lpc40xx::SystemController::EmcDivider) const
00013ad8 g     F .text	00000004 .hidden _Unwind_GetCFA
0001478c g     F .text	00000016 memcpy
00013bf8 g     F .text	0000002a .hidden _Unwind_VRS_Set
00013528 g     F .text	00000000 .hidden __aeabi_uldivmod
100003a8 g       .noinit	00000000 _noinit
00012084 g     F .text	00000048 puts
100000a0 g     O .data	000000e4 dynamic_isr_vector_table
00010e58  w    F .text	0000006c sjsu::OnBoardLed::Set(unsigned char, sjsu::OnBoardLed::LightState)
00011ecc  w    F .text	00000068 RitIrqHandler
00011ecc  w    F .text	00000068 Uart2IrqHandler
000147a2 g     F .text	00000050 _raise_r
10010000 g       *ABS*	00000000 __top_RAM
000121d0 g     F .text	00000066 xPortPendSVHandler
000110d4  w    F .text	00000084 sjsu::lpc40xx::SystemController::SetClockFrequency(unsigned char) const
10000000 g       *ABS*	00000000 __base_RamLoc64
10000184 g     O .data	00000004 out
0001047c  w    F .text	00000084 sjsu::lpc40xx::Pin::SetAsAnalogMode(bool) const
00014828 g     F .text	00000004 _getpid_r
00000000 g       *ABS*	00000000 __base_MFlash512
00013c40 g     F .text	00000070 .hidden __gnu_Unwind_Backtrace
000110b4  w    F .text	00000020 sjsu::SetUptimeFunction(unsigned long long (*)())
10010000 g       *ABS*	00000000 StackTop
00013558 g     F .text	000002cc .hidden __udivmoddi4
00011ecc  w    F .text	00000068 I2sIrqHandler
000100fc g       .text	00000000 bss_section_table
00014240 g     F .text	00000000 .hidden __gnu_Unwind_Save_VFP_D
00010300 g       .text	00000000 __CRP_WORD_END__
20008000 g       *ABS*	00000000 __top_RAM2
00011db0 g     F .text	00000030 ResetIsr
00013f90 g     F .text	0000027e .hidden _Unwind_VRS_Pop
00011ecc  w    F .text	00000068 PendSVHandler
00013f8c  w    F .text	00000004 .hidden __aeabi_unwind_cpp_pr2
00014398 g     F .text	00000022 .hidden ___Unwind_Backtrace
00011ecc  w    F .text	00000068 UsageFaultHandler
000113a4  w    F .text	000000e8 sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const
20000000 g       *ABS*	00000000 __user_heap_base
000161e4 g       .ARM.extab	00000000 __exidx_start
00011ecc  w    F .text	00000068 Uart4IrqHandler
00015788  w    O .text	00000028 vtable for sjsu::SystemController
00014744 g     F .text	00000048 __libc_init_array
00011ecc g     F .text	00000068 InterruptLookupHandler
00014308 g     F .text	00000022 .hidden ___Unwind_RaiseException
00014734 g     F .text	0000000e abort
0001432c g     F .text	00000022 .hidden ___Unwind_Resume
00011ecc  w    F .text	00000068 BodIrqHandler
00010738  w    F .text	00000024 sjsu::Milliseconds()
00014cc8  w    O .text	00000009 sjsu::lpc40xx::Gpio::SetInterruptEdge(sjsu::Gpio::Edge) const::file
00015634  w    O .text	0000000a sjsu::lpc40xx::Timer::SetTimer(unsigned long, sjsu::Timer::TimerIsrCondition, unsigned char) const::file
00010300 g     F .text	00000000 _init
0001010c g       .text	00000000 section_table_end
00010c54  w    F .text	0000005c sjsu::lpc40xx::Gpio::SetEdgeFalling() const
0001347c g     F .text	0000000a std::terminate()
00013488 g     F .text	0000009e .hidden __aeabi_d2f
00014258 g     F .text	00000000 .hidden __gnu_Unwind_Restore_WMMXD
00011920  w    F .text	00000164 sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const
00011ecc  w    F .text	00000068 SysTickHandler
000100e4 g       .text	00000000 section_table_start
00010bce  w    F .text	00000028 sjsu::lpc40xx::Gpio::DetachInterrupt() const
10000008  w    O .data	00000018 sjsu::lpc40xx::Gpio::gpio_port
100003a8 g       .bss	00000000 _ebss
00010e00  w    F .text	00000058 sjsu::OnBoardLed::Off(unsigned char)
0001087c  w    F .text	0000004c sjsu::lpc40xx::Gpio::SetAsOutput() const
00015760  w    O .text	00000028 vtable for sjsu::lpc40xx::SystemController
00010214 g     F .text	00000022 InitializeFloatingPointUnit()
00011ecc  w    F .text	00000068 RtcIrqHandler
000111cc  w    F .text	0000001c sjsu::lpc40xx::SystemController::GetSystemFrequency() const
000116bc  w    F .text	00000020 sjsu::Timer::Timer()
eff864de g       *ABS*	00000000 ValidUserCodeChecksum
000156b4  w    O .text	00000008 sjsu::lpc40xx::Uart::Port::kUart0Rx
00011ecc  w    F .text	00000068 Uart0IrqHandler
00011f8c g     F .text	0000007c GetRegistersFromStack
00015620  w    O .text	00000008 sjsu::lpc40xx::Timer::Channel::kTimer0
00011ecc  w    F .text	00000068 UsbIrqHandler
00011ecc  w    F .text	00000068 AdcIrqHandler
00014228 g     F .text	00000000 .hidden __gnu_Unwind_Restore_VFP
00015cbc g     O .text	00000020 __sf_fake_stderr
0001346c g     F .text	00000010 std::get_terminate()
0001432c g     F .text	00000022 .hidden _Unwind_Resume
00013ba8 g     F .text	0000000c .hidden _Unwind_DeleteException
00011ecc  w    F .text	00000068 EnetIrqHandler
10000218  w    O .bss	00000100 sjsu::lpc40xx::Gpio::interrupthandlers
00013ba4 g     F .text	00000002 .hidden _Unwind_Complete
00011308  w    F .text	00000034 sjsu::lpc40xx::SystemController::SelectMainClockSource(sjsu::lpc40xx::SystemController::MainClockSource) const
00011ecc  w    F .text	00000068 DmaIrqHandler
00011f34 g     F .text	00000058 RegisterIsr(IRQn, void (*)(), bool, long)
00000000 g       *ABS*	00000000 __base_Flash
00011ecc  w    F .text	00000068 Eint1IrqHandler
00011ecc  w    F .text	00000068 SvcHandler
00011ecc  w    F .text	00000068 GpioIrqHandler
00011ecc  w    F .text	00000068 SdioIrqHandler
10010000 g       *ABS*	00000000 __top_RamLoc64
100001f0 g       .bss	00000000 _bss
00011ecc  w    F .text	00000068 Pll1IrqHandler
00011ecc  w    F .text	00000068 MemManageHandler
00011688  w    F .text	00000032 sjsu::lpc40xx::Timer::TimerHandler(sjsu::lpc40xx::Timer::ChannelPartial_t const&)
0001345c g     F .text	00000006 __cxa_pure_virtual
00010aa8  w    F .text	0000003c sjsu::lpc40xx::Gpio::SetInterruptRoutine(void (*)()) const
00010830  w    F .text	0000004c sjsu::lpc40xx::Gpio::SetAsInput() const
00011ecc  w    F .text	00000068 Pwm1IrqHandler
10000088  w    O .data	00000004 sjsu::lpc40xx::SystemController::system_controller
00014414 g     F .text	000002c4 .hidden __gnu_unwind_execute
00011ecc  w    F .text	00000068 Timer0IrqHandler
00014238 g     F .text	00000000 .hidden __gnu_Unwind_Restore_VFP_D
00080000 g       *ABS*	00000000 __top_Flash
00010782  w    F .text	00000094 sjsu::Wait(unsigned long long)
00010fa8  w    F .text	0000005a unsigned long sjsu::bit::Insert<unsigned long, unsigned char>(unsigned long, unsigned char, unsigned long, unsigned long)
100003a8 g       .noinit	00000000 _end_noinit
000120cc g     F .text	000000c8 vTaskSwitchContext
00015710  w    O .text	0000003c vtable for sjsu::lpc40xx::Timer
00013b50 g     F .text	00000044 .hidden __gnu_Unwind_Resume
10000020  w    O .data	00000028 sjsu::lpc40xx::Gpio::interrupt
00015598  w    O .text	00000016 sjsu::lpc40xx::SystemController::SetPeripheralClockDivider(unsigned char) const::file
000116dc  w    F .text	00000020 sjsu::SystemController::SystemController()
00011de0  w    F .text	00000014 void sjsu::lpc40xx::Timer::TimerHandler<sjsu::lpc40xx::Timer::Channel::kTimerPartial0>()
00011ecc  w    F .text	00000068 Uart3IrqHandler
20000000 g       *ABS*	00000000 __base_RamPeriph32
00014248 g     F .text	00000000 .hidden __gnu_Unwind_Restore_VFP_D_16_to_31
00011d94 g     F .text	0000001c SystemInitialize()
00014308 g     F .text	00000022 .hidden _Unwind_RaiseException
00014730  w    F .text	00000002 .hidden __aeabi_ldiv0
00011ecc  w    F .text	00000068 Timer1IrqHandler
00011b6c  w    F .text	000000a8 sjsu::lpc40xx::Uart::Send(unsigned char) const
000100e4 g       .text	00000000 data_section_table
00010cb0  w    F .text	0000005c sjsu::lpc40xx::Gpio::ClearEdgeRising() const
000155e0  w    O .text	00000016 sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const::file
00015cdc g     O .text	00000020 __sf_fake_stdin
000102fc g       .text	00000000 __CRP_WORD_START__
000111e8  w    F .text	00000034 sjsu::lpc40xx::SystemController::GetPeripheralFrequency() const
00011c42  w    F .text	000000ba sjsu::lpc40xx::Uart::Receive(unsigned long) const
000115f0  w    F .text	00000064 sjsu::lpc40xx::SystemController::SetCpuClockDivider(unsigned char) const
00011ecc  w    F .text	00000068 Uart1IrqHandler
00010b1c  w    F .text	00000018 unsigned char sjsu::util::Value<sjsu::Gpio::Edge, unsigned char>(sjsu::Gpio::Edge)
00010f14 g     F .text	00000094 main
00010d68  w    F .text	0000003e sjsu::OnBoardLed::Initialize()
00011ecc  w    F .text	00000068 QeiIrqHandler
20000000 g       *ABS*	00000000 heap
00011ecc  w    F .text	00000068 Ssp2IrqHandler
000156bc  w    O .text	00000014 sjsu::lpc40xx::Uart::Port::kUart0
00014d5c  w    O .text	00000018 vtable for sjsu::lpc40xx::Pin
00013488 g     F .text	0000009e .hidden __truncdfsf2
00010314 g       .text	00000000 __init_array_end
000121a0 g     F .text	00000026 vPortSVCHandler
00012008 g     F .text	00000024 FirmwareStdOut(int)
00011ecc  w    F .text	00000068 Ssp1IrqHandler
00014cf4  w    O .text	00000010 sjsu::OnBoardLed::Set(unsigned char, sjsu::OnBoardLed::LightState)::file
00011158  w    F .text	00000054 sjsu::lpc40xx::SystemController::SetPeripheralClockDivider(unsigned char) const
0001184c  w    F .text	000000b4 sjsu::lpc40xx::Timer::SetTimer(unsigned long, sjsu::Timer::TimerIsrCondition, unsigned char) const
00010a54  w    F .text	00000054 sjsu::lpc40xx::Gpio::ValidPortCheck() const
00013b3c g     F .text	00000012 .hidden __gnu_Unwind_ForcedUnwind
00013b94 g     F .text	0000000e .hidden __gnu_Unwind_Resume_or_Rethrow
20008000 g       *ABS*	00000000 heap_end
00011764  w    F .text	000000e8 sjsu::lpc40xx::Timer::Initialize(unsigned long, void (*)(), long) const
00011ecc  w    F .text	00000068 Ssp0IrqHandler
00010314 g     F .text	00000000 _fini
00014210 g     F .text	00000018 .hidden restore_core_regs
0001121c  w    F .text	0000003c sjsu::lpc40xx::SystemController::IsPeripheralPoweredUp(sjsu::SystemController::PeripheralID const&) const
00011ecc  w    F .text	00000068 UsbactivityIrqHandler
000142f4 g     F .text	00000000 .hidden __gnu_Unwind_Save_WMMXC
0001075c  w    F .text	00000016 sjsu::Wait(unsigned long long)::{lambda()#1}::operator()() const
00011ecc  w    F .text	00000068 Pll0IrqHandler
000100fc g       .text	00000000 data_section_table_end
00011ecc  w    F .text	00000068 CanactivityIrqHandler
000109f4  w    F .text	00000048 sjsu::lpc40xx::Gpio::Read() const
00011ecc  w    F .text	00000068 NmiHandler
0001010c g     F .text	0000009c InitializeDataSection()
00014728 g     F .text	00000006 .hidden _Unwind_GetTextRelBase
000101a8 g     F .text	0000006c InitializeBssSection()
1000018c g     O .data	00000004 _impure_ptr
10000000 g       .uninit_RESERVED	00000000 _end_uninit_RESERVED
00011ecc  w    F .text	00000068 McpwmIrqHandler
0001030c g       .text	00000000 __preinit_array_end
00011ecc  w    F .text	00000068 WdtIrqHandler
00011900  w    F .text	0000001e sjsu::lpc40xx::Timer::GetTimer() const
10000000 g       .data	00000000 _data
00010930  w    F .text	00000040 sjsu::lpc40xx::Gpio::SetLow() const
00015640  w    O .text	0000006c sjsu::lpc40xx::Uart::kBaudRateLUT
0001470c g     F .text	00000012 .hidden _Unwind_GetLanguageSpecificData
00010ba0  w    F .text	0000002e sjsu::lpc40xx::Gpio::AttachInterrupt(void (*)(), sjsu::Gpio::Edge) const
00010970  w    F .text	00000028 sjsu::lpc40xx::Gpio::Set(sjsu::Gpio::State) const
00011720  w    F .text	00000044 sjsu::lpc40xx::Timer::Timer(sjsu::lpc40xx::Timer::Channel_t)
00010772  w    F .text	00000010 sjsu::Wait(unsigned long long)::{lambda()#1}::_FUN()
00013bb4 g     F .text	0000002a .hidden _Unwind_VRS_Get
10000188 g     O .data	00000004 __cxxabiv1::__terminate_handler
000142e0 g     F .text	00000000 .hidden __gnu_Unwind_Restore_WMMXC
00011294  w    F .text	0000003c sjsu::lpc40xx::SystemController::PowerDownPeripheral(sjsu::SystemController::PeripheralID const&) const
000112d0  w    F .text	00000038 sjsu::lpc40xx::SystemController::SelectOscillatorSource(sjsu::lpc40xx::SystemController::OscillatorSource) const
000146d8 g     F .text	00000028 .hidden __gnu_unwind_frame
00014374 g     F .text	00000022 .hidden _Unwind_ForcedUnwind
100001f0 g       .data	00000000 _edata
10000048  w    O .data	00000040 sjtwo::Leds()::leds_
000108c8  w    F .text	00000028 sjsu::lpc40xx::Gpio::SetDirection(sjsu::Gpio::Direction) const
10000318  w    O .bss	00000004 sjsu::lpc40xx::Timer::Channel::timer0_isr
00014d34  w    O .text	00000028 vtable for sjsu::lpc40xx::Gpio
00010d0c  w    F .text	0000005c sjsu::lpc40xx::Gpio::ClearEdgeFalling() const
00011ecc  w    F .text	00000068 DebugMonHandler
00011ecc  w    F .text	00000068 Eint2IrqHandler
00014cd4  w    O .text	00000010 sjsu::OnBoardLed::On(unsigned char)::file
20008000 g       *ABS*	00000000 __top_RamPeriph32
00011ecc  w    F .text	00000068 Timer3IrqHandler
00010b34  w    F .text	0000006c sjsu::lpc40xx::Gpio::SetInterruptEdge(sjsu::Gpio::Edge) const
10000000 g       *ABS*	00000000 __base_RAM
000155c8  w    O .text	00000016 sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const::file
00011ecc  w    F .text	00000068 Eint3IrqHandler
00015628  w    O .text	0000000a sjsu::lpc40xx::Timer::Initialize(unsigned long, void (*)(), long) const::file
00013462 g     F .text	00000008 __cxxabiv1::__terminate(void (*)())
000103f4  w    F .text	00000088 sjsu::lpc40xx::Pin::SetMode(sjsu::Pin::Mode) const
0001429c g     F .text	00000000 .hidden __gnu_Unwind_Save_WMMXD
00012048 g     F .text	0000001a _kill
00011002  w    F .text	00000058 unsigned long sjsu::bit::Insert<unsigned long, int>(unsigned long, int, unsigned long, unsigned long)
00011ecc  w    F .text	00000068 I2c0IrqHandler
00015cfc g     O .text	00000020 __sf_fake_stdout
000116bc  w    F .text	00000020 sjsu::Timer::Timer()
0001030c g       .text	00000000 __init_array_start
00014730  w    F .text	00000002 .hidden __aeabi_idiv0
00010816  w    F .text	0000001a sjsu::Delay(unsigned long long)
0001202c g     F .text	0000000c _exit
1000008c  w    O .data	00000004 sjsu::lpc40xx::SystemController::speed_in_hertz
00011ecc  w    F .text	00000068 Eint0IrqHandler
00010a3c  w    F .text	00000018 sjsu::lpc40xx::Gpio::GetPin() const
0001148c  w    F .text	00000164 sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const
00011720  w    F .text	00000044 sjsu::lpc40xx::Timer::Timer(sjsu::lpc40xx::Timer::Channel_t)
10000004  w    O .data	00000004 sjsu::Uptime
00010378  w    F .text	0000007c sjsu::lpc40xx::Pin::SetPinFunction(unsigned char) const
00013f88  w    F .text	00000004 .hidden __aeabi_unwind_cpp_pr1
00011d34  w    F .text	00000060 InitializePlatform()
00011d18 g     F .text	0000001c UptimeRTOS
000105a4  w    F .text	0000004c sjsu::build::Stringify(sjsu::build::Target)
000116dc  w    F .text	00000020 sjsu::SystemController::SystemController()
00014720 g     F .text	00000006 .hidden _Unwind_GetDataRelBase
00011ecc  w    F .text	00000068 SpiIrqHandler
000108f0  w    F .text	00000040 sjsu::lpc40xx::Gpio::SetHigh() const
0001030c g       .text	00000000 __preinit_array_start
00011370  w    F .text	00000034 sjsu::lpc40xx::SystemController::SelectSpifiClockSource(sjsu::lpc40xx::SystemController::SpifiSource) const
000116fc  w    F .text	00000024 sjsu::lpc40xx::SystemController::SystemController()
00014cbc  w    O .text	00000009 sjsu::lpc40xx::Gpio::ValidPortCheck() const::file
00010ae4  w    F .text	00000038 sjsu::lpc40xx::Gpio::ClearInterruptRoutine() const
00014ce4  w    O .text	00000010 sjsu::OnBoardLed::Off(unsigned char)::file
000156ac  w    O .text	00000008 sjsu::lpc40xx::Uart::Port::kUart0Tx
00010da8  w    F .text	00000058 sjsu::OnBoardLed::On(unsigned char)
00011a84  w    F .text	000000ba sjsu::lpc40xx::Uart::Initialize(unsigned long) const
000147f4 g     F .text	00000010 raise
000116fc  w    F .text	00000024 sjsu::lpc40xx::SystemController::SystemController()
000155b0  w    O .text	00000016 sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const::file



Disassembly of section .text:

00010000 <kInterruptVectorTable>:
   10000:	00 00 01 10 b1 1d 01 00 cd 1e 01 00 3d 02 01 00     ............=...
   10010:	cd 1e 01 00 cd 1e 01 00 cd 1e 01 00 de 64 f8 ef     .............d..
	...
   1002c:	a1 21 01 00 cd 1e 01 00 00 00 00 00 d1 21 01 00     .!...........!..
   1003c:	cd 1e 01 00 cd 1e 01 00 cd 1e 01 00 cd 1e 01 00     ................
   1004c:	cd 1e 01 00 cd 1e 01 00 cd 1e 01 00 cd 1e 01 00     ................
   1005c:	cd 1e 01 00 cd 1e 01 00 cd 1e 01 00 cd 1e 01 00     ................
   1006c:	cd 1e 01 00 cd 1e 01 00 00 00 00 00 cd 1e 01 00     ................
   1007c:	cd 1e 01 00 cd 1e 01 00 cd 1e 01 00 cd 1e 01 00     ................
   1008c:	cd 1e 01 00 cd 1e 01 00 cd 1e 01 00 cd 1e 01 00     ................
   1009c:	cd 1e 01 00 cd 1e 01 00 cd 1e 01 00 cd 1e 01 00     ................
   100ac:	cd 1e 01 00 cd 1e 01 00 cd 1e 01 00 cd 1e 01 00     ................
   100bc:	cd 1e 01 00 cd 1e 01 00 cd 1e 01 00 cd 1e 01 00     ................
   100cc:	cd 1e 01 00 cd 1e 01 00 cd 1e 01 00 cd 1e 01 00     ................
   100dc:	cd 1e 01 00 cd 1e 01 00                             ........

000100e4 <data_section_table>:
   100e4:	0001661c 	.word	0x0001661c
   100e8:	10000000 	.word	0x10000000
   100ec:	000001f0 	.word	0x000001f0
   100f0:	0001661c 	.word	0x0001661c
   100f4:	20000000 	.word	0x20000000
   100f8:	00000000 	.word	0x00000000

000100fc <bss_section_table>:
   100fc:	100001f0 	.word	0x100001f0
   10100:	000001b8 	.word	0x000001b8
   10104:	20000000 	.word	0x20000000
   10108:	00000000 	.word	0x00000000

0001010c <InitializeDataSection()>:
SJ2_WEAK(void InitializePlatform());

// Functions to carry out the initialization of RW and BSS data sections.
SJ2_SECTION(".after_vectors")
void InitializeDataSection()
{
   1010c:	b480      	push	{r7}
   1010e:	b087      	sub	sp, #28
   10110:	af00      	add	r7, sp, #0
  for (int i = 0; &data_section_table[i] < &data_section_table_end; i++)
   10112:	2300      	movs	r3, #0
   10114:	617b      	str	r3, [r7, #20]
   10116:	697a      	ldr	r2, [r7, #20]
   10118:	4613      	mov	r3, r2
   1011a:	005b      	lsls	r3, r3, #1
   1011c:	4413      	add	r3, r2
   1011e:	009b      	lsls	r3, r3, #2
   10120:	4a1f      	ldr	r2, [pc, #124]	; (101a0 <InitializeDataSection()+0x94>)
   10122:	4413      	add	r3, r2
   10124:	4a1f      	ldr	r2, [pc, #124]	; (101a4 <InitializeDataSection()+0x98>)
   10126:	4293      	cmp	r3, r2
   10128:	d233      	bcs.n	10192 <InitializeDataSection()+0x86>
  {
    uint32_t * rom_location = data_section_table[i].rom_location;
   1012a:	491d      	ldr	r1, [pc, #116]	; (101a0 <InitializeDataSection()+0x94>)
   1012c:	697a      	ldr	r2, [r7, #20]
   1012e:	4613      	mov	r3, r2
   10130:	005b      	lsls	r3, r3, #1
   10132:	4413      	add	r3, r2
   10134:	009b      	lsls	r3, r3, #2
   10136:	440b      	add	r3, r1
   10138:	681b      	ldr	r3, [r3, #0]
   1013a:	60fb      	str	r3, [r7, #12]
    uint32_t * ram_location = data_section_table[i].ram_location;
   1013c:	4918      	ldr	r1, [pc, #96]	; (101a0 <InitializeDataSection()+0x94>)
   1013e:	697a      	ldr	r2, [r7, #20]
   10140:	4613      	mov	r3, r2
   10142:	005b      	lsls	r3, r3, #1
   10144:	4413      	add	r3, r2
   10146:	009b      	lsls	r3, r3, #2
   10148:	440b      	add	r3, r1
   1014a:	685b      	ldr	r3, [r3, #4]
   1014c:	60bb      	str	r3, [r7, #8]
    uint32_t length         = data_section_table[i].length;
   1014e:	4914      	ldr	r1, [pc, #80]	; (101a0 <InitializeDataSection()+0x94>)
   10150:	697a      	ldr	r2, [r7, #20]
   10152:	4613      	mov	r3, r2
   10154:	005b      	lsls	r3, r3, #1
   10156:	4413      	add	r3, r2
   10158:	009b      	lsls	r3, r3, #2
   1015a:	440b      	add	r3, r1
   1015c:	3308      	adds	r3, #8
   1015e:	681b      	ldr	r3, [r3, #0]
   10160:	607b      	str	r3, [r7, #4]
    for (size_t j = 0; j < length; j++)
   10162:	2300      	movs	r3, #0
   10164:	613b      	str	r3, [r7, #16]
   10166:	693a      	ldr	r2, [r7, #16]
   10168:	687b      	ldr	r3, [r7, #4]
   1016a:	429a      	cmp	r2, r3
   1016c:	d20d      	bcs.n	1018a <InitializeDataSection()+0x7e>
    {
      ram_location[j] = rom_location[j];
   1016e:	693b      	ldr	r3, [r7, #16]
   10170:	009b      	lsls	r3, r3, #2
   10172:	68fa      	ldr	r2, [r7, #12]
   10174:	441a      	add	r2, r3
   10176:	693b      	ldr	r3, [r7, #16]
   10178:	009b      	lsls	r3, r3, #2
   1017a:	68b9      	ldr	r1, [r7, #8]
   1017c:	440b      	add	r3, r1
   1017e:	6812      	ldr	r2, [r2, #0]
   10180:	601a      	str	r2, [r3, #0]
    for (size_t j = 0; j < length; j++)
   10182:	693b      	ldr	r3, [r7, #16]
   10184:	3301      	adds	r3, #1
   10186:	613b      	str	r3, [r7, #16]
   10188:	e7ed      	b.n	10166 <InitializeDataSection()+0x5a>
  for (int i = 0; &data_section_table[i] < &data_section_table_end; i++)
   1018a:	697b      	ldr	r3, [r7, #20]
   1018c:	3301      	adds	r3, #1
   1018e:	617b      	str	r3, [r7, #20]
   10190:	e7c1      	b.n	10116 <InitializeDataSection()+0xa>
    }
  }
}
   10192:	bf00      	nop
   10194:	371c      	adds	r7, #28
   10196:	46bd      	mov	sp, r7
   10198:	f85d 7b04 	ldr.w	r7, [sp], #4
   1019c:	4770      	bx	lr
   1019e:	bf00      	nop
   101a0:	000100e4 	.word	0x000100e4
   101a4:	000100fc 	.word	0x000100fc

000101a8 <InitializeBssSection()>:

// Functions to initialization BSS data sections. This is important because
// the std c libs assume that BSS is set to zero.
SJ2_SECTION(".after_vectors")
void InitializeBssSection()
{
   101a8:	b480      	push	{r7}
   101aa:	b085      	sub	sp, #20
   101ac:	af00      	add	r7, sp, #0
  for (int i = 0; &bss_section_table[i] < &bss_section_table_end; i++)
   101ae:	2300      	movs	r3, #0
   101b0:	60fb      	str	r3, [r7, #12]
   101b2:	68fb      	ldr	r3, [r7, #12]
   101b4:	00db      	lsls	r3, r3, #3
   101b6:	4a15      	ldr	r2, [pc, #84]	; (1020c <InitializeBssSection()+0x64>)
   101b8:	4413      	add	r3, r2
   101ba:	4a15      	ldr	r2, [pc, #84]	; (10210 <InitializeBssSection()+0x68>)
   101bc:	4293      	cmp	r3, r2
   101be:	d21e      	bcs.n	101fe <InitializeBssSection()+0x56>
  {
    uint32_t * ram_location = bss_section_table[i].ram_location;
   101c0:	4a12      	ldr	r2, [pc, #72]	; (1020c <InitializeBssSection()+0x64>)
   101c2:	68fb      	ldr	r3, [r7, #12]
   101c4:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
   101c8:	607b      	str	r3, [r7, #4]
    uint32_t length         = bss_section_table[i].length;
   101ca:	4a10      	ldr	r2, [pc, #64]	; (1020c <InitializeBssSection()+0x64>)
   101cc:	68fb      	ldr	r3, [r7, #12]
   101ce:	00db      	lsls	r3, r3, #3
   101d0:	4413      	add	r3, r2
   101d2:	685b      	ldr	r3, [r3, #4]
   101d4:	603b      	str	r3, [r7, #0]
    for (size_t j = 0; j < length; j++)
   101d6:	2300      	movs	r3, #0
   101d8:	60bb      	str	r3, [r7, #8]
   101da:	68ba      	ldr	r2, [r7, #8]
   101dc:	683b      	ldr	r3, [r7, #0]
   101de:	429a      	cmp	r2, r3
   101e0:	d209      	bcs.n	101f6 <InitializeBssSection()+0x4e>
    {
      ram_location[j] = 0;
   101e2:	68bb      	ldr	r3, [r7, #8]
   101e4:	009b      	lsls	r3, r3, #2
   101e6:	687a      	ldr	r2, [r7, #4]
   101e8:	4413      	add	r3, r2
   101ea:	2200      	movs	r2, #0
   101ec:	601a      	str	r2, [r3, #0]
    for (size_t j = 0; j < length; j++)
   101ee:	68bb      	ldr	r3, [r7, #8]
   101f0:	3301      	adds	r3, #1
   101f2:	60bb      	str	r3, [r7, #8]
   101f4:	e7f1      	b.n	101da <InitializeBssSection()+0x32>
  for (int i = 0; &bss_section_table[i] < &bss_section_table_end; i++)
   101f6:	68fb      	ldr	r3, [r7, #12]
   101f8:	3301      	adds	r3, #1
   101fa:	60fb      	str	r3, [r7, #12]
   101fc:	e7d9      	b.n	101b2 <InitializeBssSection()+0xa>
    }
  }
}
   101fe:	bf00      	nop
   10200:	3714      	adds	r7, #20
   10202:	46bd      	mov	sp, r7
   10204:	f85d 7b04 	ldr.w	r7, [sp], #4
   10208:	4770      	bx	lr
   1020a:	bf00      	nop
   1020c:	000100fc 	.word	0x000100fc
   10210:	0001010c 	.word	0x0001010c

00010214 <InitializeFloatingPointUnit()>:
http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0553a/
BABGHFIB.html
*/
SJ2_SECTION(".after_vectors")
void InitializeFloatingPointUnit()
{
   10214:	b480      	push	{r7}
   10216:	af00      	add	r7, sp, #0
      // Write back the modified value to the CPACR
      "STR     R1, [R0]\n"
      // Wait for store to complete
      "DSB\n"
      // reset pipeline now the FPU is enabled
      "ISB\n");
   10218:	f8df 001c 	ldr.w	r0, [pc, #28]	; 10238 <InitializeFloatingPointUnit()+0x24>
   1021c:	6801      	ldr	r1, [r0, #0]
   1021e:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   10222:	6001      	str	r1, [r0, #0]
   10224:	f3bf 8f4f 	dsb	sy
   10228:	f3bf 8f6f 	isb	sy
}
   1022c:	bf00      	nop
   1022e:	46bd      	mov	sp, r7
   10230:	f85d 7b04 	ldr.w	r7, [sp], #4
   10234:	4770      	bx	lr
   10236:	0000      	.short	0x0000
   10238:	e000ed88 	.word	0xe000ed88

0001023c <HardFaultHandler>:
  sjsu::Halt();
}

SJ2_SECTION(".after_vectors")
void HardFaultHandler(void)
{
   1023c:	b480      	push	{r7}
   1023e:	af00      	add	r7, sp, #0
      " mrseq r0, msp                                       \n"
      " mrsne r0, psp                                       \n"
      " ldr r1, [r0, #24]                                   \n"
      " ldr r2, handler2_address_const                      \n"
      " bx r2                                               \n"
      " handler2_address_const: .word GetRegistersFromStack \n");
   10240:	f01e 0f04 	tst.w	lr, #4
   10244:	bf0c      	ite	eq
   10246:	f3ef 8008 	mrseq	r0, MSP
   1024a:	f3ef 8009 	mrsne	r0, PSP
   1024e:	6981      	ldr	r1, [r0, #24]
   10250:	4a00      	ldr	r2, [pc, #0]	; (10254 <handler2_address_const>)
   10252:	4710      	bx	r2

00010254 <handler2_address_const>:
   10254:	00011f8d 	.word	0x00011f8d
#endif
}
   10258:	bf00      	nop
   1025a:	46bd      	mov	sp, r7
   1025c:	f85d 7b04 	ldr.w	r7, [sp], #4
   10260:	4770      	bx	lr
   10262:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10266:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1026a:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1026e:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10272:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10276:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1027a:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1027e:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10282:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10286:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1028a:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1028e:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10292:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10296:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1029a:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1029e:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102a2:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102a6:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102aa:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102ae:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102b2:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102b6:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102ba:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102be:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102c2:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102c6:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102ca:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102ce:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102d2:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102d6:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102da:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102de:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102e2:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102e6:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102ea:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102ee:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102f2:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102f6:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102fa:	Address 0x00000000000102fa is out of bounds.


000102fc <__CRP_WORD_START__>:
   102fc:	ffffffff 	.word	0xffffffff

00010300 <_init>:
   10300:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   10302:	bf00      	nop
   10304:	bcf8      	pop	{r3, r4, r5, r6, r7}
   10306:	bc08      	pop	{r3}
   10308:	469e      	mov	lr, r3
   1030a:	4770      	bx	lr

0001030c <__init_array_start>:
   1030c:	00010345 	.word	0x00010345
   10310:	00011e2d 	.word	0x00011e2d

00010314 <_fini>:
   10314:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   10316:	bf00      	nop
   10318:	bcf8      	pop	{r3, r4, r5, r6, r7}
   1031a:	bc08      	pop	{r3}
   1031c:	469e      	mov	lr, r3
   1031e:	4770      	bx	lr

00010320 <__do_global_dtors_aux>:
   10320:	b510      	push	{r4, lr}
   10322:	4c05      	ldr	r4, [pc, #20]	; (10338 <__do_global_dtors_aux+0x18>)
   10324:	7823      	ldrb	r3, [r4, #0]
   10326:	b933      	cbnz	r3, 10336 <__do_global_dtors_aux+0x16>
   10328:	4b04      	ldr	r3, [pc, #16]	; (1033c <__do_global_dtors_aux+0x1c>)
   1032a:	b113      	cbz	r3, 10332 <__do_global_dtors_aux+0x12>
   1032c:	4804      	ldr	r0, [pc, #16]	; (10340 <__do_global_dtors_aux+0x20>)
   1032e:	f3af 8000 	nop.w
   10332:	2301      	movs	r3, #1
   10334:	7023      	strb	r3, [r4, #0]
   10336:	bd10      	pop	{r4, pc}
   10338:	100001f0 	.word	0x100001f0
   1033c:	00000000 	.word	0x00000000
   10340:	000161e4 	.word	0x000161e4

00010344 <frame_dummy>:
   10344:	b508      	push	{r3, lr}
   10346:	4b03      	ldr	r3, [pc, #12]	; (10354 <frame_dummy+0x10>)
   10348:	b11b      	cbz	r3, 10352 <frame_dummy+0xe>
   1034a:	4903      	ldr	r1, [pc, #12]	; (10358 <frame_dummy+0x14>)
   1034c:	4803      	ldr	r0, [pc, #12]	; (1035c <frame_dummy+0x18>)
   1034e:	f3af 8000 	nop.w
   10352:	bd08      	pop	{r3, pc}
   10354:	00000000 	.word	0x00000000
   10358:	100001f4 	.word	0x100001f4
   1035c:	000161e4 	.word	0x000161e4

00010360 <unsigned char sjsu::util::Value<sjsu::lpc40xx::Pin::PinBitMap, unsigned char>(sjsu::lpc40xx::Pin::PinBitMap)>:
//
// @param enum_type_value variable you would like to get the value of.
// @return the value of the enum class type variable of with the underlying
//         type of the enum class.
template <typename Enum, typename Type = typename std::underlying_type_t<Enum>>
constexpr Type Value(Enum enum_type_value)
   10360:	b480      	push	{r7}
   10362:	b083      	sub	sp, #12
   10364:	af00      	add	r7, sp, #0
   10366:	4603      	mov	r3, r0
   10368:	71fb      	strb	r3, [r7, #7]
{
  return static_cast<Type>(enum_type_value);
   1036a:	79fb      	ldrb	r3, [r7, #7]
}
   1036c:	4618      	mov	r0, r3
   1036e:	370c      	adds	r7, #12
   10370:	46bd      	mov	sp, r7
   10372:	f85d 7b04 	ldr.w	r7, [sp], #4
   10376:	4770      	bx	lr

00010378 <sjsu::lpc40xx::Pin::SetPinFunction(unsigned char) const>:
  static constexpr sjsu::lpc40xx::Pin CreateInactivePin()
  {
    return Pin(5, 4);
  }
  constexpr Pin(uint8_t port, uint8_t pin) : sjsu::Pin(port, pin) {}
  void SetPinFunction(uint8_t function) const override
   10378:	b590      	push	{r4, r7, lr}
   1037a:	b089      	sub	sp, #36	; 0x24
   1037c:	af00      	add	r7, sp, #0
   1037e:	6078      	str	r0, [r7, #4]
   10380:	460b      	mov	r3, r1
   10382:	70fb      	strb	r3, [r7, #3]
   10384:	687b      	ldr	r3, [r7, #4]
   10386:	613b      	str	r3, [r7, #16]
  }

 protected:
  [[gnu::always_inline]] volatile uint32_t * GetPinRegister() const
  {
    return &pin_map->_register[GetPort()][GetPin()];
   10388:	4b19      	ldr	r3, [pc, #100]	; (103f0 <sjsu::lpc40xx::Pin::SetPinFunction(unsigned char) const+0x78>)
   1038a:	681a      	ldr	r2, [r3, #0]
   1038c:	693b      	ldr	r3, [r7, #16]
   1038e:	60fb      	str	r3, [r7, #12]
  virtual void SetMode(Pin::Mode mode) const              = 0;
  virtual void SetAsOpenDrain(bool set_as_open_drain = true) const = 0;
  virtual void SetAsAnalogMode(bool set_as_analog = true) const    = 0;

  [[gnu::always_inline]] uint8_t GetPort() const {
    return port_;
   10390:	68fb      	ldr	r3, [r7, #12]
   10392:	791b      	ldrb	r3, [r3, #4]
   10394:	4618      	mov	r0, r3
   10396:	693b      	ldr	r3, [r7, #16]
   10398:	60bb      	str	r3, [r7, #8]
  }[[gnu::always_inline]] uint8_t GetPin() const
  {
    return pin_;
   1039a:	68bb      	ldr	r3, [r7, #8]
   1039c:	795b      	ldrb	r3, [r3, #5]
   1039e:	4619      	mov	r1, r3
   103a0:	0143      	lsls	r3, r0, #5
   103a2:	440b      	add	r3, r1
   103a4:	009b      	lsls	r3, r3, #2
   103a6:	4413      	add	r3, r2
    *GetPinRegister() = bit::Insert(*GetPinRegister(), function,
   103a8:	681c      	ldr	r4, [r3, #0]
                                    util::Value(PinBitMap::kFunction), 3);
   103aa:	2000      	movs	r0, #0
   103ac:	f7ff ffd8 	bl	10360 <unsigned char sjsu::util::Value<sjsu::lpc40xx::Pin::PinBitMap, unsigned char>(sjsu::lpc40xx::Pin::PinBitMap)>
   103b0:	4603      	mov	r3, r0
    *GetPinRegister() = bit::Insert(*GetPinRegister(), function,
   103b2:	461a      	mov	r2, r3
   103b4:	78f9      	ldrb	r1, [r7, #3]
   103b6:	2303      	movs	r3, #3
   103b8:	4620      	mov	r0, r4
   103ba:	f000 fdf5 	bl	10fa8 <unsigned long sjsu::bit::Insert<unsigned long, unsigned char>(unsigned long, unsigned char, unsigned long, unsigned long)>
   103be:	4601      	mov	r1, r0
   103c0:	687b      	ldr	r3, [r7, #4]
   103c2:	61fb      	str	r3, [r7, #28]
    return &pin_map->_register[GetPort()][GetPin()];
   103c4:	4b0a      	ldr	r3, [pc, #40]	; (103f0 <sjsu::lpc40xx::Pin::SetPinFunction(unsigned char) const+0x78>)
   103c6:	681a      	ldr	r2, [r3, #0]
   103c8:	69fb      	ldr	r3, [r7, #28]
   103ca:	61bb      	str	r3, [r7, #24]
    return port_;
   103cc:	69bb      	ldr	r3, [r7, #24]
   103ce:	791b      	ldrb	r3, [r3, #4]
   103d0:	461c      	mov	r4, r3
   103d2:	69fb      	ldr	r3, [r7, #28]
   103d4:	617b      	str	r3, [r7, #20]
    return pin_;
   103d6:	697b      	ldr	r3, [r7, #20]
   103d8:	795b      	ldrb	r3, [r3, #5]
   103da:	4618      	mov	r0, r3
   103dc:	0163      	lsls	r3, r4, #5
   103de:	4403      	add	r3, r0
   103e0:	009b      	lsls	r3, r3, #2
   103e2:	4413      	add	r3, r2
    *GetPinRegister() = bit::Insert(*GetPinRegister(), function,
   103e4:	6019      	str	r1, [r3, #0]
  }
   103e6:	bf00      	nop
   103e8:	3724      	adds	r7, #36	; 0x24
   103ea:	46bd      	mov	sp, r7
   103ec:	bd90      	pop	{r4, r7, pc}
   103ee:	bf00      	nop
   103f0:	10000000 	.word	0x10000000

000103f4 <sjsu::lpc40xx::Pin::SetMode(sjsu::Pin::Mode) const>:
  void SetMode(sjsu::Pin::Mode mode) const override
   103f4:	b5b0      	push	{r4, r5, r7, lr}
   103f6:	b08a      	sub	sp, #40	; 0x28
   103f8:	af00      	add	r7, sp, #0
   103fa:	6078      	str	r0, [r7, #4]
   103fc:	460b      	mov	r3, r1
   103fe:	70fb      	strb	r3, [r7, #3]
    uint8_t ui_mode   = static_cast<uint8_t>(mode);
   10400:	78fb      	ldrb	r3, [r7, #3]
   10402:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
   10406:	687b      	ldr	r3, [r7, #4]
   10408:	617b      	str	r3, [r7, #20]
    return &pin_map->_register[GetPort()][GetPin()];
   1040a:	4b1b      	ldr	r3, [pc, #108]	; (10478 <sjsu::lpc40xx::Pin::SetMode(sjsu::Pin::Mode) const+0x84>)
   1040c:	681a      	ldr	r2, [r3, #0]
   1040e:	697b      	ldr	r3, [r7, #20]
   10410:	613b      	str	r3, [r7, #16]
    return port_;
   10412:	693b      	ldr	r3, [r7, #16]
   10414:	791b      	ldrb	r3, [r3, #4]
   10416:	4618      	mov	r0, r3
   10418:	697b      	ldr	r3, [r7, #20]
   1041a:	60fb      	str	r3, [r7, #12]
    return pin_;
   1041c:	68fb      	ldr	r3, [r7, #12]
   1041e:	795b      	ldrb	r3, [r3, #5]
   10420:	4619      	mov	r1, r3
   10422:	0143      	lsls	r3, r0, #5
   10424:	440b      	add	r3, r1
   10426:	009b      	lsls	r3, r3, #2
   10428:	4413      	add	r3, r2
    *GetPinRegister() = bit::Insert(*GetPinRegister(), ui_mode & 0b11,
   1042a:	681c      	ldr	r4, [r3, #0]
   1042c:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
   10430:	f003 0503 	and.w	r5, r3, #3
                                    util::Value(PinBitMap::kMode), 2);
   10434:	2003      	movs	r0, #3
   10436:	f7ff ff93 	bl	10360 <unsigned char sjsu::util::Value<sjsu::lpc40xx::Pin::PinBitMap, unsigned char>(sjsu::lpc40xx::Pin::PinBitMap)>
   1043a:	4603      	mov	r3, r0
    *GetPinRegister() = bit::Insert(*GetPinRegister(), ui_mode & 0b11,
   1043c:	461a      	mov	r2, r3
   1043e:	2302      	movs	r3, #2
   10440:	4629      	mov	r1, r5
   10442:	4620      	mov	r0, r4
   10444:	f000 fddd 	bl	11002 <unsigned long sjsu::bit::Insert<unsigned long, int>(unsigned long, int, unsigned long, unsigned long)>
   10448:	4601      	mov	r1, r0
   1044a:	687b      	ldr	r3, [r7, #4]
   1044c:	623b      	str	r3, [r7, #32]
    return &pin_map->_register[GetPort()][GetPin()];
   1044e:	4b0a      	ldr	r3, [pc, #40]	; (10478 <sjsu::lpc40xx::Pin::SetMode(sjsu::Pin::Mode) const+0x84>)
   10450:	681a      	ldr	r2, [r3, #0]
   10452:	6a3b      	ldr	r3, [r7, #32]
   10454:	61fb      	str	r3, [r7, #28]
    return port_;
   10456:	69fb      	ldr	r3, [r7, #28]
   10458:	791b      	ldrb	r3, [r3, #4]
   1045a:	461c      	mov	r4, r3
   1045c:	6a3b      	ldr	r3, [r7, #32]
   1045e:	61bb      	str	r3, [r7, #24]
    return pin_;
   10460:	69bb      	ldr	r3, [r7, #24]
   10462:	795b      	ldrb	r3, [r3, #5]
   10464:	4618      	mov	r0, r3
   10466:	0163      	lsls	r3, r4, #5
   10468:	4403      	add	r3, r0
   1046a:	009b      	lsls	r3, r3, #2
   1046c:	4413      	add	r3, r2
    *GetPinRegister() = bit::Insert(*GetPinRegister(), ui_mode & 0b11,
   1046e:	6019      	str	r1, [r3, #0]
  }
   10470:	bf00      	nop
   10472:	3728      	adds	r7, #40	; 0x28
   10474:	46bd      	mov	sp, r7
   10476:	bdb0      	pop	{r4, r5, r7, pc}
   10478:	10000000 	.word	0x10000000

0001047c <sjsu::lpc40xx::Pin::SetAsAnalogMode(bool) const>:
  void SetAsAnalogMode(bool set_as_analog = true) const override
   1047c:	b5b0      	push	{r4, r5, r7, lr}
   1047e:	b088      	sub	sp, #32
   10480:	af00      	add	r7, sp, #0
   10482:	6078      	str	r0, [r7, #4]
   10484:	460b      	mov	r3, r1
   10486:	70fb      	strb	r3, [r7, #3]
   10488:	687b      	ldr	r3, [r7, #4]
   1048a:	613b      	str	r3, [r7, #16]
    return &pin_map->_register[GetPort()][GetPin()];
   1048c:	4b1b      	ldr	r3, [pc, #108]	; (104fc <sjsu::lpc40xx::Pin::SetAsAnalogMode(bool) const+0x80>)
   1048e:	681a      	ldr	r2, [r3, #0]
   10490:	693b      	ldr	r3, [r7, #16]
   10492:	60fb      	str	r3, [r7, #12]
    return port_;
   10494:	68fb      	ldr	r3, [r7, #12]
   10496:	791b      	ldrb	r3, [r3, #4]
   10498:	4618      	mov	r0, r3
   1049a:	693b      	ldr	r3, [r7, #16]
   1049c:	60bb      	str	r3, [r7, #8]
    return pin_;
   1049e:	68bb      	ldr	r3, [r7, #8]
   104a0:	795b      	ldrb	r3, [r3, #5]
   104a2:	4619      	mov	r1, r3
   104a4:	0143      	lsls	r3, r0, #5
   104a6:	440b      	add	r3, r1
   104a8:	009b      	lsls	r3, r3, #2
   104aa:	4413      	add	r3, r2
        bit::Insert(*GetPinRegister(), !set_as_analog,
   104ac:	681c      	ldr	r4, [r3, #0]
   104ae:	78fb      	ldrb	r3, [r7, #3]
   104b0:	f083 0301 	eor.w	r3, r3, #1
   104b4:	b2dd      	uxtb	r5, r3
                    util::Value(PinBitMap::kAnalogDigitalMode), 1);
   104b6:	2007      	movs	r0, #7
   104b8:	f7ff ff52 	bl	10360 <unsigned char sjsu::util::Value<sjsu::lpc40xx::Pin::PinBitMap, unsigned char>(sjsu::lpc40xx::Pin::PinBitMap)>
   104bc:	4603      	mov	r3, r0
        bit::Insert(*GetPinRegister(), !set_as_analog,
   104be:	461a      	mov	r2, r3
   104c0:	2301      	movs	r3, #1
   104c2:	4629      	mov	r1, r5
   104c4:	4620      	mov	r0, r4
   104c6:	f000 fdc8 	bl	1105a <unsigned long sjsu::bit::Insert<unsigned long, bool>(unsigned long, bool, unsigned long, unsigned long)>
   104ca:	4601      	mov	r1, r0
   104cc:	687b      	ldr	r3, [r7, #4]
   104ce:	61fb      	str	r3, [r7, #28]
    return &pin_map->_register[GetPort()][GetPin()];
   104d0:	4b0a      	ldr	r3, [pc, #40]	; (104fc <sjsu::lpc40xx::Pin::SetAsAnalogMode(bool) const+0x80>)
   104d2:	681a      	ldr	r2, [r3, #0]
   104d4:	69fb      	ldr	r3, [r7, #28]
   104d6:	61bb      	str	r3, [r7, #24]
    return port_;
   104d8:	69bb      	ldr	r3, [r7, #24]
   104da:	791b      	ldrb	r3, [r3, #4]
   104dc:	461c      	mov	r4, r3
   104de:	69fb      	ldr	r3, [r7, #28]
   104e0:	617b      	str	r3, [r7, #20]
    return pin_;
   104e2:	697b      	ldr	r3, [r7, #20]
   104e4:	795b      	ldrb	r3, [r3, #5]
   104e6:	4618      	mov	r0, r3
   104e8:	0163      	lsls	r3, r4, #5
   104ea:	4403      	add	r3, r0
   104ec:	009b      	lsls	r3, r3, #2
   104ee:	4413      	add	r3, r2
    *GetPinRegister() =
   104f0:	6019      	str	r1, [r3, #0]
  }
   104f2:	bf00      	nop
   104f4:	3720      	adds	r7, #32
   104f6:	46bd      	mov	sp, r7
   104f8:	bdb0      	pop	{r4, r5, r7, pc}
   104fa:	bf00      	nop
   104fc:	10000000 	.word	0x10000000

00010500 <sjsu::lpc40xx::Pin::SetAsOpenDrain(bool) const>:
  void SetAsOpenDrain(bool set_as_open_drain = true) const override
   10500:	b590      	push	{r4, r7, lr}
   10502:	b089      	sub	sp, #36	; 0x24
   10504:	af00      	add	r7, sp, #0
   10506:	6078      	str	r0, [r7, #4]
   10508:	460b      	mov	r3, r1
   1050a:	70fb      	strb	r3, [r7, #3]
   1050c:	687b      	ldr	r3, [r7, #4]
   1050e:	613b      	str	r3, [r7, #16]
    return &pin_map->_register[GetPort()][GetPin()];
   10510:	4b19      	ldr	r3, [pc, #100]	; (10578 <sjsu::lpc40xx::Pin::SetAsOpenDrain(bool) const+0x78>)
   10512:	681a      	ldr	r2, [r3, #0]
   10514:	693b      	ldr	r3, [r7, #16]
   10516:	60fb      	str	r3, [r7, #12]
    return port_;
   10518:	68fb      	ldr	r3, [r7, #12]
   1051a:	791b      	ldrb	r3, [r3, #4]
   1051c:	4618      	mov	r0, r3
   1051e:	693b      	ldr	r3, [r7, #16]
   10520:	60bb      	str	r3, [r7, #8]
    return pin_;
   10522:	68bb      	ldr	r3, [r7, #8]
   10524:	795b      	ldrb	r3, [r3, #5]
   10526:	4619      	mov	r1, r3
   10528:	0143      	lsls	r3, r0, #5
   1052a:	440b      	add	r3, r1
   1052c:	009b      	lsls	r3, r3, #2
   1052e:	4413      	add	r3, r2
    *GetPinRegister() = bit::Insert(*GetPinRegister(), set_as_open_drain,
   10530:	681c      	ldr	r4, [r3, #0]
                                    util::Value(PinBitMap::kOpenDrain), 1);
   10532:	200a      	movs	r0, #10
   10534:	f7ff ff14 	bl	10360 <unsigned char sjsu::util::Value<sjsu::lpc40xx::Pin::PinBitMap, unsigned char>(sjsu::lpc40xx::Pin::PinBitMap)>
   10538:	4603      	mov	r3, r0
    *GetPinRegister() = bit::Insert(*GetPinRegister(), set_as_open_drain,
   1053a:	461a      	mov	r2, r3
   1053c:	78f9      	ldrb	r1, [r7, #3]
   1053e:	2301      	movs	r3, #1
   10540:	4620      	mov	r0, r4
   10542:	f000 fd8a 	bl	1105a <unsigned long sjsu::bit::Insert<unsigned long, bool>(unsigned long, bool, unsigned long, unsigned long)>
   10546:	4601      	mov	r1, r0
   10548:	687b      	ldr	r3, [r7, #4]
   1054a:	61fb      	str	r3, [r7, #28]
    return &pin_map->_register[GetPort()][GetPin()];
   1054c:	4b0a      	ldr	r3, [pc, #40]	; (10578 <sjsu::lpc40xx::Pin::SetAsOpenDrain(bool) const+0x78>)
   1054e:	681a      	ldr	r2, [r3, #0]
   10550:	69fb      	ldr	r3, [r7, #28]
   10552:	61bb      	str	r3, [r7, #24]
    return port_;
   10554:	69bb      	ldr	r3, [r7, #24]
   10556:	791b      	ldrb	r3, [r3, #4]
   10558:	461c      	mov	r4, r3
   1055a:	69fb      	ldr	r3, [r7, #28]
   1055c:	617b      	str	r3, [r7, #20]
    return pin_;
   1055e:	697b      	ldr	r3, [r7, #20]
   10560:	795b      	ldrb	r3, [r3, #5]
   10562:	4618      	mov	r0, r3
   10564:	0163      	lsls	r3, r4, #5
   10566:	4403      	add	r3, r0
   10568:	009b      	lsls	r3, r3, #2
   1056a:	4413      	add	r3, r2
    *GetPinRegister() = bit::Insert(*GetPinRegister(), set_as_open_drain,
   1056c:	6019      	str	r1, [r3, #0]
  }
   1056e:	bf00      	nop
   10570:	3724      	adds	r7, #36	; 0x24
   10572:	46bd      	mov	sp, r7
   10574:	bd90      	pop	{r4, r7, pc}
   10576:	bf00      	nop
   10578:	10000000 	.word	0x10000000

0001057c <_Unwind_GetGR>:
  _Unwind_Reason_Code __gnu_unwind_execute (_Unwind_Context *,
					    __gnu_unwind_state *);

  static inline _Unwind_Word
  _Unwind_GetGR (_Unwind_Context *context, int regno)
    {
   1057c:	b580      	push	{r7, lr}
   1057e:	b086      	sub	sp, #24
   10580:	af02      	add	r7, sp, #8
   10582:	6078      	str	r0, [r7, #4]
   10584:	6039      	str	r1, [r7, #0]
      _uw val;
      _Unwind_VRS_Get (context, _UVRSC_CORE, regno, _UVRSD_UINT32, &val);
   10586:	683a      	ldr	r2, [r7, #0]
   10588:	f107 030c 	add.w	r3, r7, #12
   1058c:	9300      	str	r3, [sp, #0]
   1058e:	2300      	movs	r3, #0
   10590:	2100      	movs	r1, #0
   10592:	6878      	ldr	r0, [r7, #4]
   10594:	f003 fb0e 	bl	13bb4 <_Unwind_VRS_Get>
      return val;
   10598:	68fb      	ldr	r3, [r7, #12]
    }
   1059a:	4618      	mov	r0, r3
   1059c:	3710      	adds	r7, #16
   1059e:	46bd      	mov	sp, r7
   105a0:	bd80      	pop	{r7, pc}
   105a2:	Address 0x00000000000105a2 is out of bounds.


000105a4 <sjsu::build::Stringify(sjsu::build::Target)>:
};

constexpr const Target kTarget = Target::TARGET;

constexpr const char * Stringify(Target target)
{
   105a4:	b480      	push	{r7}
   105a6:	b085      	sub	sp, #20
   105a8:	af00      	add	r7, sp, #0
   105aa:	6078      	str	r0, [r7, #4]
  const char * result = "";
   105ac:	4b0c      	ldr	r3, [pc, #48]	; (105e0 <sjsu::build::Stringify(sjsu::build::Target)+0x3c>)
   105ae:	60fb      	str	r3, [r7, #12]
  switch (target)
   105b0:	687b      	ldr	r3, [r7, #4]
   105b2:	2b01      	cmp	r3, #1
   105b4:	d007      	beq.n	105c6 <sjsu::build::Stringify(sjsu::build::Target)+0x22>
   105b6:	2b02      	cmp	r3, #2
   105b8:	d008      	beq.n	105cc <sjsu::build::Stringify(sjsu::build::Target)+0x28>
   105ba:	2b00      	cmp	r3, #0
   105bc:	d000      	beq.n	105c0 <sjsu::build::Stringify(sjsu::build::Target)+0x1c>
  {
    case Target::Bootloader: result = "bootloader"; break;
    case Target::Application: result = "application"; break;
    case Target::HostTest: result = "host test"; break;
    default: break;
   105be:	e008      	b.n	105d2 <sjsu::build::Stringify(sjsu::build::Target)+0x2e>
    case Target::Bootloader: result = "bootloader"; break;
   105c0:	4b08      	ldr	r3, [pc, #32]	; (105e4 <sjsu::build::Stringify(sjsu::build::Target)+0x40>)
   105c2:	60fb      	str	r3, [r7, #12]
   105c4:	e005      	b.n	105d2 <sjsu::build::Stringify(sjsu::build::Target)+0x2e>
    case Target::Application: result = "application"; break;
   105c6:	4b08      	ldr	r3, [pc, #32]	; (105e8 <sjsu::build::Stringify(sjsu::build::Target)+0x44>)
   105c8:	60fb      	str	r3, [r7, #12]
   105ca:	e002      	b.n	105d2 <sjsu::build::Stringify(sjsu::build::Target)+0x2e>
    case Target::HostTest: result = "host test"; break;
   105cc:	4b07      	ldr	r3, [pc, #28]	; (105ec <sjsu::build::Stringify(sjsu::build::Target)+0x48>)
   105ce:	60fb      	str	r3, [r7, #12]
   105d0:	bf00      	nop
  }
  return result;
   105d2:	68fb      	ldr	r3, [r7, #12]
}
   105d4:	4618      	mov	r0, r3
   105d6:	3714      	adds	r7, #20
   105d8:	46bd      	mov	sp, r7
   105da:	f85d 7b04 	ldr.w	r7, [sp], #4
   105de:	4770      	bx	lr
   105e0:	0001482c 	.word	0x0001482c
   105e4:	00014830 	.word	0x00014830
   105e8:	0001483c 	.word	0x0001483c
   105ec:	00014848 	.word	0x00014848

000105f0 <sjsu::debug::PrintAddressAsList(_Unwind_Context*, void*)>:
// ==============================================
// Hidden Backtrace Utility Functions
// ==============================================
static inline _Unwind_Reason_Code PrintAddressAsList(_Unwind_Context * context,
                                                     void * depth_pointer)
{
   105f0:	b580      	push	{r7, lr}
   105f2:	b084      	sub	sp, #16
   105f4:	af00      	add	r7, sp, #0
   105f6:	6078      	str	r0, [r7, #4]
   105f8:	6039      	str	r1, [r7, #0]
  int * depth      = static_cast<int *>(depth_pointer);
   105fa:	683b      	ldr	r3, [r7, #0]
   105fc:	60fb      	str	r3, [r7, #12]
  intptr_t address = static_cast<intptr_t>(_Unwind_GetIP(context));
   105fe:	210f      	movs	r1, #15
   10600:	6878      	ldr	r0, [r7, #4]
   10602:	f7ff ffbb 	bl	1057c <_Unwind_GetGR>
   10606:	4603      	mov	r3, r0
   10608:	f023 0301 	bic.w	r3, r3, #1
   1060c:	60bb      	str	r3, [r7, #8]
  printf("  %d) 0x%08" PRIXPTR "\n", *depth,
   1060e:	68fb      	ldr	r3, [r7, #12]
   10610:	6819      	ldr	r1, [r3, #0]
   10612:	68bb      	ldr	r3, [r7, #8]
   10614:	3b04      	subs	r3, #4
   10616:	461a      	mov	r2, r3
   10618:	4806      	ldr	r0, [pc, #24]	; (10634 <sjsu::debug::PrintAddressAsList(_Unwind_Context*, void*)+0x44>)
   1061a:	f002 ff03 	bl	13424 <printf>
         address - config::kBacktraceAddressOffset);
  (*depth)++;
   1061e:	68fb      	ldr	r3, [r7, #12]
   10620:	681b      	ldr	r3, [r3, #0]
   10622:	1c5a      	adds	r2, r3, #1
   10624:	68fb      	ldr	r3, [r7, #12]
   10626:	601a      	str	r2, [r3, #0]
  return _URC_NO_REASON;
   10628:	2300      	movs	r3, #0
}
   1062a:	4618      	mov	r0, r3
   1062c:	3710      	adds	r7, #16
   1062e:	46bd      	mov	sp, r7
   10630:	bd80      	pop	{r7, pc}
   10632:	bf00      	nop
   10634:	00014854 	.word	0x00014854

00010638 <sjsu::debug::PrintAddressInRow(_Unwind_Context*, void*)>:
static inline _Unwind_Reason_Code PrintAddressInRow(_Unwind_Context * context,
                                                    void * depth_pointer)
{
   10638:	b580      	push	{r7, lr}
   1063a:	b084      	sub	sp, #16
   1063c:	af00      	add	r7, sp, #0
   1063e:	6078      	str	r0, [r7, #4]
   10640:	6039      	str	r1, [r7, #0]
  int * depth      = static_cast<int *>(depth_pointer);
   10642:	683b      	ldr	r3, [r7, #0]
   10644:	60fb      	str	r3, [r7, #12]
  intptr_t address = static_cast<intptr_t>(_Unwind_GetIP(context));
   10646:	210f      	movs	r1, #15
   10648:	6878      	ldr	r0, [r7, #4]
   1064a:	f7ff ff97 	bl	1057c <_Unwind_GetGR>
   1064e:	4603      	mov	r3, r0
   10650:	f023 0301 	bic.w	r3, r3, #1
   10654:	60bb      	str	r3, [r7, #8]
  printf(" 0x%08" PRIXPTR, address - config::kBacktraceAddressOffset);
   10656:	68bb      	ldr	r3, [r7, #8]
   10658:	3b04      	subs	r3, #4
   1065a:	4619      	mov	r1, r3
   1065c:	4806      	ldr	r0, [pc, #24]	; (10678 <sjsu::debug::PrintAddressInRow(_Unwind_Context*, void*)+0x40>)
   1065e:	f002 fee1 	bl	13424 <printf>
  (*depth)++;
   10662:	68fb      	ldr	r3, [r7, #12]
   10664:	681b      	ldr	r3, [r3, #0]
   10666:	1c5a      	adds	r2, r3, #1
   10668:	68fb      	ldr	r3, [r7, #12]
   1066a:	601a      	str	r2, [r3, #0]
  return _URC_NO_REASON;
   1066c:	2300      	movs	r3, #0
}
   1066e:	4618      	mov	r0, r3
   10670:	3710      	adds	r7, #16
   10672:	46bd      	mov	sp, r7
   10674:	bd80      	pop	{r7, pc}
   10676:	bf00      	nop
   10678:	00014864 	.word	0x00014864

0001067c <sjsu::debug::PrintBacktrace(bool, void*)>:
///        to print the file and line number that corrisponds to the printed
///        addresses.
/// @param length - the number of bytes to read from the starting location
inline void PrintBacktrace(bool show_make_command = false,
                           void * final_address   = nullptr)
{
   1067c:	b580      	push	{r7, lr}
   1067e:	b084      	sub	sp, #16
   10680:	af00      	add	r7, sp, #0
   10682:	4603      	mov	r3, r0
   10684:	6039      	str	r1, [r7, #0]
   10686:	71fb      	strb	r3, [r7, #7]
  int depth = 0;
   10688:	2300      	movs	r3, #0
   1068a:	60fb      	str	r3, [r7, #12]

  _Unwind_Backtrace(&PrintAddressAsList, &depth);
   1068c:	f107 030c 	add.w	r3, r7, #12
   10690:	4619      	mov	r1, r3
   10692:	481a      	ldr	r0, [pc, #104]	; (106fc <sjsu::debug::PrintBacktrace(bool, void*)+0x80>)
   10694:	f003 fe80 	bl	14398 <_Unwind_Backtrace>
  if (final_address)
   10698:	683b      	ldr	r3, [r7, #0]
   1069a:	2b00      	cmp	r3, #0
   1069c:	d005      	beq.n	106aa <sjsu::debug::PrintBacktrace(bool, void*)+0x2e>
  {
    printf("  %d) 0x%p\n", depth, final_address);
   1069e:	68fb      	ldr	r3, [r7, #12]
   106a0:	683a      	ldr	r2, [r7, #0]
   106a2:	4619      	mov	r1, r3
   106a4:	4816      	ldr	r0, [pc, #88]	; (10700 <sjsu::debug::PrintBacktrace(bool, void*)+0x84>)
   106a6:	f002 febd 	bl	13424 <printf>
  }

  if (show_make_command)
   106aa:	79fb      	ldrb	r3, [r7, #7]
   106ac:	2b00      	cmp	r3, #0
   106ae:	d020      	beq.n	106f2 <sjsu::debug::PrintBacktrace(bool, void*)+0x76>
  {
    printf("\nRun: the following command in your project directory");
   106b0:	4814      	ldr	r0, [pc, #80]	; (10704 <sjsu::debug::PrintBacktrace(bool, void*)+0x88>)
   106b2:	f002 feb7 	bl	13424 <printf>
    printf("\n\n  " SJ2_BOLD_WHITE);
   106b6:	4814      	ldr	r0, [pc, #80]	; (10708 <sjsu::debug::PrintBacktrace(bool, void*)+0x8c>)
   106b8:	f002 feb4 	bl	13424 <printf>
    printf("make stacktrace-%s TRACES=\"", Stringify(build::kTarget));
   106bc:	2001      	movs	r0, #1
   106be:	f7ff ff71 	bl	105a4 <sjsu::build::Stringify(sjsu::build::Target)>
   106c2:	4603      	mov	r3, r0
   106c4:	4619      	mov	r1, r3
   106c6:	4811      	ldr	r0, [pc, #68]	; (1070c <sjsu::debug::PrintBacktrace(bool, void*)+0x90>)
   106c8:	f002 feac 	bl	13424 <printf>

    _Unwind_Backtrace(&PrintAddressInRow, &depth);
   106cc:	f107 030c 	add.w	r3, r7, #12
   106d0:	4619      	mov	r1, r3
   106d2:	480f      	ldr	r0, [pc, #60]	; (10710 <sjsu::debug::PrintBacktrace(bool, void*)+0x94>)
   106d4:	f003 fe60 	bl	14398 <_Unwind_Backtrace>
    if (final_address)
   106d8:	683b      	ldr	r3, [r7, #0]
   106da:	2b00      	cmp	r3, #0
   106dc:	d003      	beq.n	106e6 <sjsu::debug::PrintBacktrace(bool, void*)+0x6a>
    {
      printf(" 0x%p", final_address);
   106de:	6839      	ldr	r1, [r7, #0]
   106e0:	480c      	ldr	r0, [pc, #48]	; (10714 <sjsu::debug::PrintBacktrace(bool, void*)+0x98>)
   106e2:	f002 fe9f 	bl	13424 <printf>
    }

    printf("\"\n\n" SJ2_COLOR_RESET);
   106e6:	480c      	ldr	r0, [pc, #48]	; (10718 <sjsu::debug::PrintBacktrace(bool, void*)+0x9c>)
   106e8:	f002 fe9c 	bl	13424 <printf>
    printf(
   106ec:	480b      	ldr	r0, [pc, #44]	; (1071c <sjsu::debug::PrintBacktrace(bool, void*)+0xa0>)
   106ee:	f002 fe99 	bl	13424 <printf>
        "This will report the file and line number that led to this function "
        "being called.");
  }
}
   106f2:	bf00      	nop
   106f4:	3710      	adds	r7, #16
   106f6:	46bd      	mov	sp, r7
   106f8:	bd80      	pop	{r7, pc}
   106fa:	bf00      	nop
   106fc:	000105f1 	.word	0x000105f1
   10700:	0001486c 	.word	0x0001486c
   10704:	00014878 	.word	0x00014878
   10708:	000148b0 	.word	0x000148b0
   1070c:	000148bc 	.word	0x000148bc
   10710:	00010639 	.word	0x00010639
   10714:	000148d8 	.word	0x000148d8
   10718:	000148e0 	.word	0x000148e0
   1071c:	000148e8 	.word	0x000148e8

00010720 <sjsu::(anonymous namespace)::DefaultUptime()>:
{
// uptime in microseconds
inline uint64_t uptime = 0;
// Returns the system uptime in microseconds, do not use this function directly
[[gnu::always_inline]] inline uint64_t DefaultUptime()
{
   10720:	b490      	push	{r4, r7}
   10722:	af00      	add	r7, sp, #0
  return uptime;
   10724:	4b03      	ldr	r3, [pc, #12]	; (10734 <sjsu::(anonymous namespace)::DefaultUptime()+0x14>)
   10726:	e9d3 3400 	ldrd	r3, r4, [r3]
}
   1072a:	4618      	mov	r0, r3
   1072c:	4621      	mov	r1, r4
   1072e:	46bd      	mov	sp, r7
   10730:	bc90      	pop	{r4, r7}
   10732:	4770      	bx	lr
   10734:	10000210 	.word	0x10000210

00010738 <sjsu::Milliseconds()>:
{
  Uptime = uptime_function;
}
// Get system uptime in milliseconds as a 64-bit integer
inline uint64_t Milliseconds()
{
   10738:	b598      	push	{r3, r4, r7, lr}
   1073a:	af00      	add	r7, sp, #0
  return Uptime() / 1'000;
   1073c:	4b06      	ldr	r3, [pc, #24]	; (10758 <sjsu::Milliseconds()+0x20>)
   1073e:	681b      	ldr	r3, [r3, #0]
   10740:	4798      	blx	r3
   10742:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   10746:	f04f 0300 	mov.w	r3, #0
   1074a:	f002 feed 	bl	13528 <__aeabi_uldivmod>
   1074e:	4603      	mov	r3, r0
   10750:	460c      	mov	r4, r1
}
   10752:	4618      	mov	r0, r3
   10754:	4621      	mov	r1, r4
   10756:	bd98      	pop	{r3, r4, r7, pc}
   10758:	10000004 	.word	0x10000004

0001075c <sjsu::Wait(unsigned long long)::{lambda()#1}::operator()() const>:
  return status;
}

inline Status Wait(uint64_t timeout)
{
  return Wait(timeout, []() -> bool { return false; });
   1075c:	b480      	push	{r7}
   1075e:	b083      	sub	sp, #12
   10760:	af00      	add	r7, sp, #0
   10762:	6078      	str	r0, [r7, #4]
   10764:	2300      	movs	r3, #0
   10766:	4618      	mov	r0, r3
   10768:	370c      	adds	r7, #12
   1076a:	46bd      	mov	sp, r7
   1076c:	f85d 7b04 	ldr.w	r7, [sp], #4
   10770:	4770      	bx	lr

00010772 <sjsu::Wait(unsigned long long)::{lambda()#1}::_FUN()>:
   10772:	b580      	push	{r7, lr}
   10774:	af00      	add	r7, sp, #0
   10776:	2000      	movs	r0, #0
   10778:	f7ff fff0 	bl	1075c <sjsu::Wait(unsigned long long)::{lambda()#1}::operator()() const>
   1077c:	4603      	mov	r3, r0
   1077e:	4618      	mov	r0, r3
   10780:	bd80      	pop	{r7, pc}

00010782 <sjsu::Wait(unsigned long long)>:
{
   10782:	b5f0      	push	{r4, r5, r6, r7, lr}
   10784:	b089      	sub	sp, #36	; 0x24
   10786:	af00      	add	r7, sp, #0
   10788:	e9c7 0100 	strd	r0, r1, [r7]
   1078c:	e9d7 3400 	ldrd	r3, r4, [r7]
   10790:	e9c7 3406 	strd	r3, r4, [r7, #24]
   10794:	723a      	strb	r2, [r7, #8]
  uint64_t timeout_time = 0;
   10796:	f04f 0300 	mov.w	r3, #0
   1079a:	f04f 0400 	mov.w	r4, #0
   1079e:	e9c7 3404 	strd	r3, r4, [r7, #16]
  if (timeout == kMaxWait)
   107a2:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
   107a6:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   107aa:	bf08      	it	eq
   107ac:	f1b3 3fff 	cmpeq.w	r3, #4294967295	; 0xffffffff
   107b0:	d106      	bne.n	107c0 <sjsu::Wait(unsigned long long)+0x3e>
    timeout_time = kMaxWait;
   107b2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   107b6:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   107ba:	e9c7 3404 	strd	r3, r4, [r7, #16]
   107be:	e00a      	b.n	107d6 <sjsu::Wait(unsigned long long)+0x54>
    timeout_time = Milliseconds() + timeout;
   107c0:	f7ff ffba 	bl	10738 <sjsu::Milliseconds()>
   107c4:	460a      	mov	r2, r1
   107c6:	4601      	mov	r1, r0
   107c8:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
   107cc:	185d      	adds	r5, r3, r1
   107ce:	eb44 0602 	adc.w	r6, r4, r2
   107d2:	e9c7 5604 	strd	r5, r6, [r7, #16]
  Status status = Status::kTimedOut;
   107d6:	2301      	movs	r3, #1
   107d8:	60fb      	str	r3, [r7, #12]
  while (Milliseconds() < timeout_time)
   107da:	f7ff ffad 	bl	10738 <sjsu::Milliseconds()>
   107de:	460a      	mov	r2, r1
   107e0:	4601      	mov	r1, r0
   107e2:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
   107e6:	42a2      	cmp	r2, r4
   107e8:	bf08      	it	eq
   107ea:	4299      	cmpeq	r1, r3
   107ec:	bf34      	ite	cc
   107ee:	2301      	movcc	r3, #1
   107f0:	2300      	movcs	r3, #0
   107f2:	b2db      	uxtb	r3, r3
   107f4:	2b00      	cmp	r3, #0
   107f6:	d009      	beq.n	1080c <sjsu::Wait(unsigned long long)+0x8a>
    if (is_done())
   107f8:	f107 0308 	add.w	r3, r7, #8
   107fc:	4618      	mov	r0, r3
   107fe:	f7ff ffad 	bl	1075c <sjsu::Wait(unsigned long long)::{lambda()#1}::operator()() const>
   10802:	4603      	mov	r3, r0
   10804:	2b00      	cmp	r3, #0
   10806:	d0e8      	beq.n	107da <sjsu::Wait(unsigned long long)+0x58>
      status = Status::kSuccess;
   10808:	2300      	movs	r3, #0
   1080a:	60fb      	str	r3, [r7, #12]
  return status;
   1080c:	68fb      	ldr	r3, [r7, #12]
}
   1080e:	4618      	mov	r0, r3
   10810:	3724      	adds	r7, #36	; 0x24
   10812:	46bd      	mov	sp, r7
   10814:	bdf0      	pop	{r4, r5, r6, r7, pc}

00010816 <sjsu::Delay(unsigned long long)>:

// Delay the system for a duration of time
inline void Delay([[maybe_unused]] uint64_t delay_time_ms)
{
   10816:	b580      	push	{r7, lr}
   10818:	b082      	sub	sp, #8
   1081a:	af00      	add	r7, sp, #0
   1081c:	e9c7 0100 	strd	r0, r1, [r7]
#if defined(HOST_TEST)
  return;
#else
  Wait(delay_time_ms);
   10820:	e9d7 0100 	ldrd	r0, r1, [r7]
   10824:	f7ff ffad 	bl	10782 <sjsu::Wait(unsigned long long)>
#endif  // HOST_TEST
}
   10828:	bf00      	nop
   1082a:	3708      	adds	r7, #8
   1082c:	46bd      	mov	sp, r7
   1082e:	bd80      	pop	{r7, pc}

00010830 <sjsu::lpc40xx::Gpio::SetAsInput() const>:
      : interupt_port_(0), pin_(port_number, pin_number)
  {
    interupt_port_ = (port_number == 2) ? 1 : 0;
  }
  // Sets the GPIO pin direction as input
  void SetAsInput() const
   10830:	b580      	push	{r7, lr}
   10832:	b084      	sub	sp, #16
   10834:	af00      	add	r7, sp, #0
   10836:	6078      	str	r0, [r7, #4]
  {
    pin_.SetPinFunction(kGpioFunction);
   10838:	687b      	ldr	r3, [r7, #4]
   1083a:	3308      	adds	r3, #8
   1083c:	2100      	movs	r1, #0
   1083e:	4618      	mov	r0, r3
   10840:	f7ff fd9a 	bl	10378 <sjsu::lpc40xx::Pin::SetPinFunction(unsigned char) const>
    gpio_port[pin_.GetPort()]->DIR &= ~(1 << pin_.GetPin());
   10844:	687b      	ldr	r3, [r7, #4]
   10846:	3308      	adds	r3, #8
   10848:	60bb      	str	r3, [r7, #8]
   1084a:	68bb      	ldr	r3, [r7, #8]
   1084c:	795b      	ldrb	r3, [r3, #5]
   1084e:	461a      	mov	r2, r3
   10850:	2301      	movs	r3, #1
   10852:	4093      	lsls	r3, r2
   10854:	43d9      	mvns	r1, r3
   10856:	687b      	ldr	r3, [r7, #4]
   10858:	3308      	adds	r3, #8
   1085a:	60fb      	str	r3, [r7, #12]
    return port_;
   1085c:	68fb      	ldr	r3, [r7, #12]
   1085e:	791b      	ldrb	r3, [r3, #4]
   10860:	461a      	mov	r2, r3
   10862:	4b05      	ldr	r3, [pc, #20]	; (10878 <sjsu::lpc40xx::Gpio::SetAsInput() const+0x48>)
   10864:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   10868:	681a      	ldr	r2, [r3, #0]
   1086a:	400a      	ands	r2, r1
   1086c:	601a      	str	r2, [r3, #0]
  }
   1086e:	bf00      	nop
   10870:	3710      	adds	r7, #16
   10872:	46bd      	mov	sp, r7
   10874:	bd80      	pop	{r7, pc}
   10876:	bf00      	nop
   10878:	10000008 	.word	0x10000008

0001087c <sjsu::lpc40xx::Gpio::SetAsOutput() const>:
  // Sets the GPIO pin direction as output
  void SetAsOutput() const
   1087c:	b580      	push	{r7, lr}
   1087e:	b084      	sub	sp, #16
   10880:	af00      	add	r7, sp, #0
   10882:	6078      	str	r0, [r7, #4]
  {
    pin_.SetPinFunction(kGpioFunction);
   10884:	687b      	ldr	r3, [r7, #4]
   10886:	3308      	adds	r3, #8
   10888:	2100      	movs	r1, #0
   1088a:	4618      	mov	r0, r3
   1088c:	f7ff fd74 	bl	10378 <sjsu::lpc40xx::Pin::SetPinFunction(unsigned char) const>
    gpio_port[pin_.GetPort()]->DIR |= (1 << pin_.GetPin());
   10890:	687b      	ldr	r3, [r7, #4]
   10892:	3308      	adds	r3, #8
   10894:	60bb      	str	r3, [r7, #8]
    return pin_;
   10896:	68bb      	ldr	r3, [r7, #8]
   10898:	795b      	ldrb	r3, [r3, #5]
   1089a:	461a      	mov	r2, r3
   1089c:	2301      	movs	r3, #1
   1089e:	fa03 f102 	lsl.w	r1, r3, r2
   108a2:	687b      	ldr	r3, [r7, #4]
   108a4:	3308      	adds	r3, #8
   108a6:	60fb      	str	r3, [r7, #12]
    return port_;
   108a8:	68fb      	ldr	r3, [r7, #12]
   108aa:	791b      	ldrb	r3, [r3, #4]
   108ac:	461a      	mov	r2, r3
   108ae:	4b05      	ldr	r3, [pc, #20]	; (108c4 <sjsu::lpc40xx::Gpio::SetAsOutput() const+0x48>)
   108b0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   108b4:	681a      	ldr	r2, [r3, #0]
   108b6:	430a      	orrs	r2, r1
   108b8:	601a      	str	r2, [r3, #0]
  }
   108ba:	bf00      	nop
   108bc:	3710      	adds	r7, #16
   108be:	46bd      	mov	sp, r7
   108c0:	bd80      	pop	{r7, pc}
   108c2:	bf00      	nop
   108c4:	10000008 	.word	0x10000008

000108c8 <sjsu::lpc40xx::Gpio::SetDirection(sjsu::Gpio::Direction) const>:
  // Sets the GPIO pin direction as output or input depending on the
  // Direction enum parameter
  inline void SetDirection(Direction direction) const override
   108c8:	b580      	push	{r7, lr}
   108ca:	b082      	sub	sp, #8
   108cc:	af00      	add	r7, sp, #0
   108ce:	6078      	str	r0, [r7, #4]
   108d0:	460b      	mov	r3, r1
   108d2:	70fb      	strb	r3, [r7, #3]
  {
    (direction) ? SetAsOutput() : SetAsInput();
   108d4:	78fb      	ldrb	r3, [r7, #3]
   108d6:	2b00      	cmp	r3, #0
   108d8:	d003      	beq.n	108e2 <sjsu::lpc40xx::Gpio::SetDirection(sjsu::Gpio::Direction) const+0x1a>
   108da:	6878      	ldr	r0, [r7, #4]
   108dc:	f7ff ffce 	bl	1087c <sjsu::lpc40xx::Gpio::SetAsOutput() const>
  }
   108e0:	e002      	b.n	108e8 <sjsu::lpc40xx::Gpio::SetDirection(sjsu::Gpio::Direction) const+0x20>
    (direction) ? SetAsOutput() : SetAsInput();
   108e2:	6878      	ldr	r0, [r7, #4]
   108e4:	f7ff ffa4 	bl	10830 <sjsu::lpc40xx::Gpio::SetAsInput() const>
  }
   108e8:	bf00      	nop
   108ea:	3708      	adds	r7, #8
   108ec:	46bd      	mov	sp, r7
   108ee:	bd80      	pop	{r7, pc}

000108f0 <sjsu::lpc40xx::Gpio::SetHigh() const>:
  // Sets the GPIO output pin to high
  void SetHigh() const
   108f0:	b480      	push	{r7}
   108f2:	b085      	sub	sp, #20
   108f4:	af00      	add	r7, sp, #0
   108f6:	6078      	str	r0, [r7, #4]
  {
    gpio_port[pin_.GetPort()]->SET = (1 << pin_.GetPin());
   108f8:	687b      	ldr	r3, [r7, #4]
   108fa:	3308      	adds	r3, #8
   108fc:	60bb      	str	r3, [r7, #8]
    return pin_;
   108fe:	68bb      	ldr	r3, [r7, #8]
   10900:	795b      	ldrb	r3, [r3, #5]
   10902:	461a      	mov	r2, r3
   10904:	2301      	movs	r3, #1
   10906:	4093      	lsls	r3, r2
   10908:	461a      	mov	r2, r3
   1090a:	687b      	ldr	r3, [r7, #4]
   1090c:	3308      	adds	r3, #8
   1090e:	60fb      	str	r3, [r7, #12]
    return port_;
   10910:	68fb      	ldr	r3, [r7, #12]
   10912:	791b      	ldrb	r3, [r3, #4]
   10914:	4619      	mov	r1, r3
   10916:	4b05      	ldr	r3, [pc, #20]	; (1092c <sjsu::lpc40xx::Gpio::SetHigh() const+0x3c>)
   10918:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   1091c:	619a      	str	r2, [r3, #24]
  }
   1091e:	bf00      	nop
   10920:	3714      	adds	r7, #20
   10922:	46bd      	mov	sp, r7
   10924:	f85d 7b04 	ldr.w	r7, [sp], #4
   10928:	4770      	bx	lr
   1092a:	bf00      	nop
   1092c:	10000008 	.word	0x10000008

00010930 <sjsu::lpc40xx::Gpio::SetLow() const>:
  // Sets the GPIO output pin to low
  void SetLow() const
   10930:	b480      	push	{r7}
   10932:	b085      	sub	sp, #20
   10934:	af00      	add	r7, sp, #0
   10936:	6078      	str	r0, [r7, #4]
  {
    gpio_port[pin_.GetPort()]->CLR = (1 << pin_.GetPin());
   10938:	687b      	ldr	r3, [r7, #4]
   1093a:	3308      	adds	r3, #8
   1093c:	60bb      	str	r3, [r7, #8]
    return pin_;
   1093e:	68bb      	ldr	r3, [r7, #8]
   10940:	795b      	ldrb	r3, [r3, #5]
   10942:	461a      	mov	r2, r3
   10944:	2301      	movs	r3, #1
   10946:	4093      	lsls	r3, r2
   10948:	461a      	mov	r2, r3
   1094a:	687b      	ldr	r3, [r7, #4]
   1094c:	3308      	adds	r3, #8
   1094e:	60fb      	str	r3, [r7, #12]
    return port_;
   10950:	68fb      	ldr	r3, [r7, #12]
   10952:	791b      	ldrb	r3, [r3, #4]
   10954:	4619      	mov	r1, r3
   10956:	4b05      	ldr	r3, [pc, #20]	; (1096c <sjsu::lpc40xx::Gpio::SetLow() const+0x3c>)
   10958:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   1095c:	61da      	str	r2, [r3, #28]
  }
   1095e:	bf00      	nop
   10960:	3714      	adds	r7, #20
   10962:	46bd      	mov	sp, r7
   10964:	f85d 7b04 	ldr.w	r7, [sp], #4
   10968:	4770      	bx	lr
   1096a:	bf00      	nop
   1096c:	10000008 	.word	0x10000008

00010970 <sjsu::lpc40xx::Gpio::Set(sjsu::Gpio::State) const>:
  // Sets the GPIO output pin to high or low depending on the State enum
  // parameter
  void Set(State output = kHigh) const override
   10970:	b580      	push	{r7, lr}
   10972:	b082      	sub	sp, #8
   10974:	af00      	add	r7, sp, #0
   10976:	6078      	str	r0, [r7, #4]
   10978:	460b      	mov	r3, r1
   1097a:	70fb      	strb	r3, [r7, #3]
  {
    (output) ? SetHigh() : SetLow();
   1097c:	78fb      	ldrb	r3, [r7, #3]
   1097e:	2b00      	cmp	r3, #0
   10980:	d003      	beq.n	1098a <sjsu::lpc40xx::Gpio::Set(sjsu::Gpio::State) const+0x1a>
   10982:	6878      	ldr	r0, [r7, #4]
   10984:	f7ff ffb4 	bl	108f0 <sjsu::lpc40xx::Gpio::SetHigh() const>
  }
   10988:	e002      	b.n	10990 <sjsu::lpc40xx::Gpio::Set(sjsu::Gpio::State) const+0x20>
    (output) ? SetHigh() : SetLow();
   1098a:	6878      	ldr	r0, [r7, #4]
   1098c:	f7ff ffd0 	bl	10930 <sjsu::lpc40xx::Gpio::SetLow() const>
  }
   10990:	bf00      	nop
   10992:	3708      	adds	r7, #8
   10994:	46bd      	mov	sp, r7
   10996:	bd80      	pop	{r7, pc}

00010998 <sjsu::lpc40xx::Gpio::Toggle() const>:
  // Toggle the output of a GPIO output pin
  void Toggle() const override
   10998:	b480      	push	{r7}
   1099a:	b085      	sub	sp, #20
   1099c:	af00      	add	r7, sp, #0
   1099e:	6078      	str	r0, [r7, #4]
  {
    gpio_port[pin_.GetPort()]->PIN ^= (1 << pin_.GetPin());
   109a0:	687b      	ldr	r3, [r7, #4]
   109a2:	3308      	adds	r3, #8
   109a4:	60bb      	str	r3, [r7, #8]
    return pin_;
   109a6:	68bb      	ldr	r3, [r7, #8]
   109a8:	795b      	ldrb	r3, [r3, #5]
   109aa:	461a      	mov	r2, r3
   109ac:	2301      	movs	r3, #1
   109ae:	fa03 f102 	lsl.w	r1, r3, r2
   109b2:	687b      	ldr	r3, [r7, #4]
   109b4:	3308      	adds	r3, #8
   109b6:	60fb      	str	r3, [r7, #12]
    return port_;
   109b8:	68fb      	ldr	r3, [r7, #12]
   109ba:	791b      	ldrb	r3, [r3, #4]
   109bc:	461a      	mov	r2, r3
   109be:	4b06      	ldr	r3, [pc, #24]	; (109d8 <sjsu::lpc40xx::Gpio::Toggle() const+0x40>)
   109c0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   109c4:	695a      	ldr	r2, [r3, #20]
   109c6:	404a      	eors	r2, r1
   109c8:	615a      	str	r2, [r3, #20]
  }
   109ca:	bf00      	nop
   109cc:	3714      	adds	r7, #20
   109ce:	46bd      	mov	sp, r7
   109d0:	f85d 7b04 	ldr.w	r7, [sp], #4
   109d4:	4770      	bx	lr
   109d6:	bf00      	nop
   109d8:	10000008 	.word	0x10000008

000109dc <sjsu::lpc40xx::Gpio::ReadState() const>:
  // Returns the current State state of the pin
  State ReadState() const override
   109dc:	b580      	push	{r7, lr}
   109de:	b082      	sub	sp, #8
   109e0:	af00      	add	r7, sp, #0
   109e2:	6078      	str	r0, [r7, #4]
  {
    return static_cast<State>(Read());
   109e4:	6878      	ldr	r0, [r7, #4]
   109e6:	f000 f805 	bl	109f4 <sjsu::lpc40xx::Gpio::Read() const>
   109ea:	4603      	mov	r3, r0
  }
   109ec:	4618      	mov	r0, r3
   109ee:	3708      	adds	r7, #8
   109f0:	46bd      	mov	sp, r7
   109f2:	bd80      	pop	{r7, pc}

000109f4 <sjsu::lpc40xx::Gpio::Read() const>:
  // Returns true if input or output pin is high
  bool Read() const override
   109f4:	b480      	push	{r7}
   109f6:	b085      	sub	sp, #20
   109f8:	af00      	add	r7, sp, #0
   109fa:	6078      	str	r0, [r7, #4]
  {
    return (gpio_port[pin_.GetPort()]->PIN >> pin_.GetPin()) & 1;
   109fc:	687b      	ldr	r3, [r7, #4]
   109fe:	3308      	adds	r3, #8
   10a00:	60bb      	str	r3, [r7, #8]
   10a02:	68bb      	ldr	r3, [r7, #8]
   10a04:	791b      	ldrb	r3, [r3, #4]
   10a06:	461a      	mov	r2, r3
   10a08:	4b0b      	ldr	r3, [pc, #44]	; (10a38 <sjsu::lpc40xx::Gpio::Read() const+0x44>)
   10a0a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   10a0e:	695b      	ldr	r3, [r3, #20]
   10a10:	687a      	ldr	r2, [r7, #4]
   10a12:	3208      	adds	r2, #8
   10a14:	60fa      	str	r2, [r7, #12]
    return pin_;
   10a16:	68fa      	ldr	r2, [r7, #12]
   10a18:	7952      	ldrb	r2, [r2, #5]
   10a1a:	40d3      	lsrs	r3, r2
   10a1c:	f003 0301 	and.w	r3, r3, #1
   10a20:	2b00      	cmp	r3, #0
   10a22:	bf14      	ite	ne
   10a24:	2301      	movne	r3, #1
   10a26:	2300      	moveq	r3, #0
   10a28:	b2db      	uxtb	r3, r3
  }
   10a2a:	4618      	mov	r0, r3
   10a2c:	3714      	adds	r7, #20
   10a2e:	46bd      	mov	sp, r7
   10a30:	f85d 7b04 	ldr.w	r7, [sp], #4
   10a34:	4770      	bx	lr
   10a36:	bf00      	nop
   10a38:	10000008 	.word	0x10000008

00010a3c <sjsu::lpc40xx::Gpio::GetPin() const>:
  const sjsu::Pin & GetPin() const override
   10a3c:	b480      	push	{r7}
   10a3e:	b083      	sub	sp, #12
   10a40:	af00      	add	r7, sp, #0
   10a42:	6078      	str	r0, [r7, #4]
  {
    return pin_;
   10a44:	687b      	ldr	r3, [r7, #4]
   10a46:	3308      	adds	r3, #8
  }
   10a48:	4618      	mov	r0, r3
   10a4a:	370c      	adds	r7, #12
   10a4c:	46bd      	mov	sp, r7
   10a4e:	f85d 7b04 	ldr.w	r7, [sp], #4
   10a52:	4770      	bx	lr

00010a54 <sjsu::lpc40xx::Gpio::ValidPortCheck() const>:

  // Checks if the selected gpio port is valid for external interrupts.
  bool ValidPortCheck() const
   10a54:	b580      	push	{r7, lr}
   10a56:	b086      	sub	sp, #24
   10a58:	af02      	add	r7, sp, #8
   10a5a:	6078      	str	r0, [r7, #4]
  {
    bool is_valid = (interupt_port_ <= 1);
   10a5c:	687b      	ldr	r3, [r7, #4]
   10a5e:	791b      	ldrb	r3, [r3, #4]
   10a60:	2b01      	cmp	r3, #1
   10a62:	bf94      	ite	ls
   10a64:	2301      	movls	r3, #1
   10a66:	2300      	movhi	r3, #0
   10a68:	b2db      	uxtb	r3, r3
   10a6a:	72fb      	strb	r3, [r7, #11]
    SJ2_ASSERT_WARNING(is_valid,
   10a6c:	7afb      	ldrb	r3, [r7, #11]
   10a6e:	f083 0301 	eor.w	r3, r3, #1
   10a72:	b2db      	uxtb	r3, r3
   10a74:	2b00      	cmp	r3, #0
   10a76:	d00b      	beq.n	10a90 <sjsu::lpc40xx::Gpio::ValidPortCheck() const+0x3c>
   10a78:	687b      	ldr	r3, [r7, #4]
   10a7a:	3308      	adds	r3, #8
   10a7c:	60fb      	str	r3, [r7, #12]
    return port_;
   10a7e:	68fb      	ldr	r3, [r7, #12]
   10a80:	791b      	ldrb	r3, [r3, #4]
   10a82:	9300      	str	r3, [sp, #0]
   10a84:	237f      	movs	r3, #127	; 0x7f
   10a86:	4a05      	ldr	r2, [pc, #20]	; (10a9c <sjsu::lpc40xx::Gpio::ValidPortCheck() const+0x48>)
   10a88:	4905      	ldr	r1, [pc, #20]	; (10aa0 <sjsu::lpc40xx::Gpio::ValidPortCheck() const+0x4c>)
   10a8a:	4806      	ldr	r0, [pc, #24]	; (10aa4 <sjsu::lpc40xx::Gpio::ValidPortCheck() const+0x50>)
   10a8c:	f002 fcca 	bl	13424 <printf>
                       "Port %d cannot be used for External Interrupts. Need "
                       "to use GPIO on Port 0 or 2.",
                       pin_.GetPort());
    return is_valid;
   10a90:	7afb      	ldrb	r3, [r7, #11]
  }
   10a92:	4618      	mov	r0, r3
   10a94:	3710      	adds	r7, #16
   10a96:	46bd      	mov	sp, r7
   10a98:	bd80      	pop	{r7, pc}
   10a9a:	bf00      	nop
   10a9c:	00014d80 	.word	0x00014d80
   10aa0:	00014cbc 	.word	0x00014cbc
   10aa4:	0001493c 	.word	0x0001493c

00010aa8 <sjsu::lpc40xx::Gpio::SetInterruptRoutine(void (*)()) const>:

  // Assigns the developer's ISR function to the port/pin gpio instance.
  void SetInterruptRoutine(IsrPointer function) const
   10aa8:	b590      	push	{r4, r7, lr}
   10aaa:	b085      	sub	sp, #20
   10aac:	af00      	add	r7, sp, #0
   10aae:	6078      	str	r0, [r7, #4]
   10ab0:	6039      	str	r1, [r7, #0]
  {
    ValidPortCheck();
   10ab2:	6878      	ldr	r0, [r7, #4]
   10ab4:	f7ff ffce 	bl	10a54 <sjsu::lpc40xx::Gpio::ValidPortCheck() const>
    interrupthandlers[interupt_port_][pin_.GetPin()] = function;
   10ab8:	683a      	ldr	r2, [r7, #0]
   10aba:	687b      	ldr	r3, [r7, #4]
   10abc:	791b      	ldrb	r3, [r3, #4]
   10abe:	461c      	mov	r4, r3
   10ac0:	687b      	ldr	r3, [r7, #4]
   10ac2:	3308      	adds	r3, #8
   10ac4:	60fb      	str	r3, [r7, #12]
    return pin_;
   10ac6:	68fb      	ldr	r3, [r7, #12]
   10ac8:	795b      	ldrb	r3, [r3, #5]
   10aca:	4618      	mov	r0, r3
   10acc:	4904      	ldr	r1, [pc, #16]	; (10ae0 <sjsu::lpc40xx::Gpio::SetInterruptRoutine(void (*)()) const+0x38>)
   10ace:	0163      	lsls	r3, r4, #5
   10ad0:	4403      	add	r3, r0
   10ad2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
   10ad6:	bf00      	nop
   10ad8:	3714      	adds	r7, #20
   10ada:	46bd      	mov	sp, r7
   10adc:	bd90      	pop	{r4, r7, pc}
   10ade:	bf00      	nop
   10ae0:	10000218 	.word	0x10000218

00010ae4 <sjsu::lpc40xx::Gpio::ClearInterruptRoutine() const>:

  // Clears the developers ISR function from the port/pin gio instance.
  void ClearInterruptRoutine() const
   10ae4:	b480      	push	{r7}
   10ae6:	b085      	sub	sp, #20
   10ae8:	af00      	add	r7, sp, #0
   10aea:	6078      	str	r0, [r7, #4]
  {
    interrupthandlers[interupt_port_][pin_.GetPin()] = nullptr;
   10aec:	687b      	ldr	r3, [r7, #4]
   10aee:	791b      	ldrb	r3, [r3, #4]
   10af0:	4618      	mov	r0, r3
   10af2:	687b      	ldr	r3, [r7, #4]
   10af4:	3308      	adds	r3, #8
   10af6:	60fb      	str	r3, [r7, #12]
   10af8:	68fb      	ldr	r3, [r7, #12]
   10afa:	795b      	ldrb	r3, [r3, #5]
   10afc:	4619      	mov	r1, r3
   10afe:	4a06      	ldr	r2, [pc, #24]	; (10b18 <sjsu::lpc40xx::Gpio::ClearInterruptRoutine() const+0x34>)
   10b00:	0143      	lsls	r3, r0, #5
   10b02:	440b      	add	r3, r1
   10b04:	2100      	movs	r1, #0
   10b06:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
  }
   10b0a:	bf00      	nop
   10b0c:	3714      	adds	r7, #20
   10b0e:	46bd      	mov	sp, r7
   10b10:	f85d 7b04 	ldr.w	r7, [sp], #4
   10b14:	4770      	bx	lr
   10b16:	bf00      	nop
   10b18:	10000218 	.word	0x10000218

00010b1c <unsigned char sjsu::util::Value<sjsu::Gpio::Edge, unsigned char>(sjsu::Gpio::Edge)>:
constexpr Type Value(Enum enum_type_value)
   10b1c:	b480      	push	{r7}
   10b1e:	b083      	sub	sp, #12
   10b20:	af00      	add	r7, sp, #0
   10b22:	4603      	mov	r3, r0
   10b24:	71fb      	strb	r3, [r7, #7]
  return static_cast<Type>(enum_type_value);
   10b26:	79fb      	ldrb	r3, [r7, #7]
}
   10b28:	4618      	mov	r0, r3
   10b2a:	370c      	adds	r7, #12
   10b2c:	46bd      	mov	sp, r7
   10b2e:	f85d 7b04 	ldr.w	r7, [sp], #4
   10b32:	4770      	bx	lr

00010b34 <sjsu::lpc40xx::Gpio::SetInterruptEdge(sjsu::Gpio::Edge) const>:

  // Sets the selected edge that the gpio interrupt will be triggered on.
  void SetInterruptEdge(Edge edge) const
   10b34:	b580      	push	{r7, lr}
   10b36:	b084      	sub	sp, #16
   10b38:	af02      	add	r7, sp, #8
   10b3a:	6078      	str	r0, [r7, #4]
   10b3c:	460b      	mov	r3, r1
   10b3e:	70fb      	strb	r3, [r7, #3]
  {
    ValidPortCheck();
   10b40:	6878      	ldr	r0, [r7, #4]
   10b42:	f7ff ff87 	bl	10a54 <sjsu::lpc40xx::Gpio::ValidPortCheck() const>
    switch (edge)
   10b46:	78fb      	ldrb	r3, [r7, #3]
   10b48:	2b01      	cmp	r3, #1
   10b4a:	d008      	beq.n	10b5e <sjsu::lpc40xx::Gpio::SetInterruptEdge(sjsu::Gpio::Edge) const+0x2a>
   10b4c:	2b01      	cmp	r3, #1
   10b4e:	d302      	bcc.n	10b56 <sjsu::lpc40xx::Gpio::SetInterruptEdge(sjsu::Gpio::Edge) const+0x22>
   10b50:	2b02      	cmp	r3, #2
   10b52:	d008      	beq.n	10b66 <sjsu::lpc40xx::Gpio::SetInterruptEdge(sjsu::Gpio::Edge) const+0x32>
   10b54:	e00e      	b.n	10b74 <sjsu::lpc40xx::Gpio::SetInterruptEdge(sjsu::Gpio::Edge) const+0x40>
    {
      case Edge::kEdgeRising:
      {
        SetEdgeRising();
   10b56:	6878      	ldr	r0, [r7, #4]
   10b58:	f000 f84e 	bl	10bf8 <sjsu::lpc40xx::Gpio::SetEdgeRising() const>
        break;
   10b5c:	e016      	b.n	10b8c <sjsu::lpc40xx::Gpio::SetInterruptEdge(sjsu::Gpio::Edge) const+0x58>
      }
      case Edge::kEdgeFalling:
      {
        SetEdgeFalling();
   10b5e:	6878      	ldr	r0, [r7, #4]
   10b60:	f000 f878 	bl	10c54 <sjsu::lpc40xx::Gpio::SetEdgeFalling() const>
        break;
   10b64:	e012      	b.n	10b8c <sjsu::lpc40xx::Gpio::SetInterruptEdge(sjsu::Gpio::Edge) const+0x58>
      }
      case Edge::kEdgeBoth:
      {
        SetEdgeRising();
   10b66:	6878      	ldr	r0, [r7, #4]
   10b68:	f000 f846 	bl	10bf8 <sjsu::lpc40xx::Gpio::SetEdgeRising() const>
        SetEdgeFalling();
   10b6c:	6878      	ldr	r0, [r7, #4]
   10b6e:	f000 f871 	bl	10c54 <sjsu::lpc40xx::Gpio::SetEdgeFalling() const>
        break;
   10b72:	e00b      	b.n	10b8c <sjsu::lpc40xx::Gpio::SetInterruptEdge(sjsu::Gpio::Edge) const+0x58>
      }
      default:
      {
        LOG_WARNING(
   10b74:	78fb      	ldrb	r3, [r7, #3]
   10b76:	4618      	mov	r0, r3
   10b78:	f7ff ffd0 	bl	10b1c <unsigned char sjsu::util::Value<sjsu::Gpio::Edge, unsigned char>(sjsu::Gpio::Edge)>
   10b7c:	4603      	mov	r3, r0
   10b7e:	9300      	str	r3, [sp, #0]
   10b80:	23ab      	movs	r3, #171	; 0xab
   10b82:	4a04      	ldr	r2, [pc, #16]	; (10b94 <sjsu::lpc40xx::Gpio::SetInterruptEdge(sjsu::Gpio::Edge) const+0x60>)
   10b84:	4904      	ldr	r1, [pc, #16]	; (10b98 <sjsu::lpc40xx::Gpio::SetInterruptEdge(sjsu::Gpio::Edge) const+0x64>)
   10b86:	4805      	ldr	r0, [pc, #20]	; (10b9c <sjsu::lpc40xx::Gpio::SetInterruptEdge(sjsu::Gpio::Edge) const+0x68>)
   10b88:	f002 fc4c 	bl	13424 <printf>
            "Edge %d cannot be used for External Interrupts."
            "Need to use a rising, falling, or both configuration.",
            util::Value(edge));
      }
    }
  }
   10b8c:	bf00      	nop
   10b8e:	3708      	adds	r7, #8
   10b90:	46bd      	mov	sp, r7
   10b92:	bd80      	pop	{r7, pc}
   10b94:	00014db4 	.word	0x00014db4
   10b98:	00014cc8 	.word	0x00014cc8
   10b9c:	000149cc 	.word	0x000149cc

00010ba0 <sjsu::lpc40xx::Gpio::AttachInterrupt(void (*)(), sjsu::Gpio::Edge) const>:
    }
  }

  // Assign the developer's ISR and sets the selected edge that the gpio
  // interrupt will be triggered on.
  void AttachInterrupt(IsrPointer function, Edge edge) const override
   10ba0:	b580      	push	{r7, lr}
   10ba2:	b084      	sub	sp, #16
   10ba4:	af00      	add	r7, sp, #0
   10ba6:	60f8      	str	r0, [r7, #12]
   10ba8:	60b9      	str	r1, [r7, #8]
   10baa:	4613      	mov	r3, r2
   10bac:	71fb      	strb	r3, [r7, #7]
  {
    ValidPortCheck();
   10bae:	68f8      	ldr	r0, [r7, #12]
   10bb0:	f7ff ff50 	bl	10a54 <sjsu::lpc40xx::Gpio::ValidPortCheck() const>
    SetInterruptRoutine(function);
   10bb4:	68b9      	ldr	r1, [r7, #8]
   10bb6:	68f8      	ldr	r0, [r7, #12]
   10bb8:	f7ff ff76 	bl	10aa8 <sjsu::lpc40xx::Gpio::SetInterruptRoutine(void (*)()) const>
    SetInterruptEdge(edge);
   10bbc:	79fb      	ldrb	r3, [r7, #7]
   10bbe:	4619      	mov	r1, r3
   10bc0:	68f8      	ldr	r0, [r7, #12]
   10bc2:	f7ff ffb7 	bl	10b34 <sjsu::lpc40xx::Gpio::SetInterruptEdge(sjsu::Gpio::Edge) const>
  }
   10bc6:	bf00      	nop
   10bc8:	3710      	adds	r7, #16
   10bca:	46bd      	mov	sp, r7
   10bcc:	bd80      	pop	{r7, pc}

00010bce <sjsu::lpc40xx::Gpio::DetachInterrupt() const>:

  // Removes the developer's ISR and clears the selected edge of the gpio
  // interrupt from being triggered.
  void DetachInterrupt() const override
   10bce:	b580      	push	{r7, lr}
   10bd0:	b082      	sub	sp, #8
   10bd2:	af00      	add	r7, sp, #0
   10bd4:	6078      	str	r0, [r7, #4]
  {
    ValidPortCheck();
   10bd6:	6878      	ldr	r0, [r7, #4]
   10bd8:	f7ff ff3c 	bl	10a54 <sjsu::lpc40xx::Gpio::ValidPortCheck() const>
    ClearInterruptRoutine();
   10bdc:	6878      	ldr	r0, [r7, #4]
   10bde:	f7ff ff81 	bl	10ae4 <sjsu::lpc40xx::Gpio::ClearInterruptRoutine() const>
    ClearEdgeRising();
   10be2:	6878      	ldr	r0, [r7, #4]
   10be4:	f000 f864 	bl	10cb0 <sjsu::lpc40xx::Gpio::ClearEdgeRising() const>
    ClearEdgeFalling();
   10be8:	6878      	ldr	r0, [r7, #4]
   10bea:	f000 f88f 	bl	10d0c <sjsu::lpc40xx::Gpio::ClearEdgeFalling() const>
  }
   10bee:	bf00      	nop
   10bf0:	3708      	adds	r7, #8
   10bf2:	46bd      	mov	sp, r7
   10bf4:	bd80      	pop	{r7, pc}
   10bf6:	Address 0x0000000000010bf6 is out of bounds.


00010bf8 <sjsu::lpc40xx::Gpio::SetEdgeRising() const>:
    *interrupt[triggered_port].clear |= (1 << triggered_pin);
  }

 private:
  // Sets the gpio interrupt to trigger on a rising edge.
  void SetEdgeRising() const
   10bf8:	b490      	push	{r4, r7}
   10bfa:	b084      	sub	sp, #16
   10bfc:	af00      	add	r7, sp, #0
   10bfe:	6078      	str	r0, [r7, #4]
  {
    *interrupt[interupt_port_].enable_rising_edge |= (1 << pin_.GetPin());
   10c00:	687b      	ldr	r3, [r7, #4]
   10c02:	3308      	adds	r3, #8
   10c04:	60fb      	str	r3, [r7, #12]
   10c06:	68fb      	ldr	r3, [r7, #12]
   10c08:	795b      	ldrb	r3, [r3, #5]
   10c0a:	461a      	mov	r2, r3
   10c0c:	2301      	movs	r3, #1
   10c0e:	fa03 f002 	lsl.w	r0, r3, r2
   10c12:	687b      	ldr	r3, [r7, #4]
   10c14:	791b      	ldrb	r3, [r3, #4]
   10c16:	4619      	mov	r1, r3
   10c18:	4a0d      	ldr	r2, [pc, #52]	; (10c50 <sjsu::lpc40xx::Gpio::SetEdgeRising() const+0x58>)
   10c1a:	460b      	mov	r3, r1
   10c1c:	009b      	lsls	r3, r3, #2
   10c1e:	440b      	add	r3, r1
   10c20:	009b      	lsls	r3, r3, #2
   10c22:	4413      	add	r3, r2
   10c24:	330c      	adds	r3, #12
   10c26:	681b      	ldr	r3, [r3, #0]
   10c28:	681a      	ldr	r2, [r3, #0]
   10c2a:	4604      	mov	r4, r0
   10c2c:	687b      	ldr	r3, [r7, #4]
   10c2e:	791b      	ldrb	r3, [r3, #4]
   10c30:	4618      	mov	r0, r3
   10c32:	4907      	ldr	r1, [pc, #28]	; (10c50 <sjsu::lpc40xx::Gpio::SetEdgeRising() const+0x58>)
   10c34:	4603      	mov	r3, r0
   10c36:	009b      	lsls	r3, r3, #2
   10c38:	4403      	add	r3, r0
   10c3a:	009b      	lsls	r3, r3, #2
   10c3c:	440b      	add	r3, r1
   10c3e:	330c      	adds	r3, #12
   10c40:	681b      	ldr	r3, [r3, #0]
   10c42:	4322      	orrs	r2, r4
   10c44:	601a      	str	r2, [r3, #0]
  }
   10c46:	bf00      	nop
   10c48:	3710      	adds	r7, #16
   10c4a:	46bd      	mov	sp, r7
   10c4c:	bc90      	pop	{r4, r7}
   10c4e:	4770      	bx	lr
   10c50:	10000020 	.word	0x10000020

00010c54 <sjsu::lpc40xx::Gpio::SetEdgeFalling() const>:

  // Sets the gpio interrupt to trigger on a falling edge.
  void SetEdgeFalling() const
   10c54:	b490      	push	{r4, r7}
   10c56:	b084      	sub	sp, #16
   10c58:	af00      	add	r7, sp, #0
   10c5a:	6078      	str	r0, [r7, #4]
  {
    *interrupt[interupt_port_].enable_falling_edge |= (1 << pin_.GetPin());
   10c5c:	687b      	ldr	r3, [r7, #4]
   10c5e:	3308      	adds	r3, #8
   10c60:	60fb      	str	r3, [r7, #12]
   10c62:	68fb      	ldr	r3, [r7, #12]
   10c64:	795b      	ldrb	r3, [r3, #5]
   10c66:	461a      	mov	r2, r3
   10c68:	2301      	movs	r3, #1
   10c6a:	fa03 f002 	lsl.w	r0, r3, r2
   10c6e:	687b      	ldr	r3, [r7, #4]
   10c70:	791b      	ldrb	r3, [r3, #4]
   10c72:	4619      	mov	r1, r3
   10c74:	4a0d      	ldr	r2, [pc, #52]	; (10cac <sjsu::lpc40xx::Gpio::SetEdgeFalling() const+0x58>)
   10c76:	460b      	mov	r3, r1
   10c78:	009b      	lsls	r3, r3, #2
   10c7a:	440b      	add	r3, r1
   10c7c:	009b      	lsls	r3, r3, #2
   10c7e:	4413      	add	r3, r2
   10c80:	3310      	adds	r3, #16
   10c82:	681b      	ldr	r3, [r3, #0]
   10c84:	681a      	ldr	r2, [r3, #0]
   10c86:	4604      	mov	r4, r0
   10c88:	687b      	ldr	r3, [r7, #4]
   10c8a:	791b      	ldrb	r3, [r3, #4]
   10c8c:	4618      	mov	r0, r3
   10c8e:	4907      	ldr	r1, [pc, #28]	; (10cac <sjsu::lpc40xx::Gpio::SetEdgeFalling() const+0x58>)
   10c90:	4603      	mov	r3, r0
   10c92:	009b      	lsls	r3, r3, #2
   10c94:	4403      	add	r3, r0
   10c96:	009b      	lsls	r3, r3, #2
   10c98:	440b      	add	r3, r1
   10c9a:	3310      	adds	r3, #16
   10c9c:	681b      	ldr	r3, [r3, #0]
   10c9e:	4322      	orrs	r2, r4
   10ca0:	601a      	str	r2, [r3, #0]
  }
   10ca2:	bf00      	nop
   10ca4:	3710      	adds	r7, #16
   10ca6:	46bd      	mov	sp, r7
   10ca8:	bc90      	pop	{r4, r7}
   10caa:	4770      	bx	lr
   10cac:	10000020 	.word	0x10000020

00010cb0 <sjsu::lpc40xx::Gpio::ClearEdgeRising() const>:

  // Clears the gpio interrupt to no longer trigger on a rising edge.
  void ClearEdgeRising() const
   10cb0:	b490      	push	{r4, r7}
   10cb2:	b084      	sub	sp, #16
   10cb4:	af00      	add	r7, sp, #0
   10cb6:	6078      	str	r0, [r7, #4]
  {
    *interrupt[interupt_port_].enable_rising_edge &= ~(1 << pin_.GetPin());
   10cb8:	687b      	ldr	r3, [r7, #4]
   10cba:	3308      	adds	r3, #8
   10cbc:	60fb      	str	r3, [r7, #12]
   10cbe:	68fb      	ldr	r3, [r7, #12]
   10cc0:	795b      	ldrb	r3, [r3, #5]
   10cc2:	461a      	mov	r2, r3
   10cc4:	2301      	movs	r3, #1
   10cc6:	4093      	lsls	r3, r2
   10cc8:	43d8      	mvns	r0, r3
   10cca:	687b      	ldr	r3, [r7, #4]
   10ccc:	791b      	ldrb	r3, [r3, #4]
   10cce:	4619      	mov	r1, r3
   10cd0:	4a0d      	ldr	r2, [pc, #52]	; (10d08 <sjsu::lpc40xx::Gpio::ClearEdgeRising() const+0x58>)
   10cd2:	460b      	mov	r3, r1
   10cd4:	009b      	lsls	r3, r3, #2
   10cd6:	440b      	add	r3, r1
   10cd8:	009b      	lsls	r3, r3, #2
   10cda:	4413      	add	r3, r2
   10cdc:	330c      	adds	r3, #12
   10cde:	681b      	ldr	r3, [r3, #0]
   10ce0:	681a      	ldr	r2, [r3, #0]
   10ce2:	4604      	mov	r4, r0
   10ce4:	687b      	ldr	r3, [r7, #4]
   10ce6:	791b      	ldrb	r3, [r3, #4]
   10ce8:	4618      	mov	r0, r3
   10cea:	4907      	ldr	r1, [pc, #28]	; (10d08 <sjsu::lpc40xx::Gpio::ClearEdgeRising() const+0x58>)
   10cec:	4603      	mov	r3, r0
   10cee:	009b      	lsls	r3, r3, #2
   10cf0:	4403      	add	r3, r0
   10cf2:	009b      	lsls	r3, r3, #2
   10cf4:	440b      	add	r3, r1
   10cf6:	330c      	adds	r3, #12
   10cf8:	681b      	ldr	r3, [r3, #0]
   10cfa:	4022      	ands	r2, r4
   10cfc:	601a      	str	r2, [r3, #0]
  }
   10cfe:	bf00      	nop
   10d00:	3710      	adds	r7, #16
   10d02:	46bd      	mov	sp, r7
   10d04:	bc90      	pop	{r4, r7}
   10d06:	4770      	bx	lr
   10d08:	10000020 	.word	0x10000020

00010d0c <sjsu::lpc40xx::Gpio::ClearEdgeFalling() const>:

  // Clears the gpio interrupt to no longer trigger on a falling edge.
  void ClearEdgeFalling() const
   10d0c:	b490      	push	{r4, r7}
   10d0e:	b084      	sub	sp, #16
   10d10:	af00      	add	r7, sp, #0
   10d12:	6078      	str	r0, [r7, #4]
  {
    *interrupt[interupt_port_].enable_falling_edge &= ~(1 << pin_.GetPin());
   10d14:	687b      	ldr	r3, [r7, #4]
   10d16:	3308      	adds	r3, #8
   10d18:	60fb      	str	r3, [r7, #12]
   10d1a:	68fb      	ldr	r3, [r7, #12]
   10d1c:	795b      	ldrb	r3, [r3, #5]
   10d1e:	461a      	mov	r2, r3
   10d20:	2301      	movs	r3, #1
   10d22:	4093      	lsls	r3, r2
   10d24:	43d8      	mvns	r0, r3
   10d26:	687b      	ldr	r3, [r7, #4]
   10d28:	791b      	ldrb	r3, [r3, #4]
   10d2a:	4619      	mov	r1, r3
   10d2c:	4a0d      	ldr	r2, [pc, #52]	; (10d64 <sjsu::lpc40xx::Gpio::ClearEdgeFalling() const+0x58>)
   10d2e:	460b      	mov	r3, r1
   10d30:	009b      	lsls	r3, r3, #2
   10d32:	440b      	add	r3, r1
   10d34:	009b      	lsls	r3, r3, #2
   10d36:	4413      	add	r3, r2
   10d38:	3310      	adds	r3, #16
   10d3a:	681b      	ldr	r3, [r3, #0]
   10d3c:	681a      	ldr	r2, [r3, #0]
   10d3e:	4604      	mov	r4, r0
   10d40:	687b      	ldr	r3, [r7, #4]
   10d42:	791b      	ldrb	r3, [r3, #4]
   10d44:	4618      	mov	r0, r3
   10d46:	4907      	ldr	r1, [pc, #28]	; (10d64 <sjsu::lpc40xx::Gpio::ClearEdgeFalling() const+0x58>)
   10d48:	4603      	mov	r3, r0
   10d4a:	009b      	lsls	r3, r3, #2
   10d4c:	4403      	add	r3, r0
   10d4e:	009b      	lsls	r3, r3, #2
   10d50:	440b      	add	r3, r1
   10d52:	3310      	adds	r3, #16
   10d54:	681b      	ldr	r3, [r3, #0]
   10d56:	4022      	ands	r2, r4
   10d58:	601a      	str	r2, [r3, #0]
  }
   10d5a:	bf00      	nop
   10d5c:	3710      	adds	r7, #16
   10d5e:	46bd      	mov	sp, r7
   10d60:	bc90      	pop	{r4, r7}
   10d62:	4770      	bx	lr
   10d64:	10000020 	.word	0x10000020

00010d68 <sjsu::OnBoardLed::Initialize()>:
    kOn  = true,
    kOff = false
  };
  // Initialize takes the array of Gpios, sets each one to an output, and
  // then turns off all of the leds by setting the output high.
  void Initialize()
   10d68:	b580      	push	{r7, lr}
   10d6a:	b084      	sub	sp, #16
   10d6c:	af00      	add	r7, sp, #0
   10d6e:	6078      	str	r0, [r7, #4]
  {
    for (uint8_t i = 0; i < 4; i++)
   10d70:	2300      	movs	r3, #0
   10d72:	73fb      	strb	r3, [r7, #15]
   10d74:	7bfb      	ldrb	r3, [r7, #15]
   10d76:	2b03      	cmp	r3, #3
   10d78:	d811      	bhi.n	10d9e <sjsu::OnBoardLed::Initialize()+0x36>
    {
      led[i].SetAsOutput();
   10d7a:	7bfb      	ldrb	r3, [r7, #15]
   10d7c:	011b      	lsls	r3, r3, #4
   10d7e:	687a      	ldr	r2, [r7, #4]
   10d80:	4413      	add	r3, r2
   10d82:	4618      	mov	r0, r3
   10d84:	f7ff fd7a 	bl	1087c <sjsu::lpc40xx::Gpio::SetAsOutput() const>
      led[i].SetHigh();
   10d88:	7bfb      	ldrb	r3, [r7, #15]
   10d8a:	011b      	lsls	r3, r3, #4
   10d8c:	687a      	ldr	r2, [r7, #4]
   10d8e:	4413      	add	r3, r2
   10d90:	4618      	mov	r0, r3
   10d92:	f7ff fdad 	bl	108f0 <sjsu::lpc40xx::Gpio::SetHigh() const>
    for (uint8_t i = 0; i < 4; i++)
   10d96:	7bfb      	ldrb	r3, [r7, #15]
   10d98:	3301      	adds	r3, #1
   10d9a:	73fb      	strb	r3, [r7, #15]
   10d9c:	e7ea      	b.n	10d74 <sjsu::OnBoardLed::Initialize()+0xc>
    }
  }
   10d9e:	bf00      	nop
   10da0:	3710      	adds	r7, #16
   10da2:	46bd      	mov	sp, r7
   10da4:	bd80      	pop	{r7, pc}
   10da6:	Address 0x0000000000010da6 is out of bounds.


00010da8 <sjsu::OnBoardLed::On(unsigned char)>:

  void On(uint8_t led_number)
   10da8:	b580      	push	{r7, lr}
   10daa:	b084      	sub	sp, #16
   10dac:	af02      	add	r7, sp, #8
   10dae:	6078      	str	r0, [r7, #4]
   10db0:	460b      	mov	r3, r1
   10db2:	70fb      	strb	r3, [r7, #3]
  {
    SJ2_ASSERT_FATAL(led_number < 4,
   10db4:	78fb      	ldrb	r3, [r7, #3]
   10db6:	2b03      	cmp	r3, #3
   10db8:	d90f      	bls.n	10dda <sjsu::OnBoardLed::On(unsigned char)+0x32>
   10dba:	78fb      	ldrb	r3, [r7, #3]
   10dbc:	9300      	str	r3, [sp, #0]
   10dbe:	2336      	movs	r3, #54	; 0x36
   10dc0:	4a0b      	ldr	r2, [pc, #44]	; (10df0 <sjsu::OnBoardLed::On(unsigned char)+0x48>)
   10dc2:	490c      	ldr	r1, [pc, #48]	; (10df4 <sjsu::OnBoardLed::On(unsigned char)+0x4c>)
   10dc4:	480c      	ldr	r0, [pc, #48]	; (10df8 <sjsu::OnBoardLed::On(unsigned char)+0x50>)
   10dc6:	f002 fb2d 	bl	13424 <printf>
   10dca:	480c      	ldr	r0, [pc, #48]	; (10dfc <sjsu::OnBoardLed::On(unsigned char)+0x54>)
   10dcc:	f001 f95a 	bl	12084 <puts>
   10dd0:	2100      	movs	r1, #0
   10dd2:	2001      	movs	r0, #1
   10dd4:	f7ff fc52 	bl	1067c <sjsu::debug::PrintBacktrace(bool, void*)>
   10dd8:	e7fe      	b.n	10dd8 <sjsu::OnBoardLed::On(unsigned char)+0x30>
                     "Input Led number can't be greater than 3, input = %d.\n",
                     led_number);
    led[led_number].SetLow();
   10dda:	78fb      	ldrb	r3, [r7, #3]
   10ddc:	011b      	lsls	r3, r3, #4
   10dde:	687a      	ldr	r2, [r7, #4]
   10de0:	4413      	add	r3, r2
   10de2:	4618      	mov	r0, r3
   10de4:	f7ff fda4 	bl	10930 <sjsu::lpc40xx::Gpio::SetLow() const>
  }
   10de8:	bf00      	nop
   10dea:	3708      	adds	r7, #8
   10dec:	46bd      	mov	sp, r7
   10dee:	bd80      	pop	{r7, pc}
   10df0:	00014e3c 	.word	0x00014e3c
   10df4:	00014cd4 	.word	0x00014cd4
   10df8:	00014aac 	.word	0x00014aac
   10dfc:	00014b60 	.word	0x00014b60

00010e00 <sjsu::OnBoardLed::Off(unsigned char)>:

  void Off(uint8_t led_number)
   10e00:	b580      	push	{r7, lr}
   10e02:	b084      	sub	sp, #16
   10e04:	af02      	add	r7, sp, #8
   10e06:	6078      	str	r0, [r7, #4]
   10e08:	460b      	mov	r3, r1
   10e0a:	70fb      	strb	r3, [r7, #3]
  {
    SJ2_ASSERT_FATAL(led_number < 4,
   10e0c:	78fb      	ldrb	r3, [r7, #3]
   10e0e:	2b03      	cmp	r3, #3
   10e10:	d90f      	bls.n	10e32 <sjsu::OnBoardLed::Off(unsigned char)+0x32>
   10e12:	78fb      	ldrb	r3, [r7, #3]
   10e14:	9300      	str	r3, [sp, #0]
   10e16:	233e      	movs	r3, #62	; 0x3e
   10e18:	4a0b      	ldr	r2, [pc, #44]	; (10e48 <sjsu::OnBoardLed::Off(unsigned char)+0x48>)
   10e1a:	490c      	ldr	r1, [pc, #48]	; (10e4c <sjsu::OnBoardLed::Off(unsigned char)+0x4c>)
   10e1c:	480c      	ldr	r0, [pc, #48]	; (10e50 <sjsu::OnBoardLed::Off(unsigned char)+0x50>)
   10e1e:	f002 fb01 	bl	13424 <printf>
   10e22:	480c      	ldr	r0, [pc, #48]	; (10e54 <sjsu::OnBoardLed::Off(unsigned char)+0x54>)
   10e24:	f001 f92e 	bl	12084 <puts>
   10e28:	2100      	movs	r1, #0
   10e2a:	2001      	movs	r0, #1
   10e2c:	f7ff fc26 	bl	1067c <sjsu::debug::PrintBacktrace(bool, void*)>
   10e30:	e7fe      	b.n	10e30 <sjsu::OnBoardLed::Off(unsigned char)+0x30>
                     "Input Led number can't be greater than 3, input = %d.\n",
                     led_number);
    led[led_number].SetHigh();
   10e32:	78fb      	ldrb	r3, [r7, #3]
   10e34:	011b      	lsls	r3, r3, #4
   10e36:	687a      	ldr	r2, [r7, #4]
   10e38:	4413      	add	r3, r2
   10e3a:	4618      	mov	r0, r3
   10e3c:	f7ff fd58 	bl	108f0 <sjsu::lpc40xx::Gpio::SetHigh() const>
  }
   10e40:	bf00      	nop
   10e42:	3708      	adds	r7, #8
   10e44:	46bd      	mov	sp, r7
   10e46:	bd80      	pop	{r7, pc}
   10e48:	00014e60 	.word	0x00014e60
   10e4c:	00014ce4 	.word	0x00014ce4
   10e50:	00014aac 	.word	0x00014aac
   10e54:	00014b60 	.word	0x00014b60

00010e58 <sjsu::OnBoardLed::Set(unsigned char, sjsu::OnBoardLed::LightState)>:

  void Set(uint8_t led_number, LightState state = LightState::kOn)
   10e58:	b580      	push	{r7, lr}
   10e5a:	b084      	sub	sp, #16
   10e5c:	af02      	add	r7, sp, #8
   10e5e:	6078      	str	r0, [r7, #4]
   10e60:	460b      	mov	r3, r1
   10e62:	70fb      	strb	r3, [r7, #3]
   10e64:	4613      	mov	r3, r2
   10e66:	70bb      	strb	r3, [r7, #2]
  {
    SJ2_ASSERT_FATAL(led_number < 4,
   10e68:	78fb      	ldrb	r3, [r7, #3]
   10e6a:	2b03      	cmp	r3, #3
   10e6c:	d90f      	bls.n	10e8e <sjsu::OnBoardLed::Set(unsigned char, sjsu::OnBoardLed::LightState)+0x36>
   10e6e:	78fb      	ldrb	r3, [r7, #3]
   10e70:	9300      	str	r3, [sp, #0]
   10e72:	2346      	movs	r3, #70	; 0x46
   10e74:	4a0f      	ldr	r2, [pc, #60]	; (10eb4 <sjsu::OnBoardLed::Set(unsigned char, sjsu::OnBoardLed::LightState)+0x5c>)
   10e76:	4910      	ldr	r1, [pc, #64]	; (10eb8 <sjsu::OnBoardLed::Set(unsigned char, sjsu::OnBoardLed::LightState)+0x60>)
   10e78:	4810      	ldr	r0, [pc, #64]	; (10ebc <sjsu::OnBoardLed::Set(unsigned char, sjsu::OnBoardLed::LightState)+0x64>)
   10e7a:	f002 fad3 	bl	13424 <printf>
   10e7e:	4810      	ldr	r0, [pc, #64]	; (10ec0 <sjsu::OnBoardLed::Set(unsigned char, sjsu::OnBoardLed::LightState)+0x68>)
   10e80:	f001 f900 	bl	12084 <puts>
   10e84:	2100      	movs	r1, #0
   10e86:	2001      	movs	r0, #1
   10e88:	f7ff fbf8 	bl	1067c <sjsu::debug::PrintBacktrace(bool, void*)>
   10e8c:	e7fe      	b.n	10e8c <sjsu::OnBoardLed::Set(unsigned char, sjsu::OnBoardLed::LightState)+0x34>
                     "Input Led number can't be greater than 3, input = %d.\n",
                     led_number);
    if (state == LightState::kOn)
   10e8e:	78bb      	ldrb	r3, [r7, #2]
   10e90:	2b01      	cmp	r3, #1
   10e92:	d105      	bne.n	10ea0 <sjsu::OnBoardLed::Set(unsigned char, sjsu::OnBoardLed::LightState)+0x48>
    {
      On(led_number);
   10e94:	78fb      	ldrb	r3, [r7, #3]
   10e96:	4619      	mov	r1, r3
   10e98:	6878      	ldr	r0, [r7, #4]
   10e9a:	f7ff ff85 	bl	10da8 <sjsu::OnBoardLed::On(unsigned char)>
    }
    else
    {
      Off(led_number);
    }
  }
   10e9e:	e004      	b.n	10eaa <sjsu::OnBoardLed::Set(unsigned char, sjsu::OnBoardLed::LightState)+0x52>
      Off(led_number);
   10ea0:	78fb      	ldrb	r3, [r7, #3]
   10ea2:	4619      	mov	r1, r3
   10ea4:	6878      	ldr	r0, [r7, #4]
   10ea6:	f7ff ffab 	bl	10e00 <sjsu::OnBoardLed::Off(unsigned char)>
  }
   10eaa:	bf00      	nop
   10eac:	3708      	adds	r7, #8
   10eae:	46bd      	mov	sp, r7
   10eb0:	bd80      	pop	{r7, pc}
   10eb2:	bf00      	nop
   10eb4:	00014df8 	.word	0x00014df8
   10eb8:	00014cf4 	.word	0x00014cf4
   10ebc:	00014aac 	.word	0x00014aac
   10ec0:	00014b60 	.word	0x00014b60

00010ec4 <sjsu::OnBoardLed::SetAll(unsigned char)>:

  // This function takes in the 4 least significant bits from value, and sets
  // the led to be ON or OFF. The least significant bit corresponds to LED0,
  // next least significant corresponds to LED1, etc. ON =1, OFF =0. The four
  // most significant bits will be unused.
  void SetAll(uint8_t value)
   10ec4:	b580      	push	{r7, lr}
   10ec6:	b084      	sub	sp, #16
   10ec8:	af00      	add	r7, sp, #0
   10eca:	6078      	str	r0, [r7, #4]
   10ecc:	460b      	mov	r3, r1
   10ece:	70fb      	strb	r3, [r7, #3]
  {
    for (uint8_t i = 0; i < 4; i++)
   10ed0:	2300      	movs	r3, #0
   10ed2:	73fb      	strb	r3, [r7, #15]
   10ed4:	7bfb      	ldrb	r3, [r7, #15]
   10ed6:	2b03      	cmp	r3, #3
   10ed8:	d818      	bhi.n	10f0c <sjsu::OnBoardLed::SetAll(unsigned char)+0x48>
    {
      if ((value >> i) & 1)
   10eda:	78fa      	ldrb	r2, [r7, #3]
   10edc:	7bfb      	ldrb	r3, [r7, #15]
   10ede:	fa42 f303 	asr.w	r3, r2, r3
   10ee2:	f003 0301 	and.w	r3, r3, #1
   10ee6:	2b00      	cmp	r3, #0
   10ee8:	d006      	beq.n	10ef8 <sjsu::OnBoardLed::SetAll(unsigned char)+0x34>
      {
        Set(i, LightState::kOn);
   10eea:	7bfb      	ldrb	r3, [r7, #15]
   10eec:	2201      	movs	r2, #1
   10eee:	4619      	mov	r1, r3
   10ef0:	6878      	ldr	r0, [r7, #4]
   10ef2:	f7ff ffb1 	bl	10e58 <sjsu::OnBoardLed::Set(unsigned char, sjsu::OnBoardLed::LightState)>
   10ef6:	e005      	b.n	10f04 <sjsu::OnBoardLed::SetAll(unsigned char)+0x40>
      }
      else
      {
        Set(i, LightState::kOff);
   10ef8:	7bfb      	ldrb	r3, [r7, #15]
   10efa:	2200      	movs	r2, #0
   10efc:	4619      	mov	r1, r3
   10efe:	6878      	ldr	r0, [r7, #4]
   10f00:	f7ff ffaa 	bl	10e58 <sjsu::OnBoardLed::Set(unsigned char, sjsu::OnBoardLed::LightState)>
    for (uint8_t i = 0; i < 4; i++)
   10f04:	7bfb      	ldrb	r3, [r7, #15]
   10f06:	3301      	adds	r3, #1
   10f08:	73fb      	strb	r3, [r7, #15]
   10f0a:	e7e3      	b.n	10ed4 <sjsu::OnBoardLed::SetAll(unsigned char)+0x10>
      }
    }
  }
   10f0c:	bf00      	nop
   10f0e:	3710      	adds	r7, #16
   10f10:	46bd      	mov	sp, r7
   10f12:	bd80      	pop	{r7, pc}

00010f14 <main>:
#include "L2_HAL/boards/sjtwo.hpp"
#include "utility/log.hpp"
#include "utility/time.hpp"

int main()
{
   10f14:	b580      	push	{r7, lr}
   10f16:	b084      	sub	sp, #16
   10f18:	af02      	add	r7, sp, #8
  LOG_INFO("Staring Hello World Application");
   10f1a:	230c      	movs	r3, #12
   10f1c:	4a18      	ldr	r2, [pc, #96]	; (10f80 <main+0x6c>)
   10f1e:	4919      	ldr	r1, [pc, #100]	; (10f84 <main+0x70>)
   10f20:	4819      	ldr	r0, [pc, #100]	; (10f88 <main+0x74>)
   10f22:	f002 fa7f 	bl	13424 <printf>
  LOG_INFO("Initializing LEDs...");
   10f26:	230d      	movs	r3, #13
   10f28:	4a15      	ldr	r2, [pc, #84]	; (10f80 <main+0x6c>)
   10f2a:	4918      	ldr	r1, [pc, #96]	; (10f8c <main+0x78>)
   10f2c:	4818      	ldr	r0, [pc, #96]	; (10f90 <main+0x7c>)
   10f2e:	f002 fa79 	bl	13424 <printf>
  }

  [[gnu::always_inline]] inline static sjsu::OnBoardLed & Leds()
  {
    static sjsu::OnBoardLed leds_;
    return leds_;
   10f32:	4b18      	ldr	r3, [pc, #96]	; (10f94 <main+0x80>)
  sjtwo::Leds().Initialize();
   10f34:	4618      	mov	r0, r3
   10f36:	f7ff ff17 	bl	10d68 <sjsu::OnBoardLed::Initialize()>
  LOG_INFO("LEDs Initialized!");
   10f3a:	230f      	movs	r3, #15
   10f3c:	4a10      	ldr	r2, [pc, #64]	; (10f80 <main+0x6c>)
   10f3e:	4916      	ldr	r1, [pc, #88]	; (10f98 <main+0x84>)
   10f40:	4816      	ldr	r0, [pc, #88]	; (10f9c <main+0x88>)
   10f42:	f002 fa6f 	bl	13424 <printf>
  while (true)
  {
    for (uint8_t i = 0; i < 16; i++)
   10f46:	2300      	movs	r3, #0
   10f48:	71fb      	strb	r3, [r7, #7]
   10f4a:	79fb      	ldrb	r3, [r7, #7]
   10f4c:	2b0f      	cmp	r3, #15
   10f4e:	d8fa      	bhi.n	10f46 <main+0x32>
    {
      LOG_INFO("Hello World 0x%X", i);
   10f50:	79fb      	ldrb	r3, [r7, #7]
   10f52:	9300      	str	r3, [sp, #0]
   10f54:	2314      	movs	r3, #20
   10f56:	4a0a      	ldr	r2, [pc, #40]	; (10f80 <main+0x6c>)
   10f58:	4911      	ldr	r1, [pc, #68]	; (10fa0 <main+0x8c>)
   10f5a:	4812      	ldr	r0, [pc, #72]	; (10fa4 <main+0x90>)
   10f5c:	f002 fa62 	bl	13424 <printf>
   10f60:	4a0c      	ldr	r2, [pc, #48]	; (10f94 <main+0x80>)
      sjtwo::Leds().SetAll(i);
   10f62:	79fb      	ldrb	r3, [r7, #7]
   10f64:	4619      	mov	r1, r3
   10f66:	4610      	mov	r0, r2
   10f68:	f7ff ffac 	bl	10ec4 <sjsu::OnBoardLed::SetAll(unsigned char)>
      sjsu::Delay(500);
   10f6c:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
   10f70:	f04f 0100 	mov.w	r1, #0
   10f74:	f7ff fc4f 	bl	10816 <sjsu::Delay(unsigned long long)>
    for (uint8_t i = 0; i < 16; i++)
   10f78:	79fb      	ldrb	r3, [r7, #7]
   10f7a:	3301      	adds	r3, #1
   10f7c:	71fb      	strb	r3, [r7, #7]
   10f7e:	e7e4      	b.n	10f4a <main+0x36>
   10f80:	00014d74 	.word	0x00014d74
   10f84:	00014d04 	.word	0x00014d04
   10f88:	00014b78 	.word	0x00014b78
   10f8c:	00014d10 	.word	0x00014d10
   10f90:	00014bd4 	.word	0x00014bd4
   10f94:	10000048 	.word	0x10000048
   10f98:	00014d1c 	.word	0x00014d1c
   10f9c:	00014c24 	.word	0x00014c24
   10fa0:	00014d28 	.word	0x00014d28
   10fa4:	00014c70 	.word	0x00014c70

00010fa8 <unsigned long sjsu::bit::Insert<unsigned long, unsigned char>(unsigned long, unsigned char, unsigned long, unsigned long)>:
/// @param target the target that will have bits inserted into it.
/// @param value the bits to be inserted into the target
/// @param position the position in the target to insert the value of bits.
/// @param width the length of bits that will be overwritten in the target.
template <typename T, typename U>
[[nodiscard]] constexpr T Insert(T target, U value, uint32_t position,
   10fa8:	b480      	push	{r7}
   10faa:	b089      	sub	sp, #36	; 0x24
   10fac:	af00      	add	r7, sp, #0
   10fae:	60f8      	str	r0, [r7, #12]
   10fb0:	607a      	str	r2, [r7, #4]
   10fb2:	603b      	str	r3, [r7, #0]
   10fb4:	460b      	mov	r3, r1
   10fb6:	72fb      	strb	r3, [r7, #11]
  // Need to use an unsigned version of the type T for the mask to make sure
  // that the shift right doesn't result in a sign extended shift.
  using UnsignedT = typename std::make_unsigned<T>::type;
  // At compile time, generate variable containing all 1s with the size of the
  // target parameter.
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   10fb8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   10fbc:	61fb      	str	r3, [r7, #28]
  // At compile time calculate the number of bits in the target parameter.
  constexpr size_t kTargetWidth = sizeof(T) * 8;
   10fbe:	2320      	movs	r3, #32
   10fc0:	61bb      	str	r3, [r7, #24]
  // Create mask by shifting the set of 1s down so that the number of 1s from
  // bit position 0 is equal to the width parameter.
  UnsignedT mask = kFieldOfOnes >> (kTargetWidth - width);
   10fc2:	683b      	ldr	r3, [r7, #0]
   10fc4:	f1c3 0320 	rsb	r3, r3, #32
   10fc8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   10fcc:	fa22 f303 	lsr.w	r3, r2, r3
   10fd0:	617b      	str	r3, [r7, #20]
  // Clear width's number of bits in the target value at the bit position
  // specified.
  target &= ~(mask << position);
   10fd2:	697a      	ldr	r2, [r7, #20]
   10fd4:	687b      	ldr	r3, [r7, #4]
   10fd6:	fa02 f303 	lsl.w	r3, r2, r3
   10fda:	43db      	mvns	r3, r3
   10fdc:	68fa      	ldr	r2, [r7, #12]
   10fde:	4013      	ands	r3, r2
   10fe0:	60fb      	str	r3, [r7, #12]
  // AND value with mask to remove any bits beyond the specified width.
  // Shift masked value into bit position and OR with target value.
  target |= (value & mask) << position;
   10fe2:	7afa      	ldrb	r2, [r7, #11]
   10fe4:	697b      	ldr	r3, [r7, #20]
   10fe6:	401a      	ands	r2, r3
   10fe8:	687b      	ldr	r3, [r7, #4]
   10fea:	fa02 f303 	lsl.w	r3, r2, r3
   10fee:	68fa      	ldr	r2, [r7, #12]
   10ff0:	4313      	orrs	r3, r2
   10ff2:	60fb      	str	r3, [r7, #12]
  return target;
   10ff4:	68fb      	ldr	r3, [r7, #12]
}
   10ff6:	4618      	mov	r0, r3
   10ff8:	3724      	adds	r7, #36	; 0x24
   10ffa:	46bd      	mov	sp, r7
   10ffc:	f85d 7b04 	ldr.w	r7, [sp], #4
   11000:	4770      	bx	lr

00011002 <unsigned long sjsu::bit::Insert<unsigned long, int>(unsigned long, int, unsigned long, unsigned long)>:
[[nodiscard]] constexpr T Insert(T target, U value, uint32_t position,
   11002:	b480      	push	{r7}
   11004:	b089      	sub	sp, #36	; 0x24
   11006:	af00      	add	r7, sp, #0
   11008:	60f8      	str	r0, [r7, #12]
   1100a:	60b9      	str	r1, [r7, #8]
   1100c:	607a      	str	r2, [r7, #4]
   1100e:	603b      	str	r3, [r7, #0]
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   11010:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   11014:	61fb      	str	r3, [r7, #28]
  constexpr size_t kTargetWidth = sizeof(T) * 8;
   11016:	2320      	movs	r3, #32
   11018:	61bb      	str	r3, [r7, #24]
  UnsignedT mask = kFieldOfOnes >> (kTargetWidth - width);
   1101a:	683b      	ldr	r3, [r7, #0]
   1101c:	f1c3 0320 	rsb	r3, r3, #32
   11020:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   11024:	fa22 f303 	lsr.w	r3, r2, r3
   11028:	617b      	str	r3, [r7, #20]
  target &= ~(mask << position);
   1102a:	697a      	ldr	r2, [r7, #20]
   1102c:	687b      	ldr	r3, [r7, #4]
   1102e:	fa02 f303 	lsl.w	r3, r2, r3
   11032:	43db      	mvns	r3, r3
   11034:	68fa      	ldr	r2, [r7, #12]
   11036:	4013      	ands	r3, r2
   11038:	60fb      	str	r3, [r7, #12]
  target |= (value & mask) << position;
   1103a:	68ba      	ldr	r2, [r7, #8]
   1103c:	697b      	ldr	r3, [r7, #20]
   1103e:	401a      	ands	r2, r3
   11040:	687b      	ldr	r3, [r7, #4]
   11042:	fa02 f303 	lsl.w	r3, r2, r3
   11046:	68fa      	ldr	r2, [r7, #12]
   11048:	4313      	orrs	r3, r2
   1104a:	60fb      	str	r3, [r7, #12]
  return target;
   1104c:	68fb      	ldr	r3, [r7, #12]
}
   1104e:	4618      	mov	r0, r3
   11050:	3724      	adds	r7, #36	; 0x24
   11052:	46bd      	mov	sp, r7
   11054:	f85d 7b04 	ldr.w	r7, [sp], #4
   11058:	4770      	bx	lr

0001105a <unsigned long sjsu::bit::Insert<unsigned long, bool>(unsigned long, bool, unsigned long, unsigned long)>:
[[nodiscard]] constexpr T Insert(T target, U value, uint32_t position,
   1105a:	b480      	push	{r7}
   1105c:	b089      	sub	sp, #36	; 0x24
   1105e:	af00      	add	r7, sp, #0
   11060:	60f8      	str	r0, [r7, #12]
   11062:	607a      	str	r2, [r7, #4]
   11064:	603b      	str	r3, [r7, #0]
   11066:	460b      	mov	r3, r1
   11068:	72fb      	strb	r3, [r7, #11]
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   1106a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1106e:	61fb      	str	r3, [r7, #28]
  constexpr size_t kTargetWidth = sizeof(T) * 8;
   11070:	2320      	movs	r3, #32
   11072:	61bb      	str	r3, [r7, #24]
  UnsignedT mask = kFieldOfOnes >> (kTargetWidth - width);
   11074:	683b      	ldr	r3, [r7, #0]
   11076:	f1c3 0320 	rsb	r3, r3, #32
   1107a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1107e:	fa22 f303 	lsr.w	r3, r2, r3
   11082:	617b      	str	r3, [r7, #20]
  target &= ~(mask << position);
   11084:	697a      	ldr	r2, [r7, #20]
   11086:	687b      	ldr	r3, [r7, #4]
   11088:	fa02 f303 	lsl.w	r3, r2, r3
   1108c:	43db      	mvns	r3, r3
   1108e:	68fa      	ldr	r2, [r7, #12]
   11090:	4013      	ands	r3, r2
   11092:	60fb      	str	r3, [r7, #12]
  target |= (value & mask) << position;
   11094:	7afa      	ldrb	r2, [r7, #11]
   11096:	697b      	ldr	r3, [r7, #20]
   11098:	401a      	ands	r2, r3
   1109a:	687b      	ldr	r3, [r7, #4]
   1109c:	fa02 f303 	lsl.w	r3, r2, r3
   110a0:	68fa      	ldr	r2, [r7, #12]
   110a2:	4313      	orrs	r3, r2
   110a4:	60fb      	str	r3, [r7, #12]
  return target;
   110a6:	68fb      	ldr	r3, [r7, #12]
}
   110a8:	4618      	mov	r0, r3
   110aa:	3724      	adds	r7, #36	; 0x24
   110ac:	46bd      	mov	sp, r7
   110ae:	f85d 7b04 	ldr.w	r7, [sp], #4
   110b2:	4770      	bx	lr

000110b4 <sjsu::SetUptimeFunction(unsigned long long (*)())>:
{
   110b4:	b480      	push	{r7}
   110b6:	b083      	sub	sp, #12
   110b8:	af00      	add	r7, sp, #0
   110ba:	6078      	str	r0, [r7, #4]
  Uptime = uptime_function;
   110bc:	4a04      	ldr	r2, [pc, #16]	; (110d0 <sjsu::SetUptimeFunction(unsigned long long (*)())+0x1c>)
   110be:	687b      	ldr	r3, [r7, #4]
   110c0:	6013      	str	r3, [r2, #0]
}
   110c2:	bf00      	nop
   110c4:	370c      	adds	r7, #12
   110c6:	46bd      	mov	sp, r7
   110c8:	f85d 7b04 	ldr.w	r7, [sp], #4
   110cc:	4770      	bx	lr
   110ce:	bf00      	nop
   110d0:	10000004 	.word	0x10000004

000110d4 <sjsu::lpc40xx::SystemController::SetClockFrequency(unsigned char) const>:
  static constexpr uint32_t kDefaultIRCFrequency    = 12'000'000;
  static constexpr uint32_t kDefaultTimeout         = 1'000;  // ms

  inline static LPC_SC_TypeDef * system_controller = LPC_SC;

  uint32_t SetClockFrequency(uint8_t frequency_in_mhz) const final override
   110d4:	b580      	push	{r7, lr}
   110d6:	b084      	sub	sp, #16
   110d8:	af00      	add	r7, sp, #0
   110da:	6078      	str	r0, [r7, #4]
   110dc:	460b      	mov	r3, r1
   110de:	70fb      	strb	r3, [r7, #3]
  {
    uint32_t offset = 0;
   110e0:	2300      	movs	r3, #0
   110e2:	60fb      	str	r3, [r7, #12]
    SelectOscillatorSource(OscillatorSource::kIrc);
   110e4:	2100      	movs	r1, #0
   110e6:	6878      	ldr	r0, [r7, #4]
   110e8:	f000 f8f2 	bl	112d0 <sjsu::lpc40xx::SystemController::SelectOscillatorSource(sjsu::lpc40xx::SystemController::OscillatorSource) const>
    if (frequency_in_mhz > 12)
   110ec:	78fb      	ldrb	r3, [r7, #3]
   110ee:	2b0c      	cmp	r3, #12
   110f0:	d914      	bls.n	1111c <sjsu::lpc40xx::SystemController::SetClockFrequency(unsigned char) const+0x48>
    {
      offset = SetMainPll(PllInput::kIrc, frequency_in_mhz);
   110f2:	78fb      	ldrb	r3, [r7, #3]
   110f4:	b29b      	uxth	r3, r3
   110f6:	461a      	mov	r2, r3
   110f8:	210c      	movs	r1, #12
   110fa:	6878      	ldr	r0, [r7, #4]
   110fc:	f000 f9c6 	bl	1148c <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const>
   11100:	60f8      	str	r0, [r7, #12]
      SelectMainClockSource(MainClockSource::kPllClock);
   11102:	f44f 7180 	mov.w	r1, #256	; 0x100
   11106:	6878      	ldr	r0, [r7, #4]
   11108:	f000 f8fe 	bl	11308 <sjsu::lpc40xx::SystemController::SelectMainClockSource(sjsu::lpc40xx::SystemController::MainClockSource) const>
      speed_in_hertz = frequency_in_mhz * 1'000'000;
   1110c:	78fb      	ldrb	r3, [r7, #3]
   1110e:	4a0f      	ldr	r2, [pc, #60]	; (1114c <sjsu::lpc40xx::SystemController::SetClockFrequency(unsigned char) const+0x78>)
   11110:	fb02 f303 	mul.w	r3, r2, r3
   11114:	461a      	mov	r2, r3
   11116:	4b0e      	ldr	r3, [pc, #56]	; (11150 <sjsu::lpc40xx::SystemController::SetClockFrequency(unsigned char) const+0x7c>)
   11118:	601a      	str	r2, [r3, #0]
   1111a:	e006      	b.n	1112a <sjsu::lpc40xx::SystemController::SetClockFrequency(unsigned char) const+0x56>
    }
    else
    {
      SelectMainClockSource(MainClockSource::kBaseClock);
   1111c:	2100      	movs	r1, #0
   1111e:	6878      	ldr	r0, [r7, #4]
   11120:	f000 f8f2 	bl	11308 <sjsu::lpc40xx::SystemController::SelectMainClockSource(sjsu::lpc40xx::SystemController::MainClockSource) const>
      speed_in_hertz = kDefaultIRCFrequency;
   11124:	4b0a      	ldr	r3, [pc, #40]	; (11150 <sjsu::lpc40xx::SystemController::SetClockFrequency(unsigned char) const+0x7c>)
   11126:	4a0b      	ldr	r2, [pc, #44]	; (11154 <sjsu::lpc40xx::SystemController::SetClockFrequency(unsigned char) const+0x80>)
   11128:	601a      	str	r2, [r3, #0]
    }
    SetCpuClockDivider(kDivideInputBy1);
   1112a:	2101      	movs	r1, #1
   1112c:	6878      	ldr	r0, [r7, #4]
   1112e:	f000 fa5f 	bl	115f0 <sjsu::lpc40xx::SystemController::SetCpuClockDivider(unsigned char) const>
    SetPeripheralClockDivider(kDivideInputBy1);
   11132:	2101      	movs	r1, #1
   11134:	6878      	ldr	r0, [r7, #4]
   11136:	f000 f80f 	bl	11158 <sjsu::lpc40xx::SystemController::SetPeripheralClockDivider(unsigned char) const>
    SetEmcClockDivider(EmcDivider::kSameSpeedAsCpu);
   1113a:	2100      	movs	r1, #0
   1113c:	6878      	ldr	r0, [r7, #4]
   1113e:	f000 fa89 	bl	11654 <sjsu::lpc40xx::SystemController::SetEmcClockDivider(sjsu::lpc40xx::SystemController::EmcDivider) const>
    return offset;
   11142:	68fb      	ldr	r3, [r7, #12]
  }
   11144:	4618      	mov	r0, r3
   11146:	3710      	adds	r7, #16
   11148:	46bd      	mov	sp, r7
   1114a:	bd80      	pop	{r7, pc}
   1114c:	000f4240 	.word	0x000f4240
   11150:	1000008c 	.word	0x1000008c
   11154:	00b71b00 	.word	0x00b71b00

00011158 <sjsu::lpc40xx::SystemController::SetPeripheralClockDivider(unsigned char) const>:

  void SetPeripheralClockDivider(
   11158:	b580      	push	{r7, lr}
   1115a:	b082      	sub	sp, #8
   1115c:	af00      	add	r7, sp, #0
   1115e:	6078      	str	r0, [r7, #4]
   11160:	460b      	mov	r3, r1
   11162:	70fb      	strb	r3, [r7, #3]
      uint8_t peripheral_divider) const final override
  {
    SJ2_ASSERT_FATAL(peripheral_divider <= 4, "Divider mustn't exceed 32");
   11164:	78fb      	ldrb	r3, [r7, #3]
   11166:	2b04      	cmp	r3, #4
   11168:	d90d      	bls.n	11186 <sjsu::lpc40xx::SystemController::SetPeripheralClockDivider(unsigned char) const+0x2e>
   1116a:	2398      	movs	r3, #152	; 0x98
   1116c:	4a0a      	ldr	r2, [pc, #40]	; (11198 <sjsu::lpc40xx::SystemController::SetPeripheralClockDivider(unsigned char) const+0x40>)
   1116e:	490b      	ldr	r1, [pc, #44]	; (1119c <sjsu::lpc40xx::SystemController::SetPeripheralClockDivider(unsigned char) const+0x44>)
   11170:	480b      	ldr	r0, [pc, #44]	; (111a0 <sjsu::lpc40xx::SystemController::SetPeripheralClockDivider(unsigned char) const+0x48>)
   11172:	f002 f957 	bl	13424 <printf>
   11176:	480b      	ldr	r0, [pc, #44]	; (111a4 <sjsu::lpc40xx::SystemController::SetPeripheralClockDivider(unsigned char) const+0x4c>)
   11178:	f000 ff84 	bl	12084 <puts>
   1117c:	2100      	movs	r1, #0
   1117e:	2001      	movs	r0, #1
   11180:	f7ff fa7c 	bl	1067c <sjsu::debug::PrintBacktrace(bool, void*)>
   11184:	e7fe      	b.n	11184 <sjsu::lpc40xx::SystemController::SetPeripheralClockDivider(unsigned char) const+0x2c>
    system_controller->PCLKSEL = peripheral_divider;
   11186:	4b08      	ldr	r3, [pc, #32]	; (111a8 <sjsu::lpc40xx::SystemController::SetPeripheralClockDivider(unsigned char) const+0x50>)
   11188:	681b      	ldr	r3, [r3, #0]
   1118a:	78fa      	ldrb	r2, [r7, #3]
   1118c:	f8c3 21a8 	str.w	r2, [r3, #424]	; 0x1a8
  }
   11190:	bf00      	nop
   11192:	3708      	adds	r7, #8
   11194:	46bd      	mov	sp, r7
   11196:	bd80      	pop	{r7, pc}
   11198:	000157b0 	.word	0x000157b0
   1119c:	00015598 	.word	0x00015598
   111a0:	00014f94 	.word	0x00014f94
   111a4:	00015034 	.word	0x00015034
   111a8:	10000088 	.word	0x10000088

000111ac <sjsu::lpc40xx::SystemController::GetPeripheralClockDivider() const>:

  uint32_t GetPeripheralClockDivider() const final override
   111ac:	b480      	push	{r7}
   111ae:	b083      	sub	sp, #12
   111b0:	af00      	add	r7, sp, #0
   111b2:	6078      	str	r0, [r7, #4]
    {
      return 1;
    }
    else
    {
      return system_controller->PCLKSEL;
   111b4:	4b04      	ldr	r3, [pc, #16]	; (111c8 <sjsu::lpc40xx::SystemController::GetPeripheralClockDivider() const+0x1c>)
   111b6:	681b      	ldr	r3, [r3, #0]
   111b8:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
    }
  }
   111bc:	4618      	mov	r0, r3
   111be:	370c      	adds	r7, #12
   111c0:	46bd      	mov	sp, r7
   111c2:	f85d 7b04 	ldr.w	r7, [sp], #4
   111c6:	4770      	bx	lr
   111c8:	10000088 	.word	0x10000088

000111cc <sjsu::lpc40xx::SystemController::GetSystemFrequency() const>:

  uint32_t GetSystemFrequency() const final override
   111cc:	b480      	push	{r7}
   111ce:	b083      	sub	sp, #12
   111d0:	af00      	add	r7, sp, #0
   111d2:	6078      	str	r0, [r7, #4]
    {
      return config::kSystemClockRate;
    }
    else
    {
      return speed_in_hertz;
   111d4:	4b03      	ldr	r3, [pc, #12]	; (111e4 <sjsu::lpc40xx::SystemController::GetSystemFrequency() const+0x18>)
   111d6:	681b      	ldr	r3, [r3, #0]
    }
  }
   111d8:	4618      	mov	r0, r3
   111da:	370c      	adds	r7, #12
   111dc:	46bd      	mov	sp, r7
   111de:	f85d 7b04 	ldr.w	r7, [sp], #4
   111e2:	4770      	bx	lr
   111e4:	1000008c 	.word	0x1000008c

000111e8 <sjsu::lpc40xx::SystemController::GetPeripheralFrequency() const>:

  uint32_t GetPeripheralFrequency() const final override
   111e8:	b580      	push	{r7, lr}
   111ea:	b084      	sub	sp, #16
   111ec:	af00      	add	r7, sp, #0
   111ee:	6078      	str	r0, [r7, #4]
  {
    uint32_t peripheral_clock_divider = GetPeripheralClockDivider();
   111f0:	6878      	ldr	r0, [r7, #4]
   111f2:	f7ff ffdb 	bl	111ac <sjsu::lpc40xx::SystemController::GetPeripheralClockDivider() const>
   111f6:	60b8      	str	r0, [r7, #8]
    uint32_t result = 0;  // return 0 if peripheral_clock_divider == 0
   111f8:	2300      	movs	r3, #0
   111fa:	60fb      	str	r3, [r7, #12]
    if (peripheral_clock_divider != 0)
   111fc:	68bb      	ldr	r3, [r7, #8]
   111fe:	2b00      	cmp	r3, #0
   11200:	d007      	beq.n	11212 <sjsu::lpc40xx::SystemController::GetPeripheralFrequency() const+0x2a>
    {
      result = GetSystemFrequency() / peripheral_clock_divider;
   11202:	6878      	ldr	r0, [r7, #4]
   11204:	f7ff ffe2 	bl	111cc <sjsu::lpc40xx::SystemController::GetSystemFrequency() const>
   11208:	4602      	mov	r2, r0
   1120a:	68bb      	ldr	r3, [r7, #8]
   1120c:	fbb2 f3f3 	udiv	r3, r2, r3
   11210:	60fb      	str	r3, [r7, #12]
    }
    return result;
   11212:	68fb      	ldr	r3, [r7, #12]
  }
   11214:	4618      	mov	r0, r3
   11216:	3710      	adds	r7, #16
   11218:	46bd      	mov	sp, r7
   1121a:	bd80      	pop	{r7, pc}

0001121c <sjsu::lpc40xx::SystemController::IsPeripheralPoweredUp(sjsu::SystemController::PeripheralID const&) const>:
  /// Check if a peripheral is powered up by checking the power connection
  /// register. Should typically only be used for unit testing code and
  /// debugging.
  bool IsPeripheralPoweredUp(
   1121c:	b480      	push	{r7}
   1121e:	b085      	sub	sp, #20
   11220:	af00      	add	r7, sp, #0
   11222:	6078      	str	r0, [r7, #4]
   11224:	6039      	str	r1, [r7, #0]
      const PeripheralID & peripheral_select) const final override
  {
    bool peripheral_is_powered_on =
        system_controller->PCONP & (1 << peripheral_select.device_id);
   11226:	4b0b      	ldr	r3, [pc, #44]	; (11254 <sjsu::lpc40xx::SystemController::IsPeripheralPoweredUp(sjsu::SystemController::PeripheralID const&) const+0x38>)
   11228:	681b      	ldr	r3, [r3, #0]
   1122a:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
   1122e:	683a      	ldr	r2, [r7, #0]
   11230:	6812      	ldr	r2, [r2, #0]
   11232:	2101      	movs	r1, #1
   11234:	fa01 f202 	lsl.w	r2, r1, r2
   11238:	4013      	ands	r3, r2
   1123a:	2b00      	cmp	r3, #0
   1123c:	bf14      	ite	ne
   1123e:	2301      	movne	r3, #1
   11240:	2300      	moveq	r3, #0
   11242:	73fb      	strb	r3, [r7, #15]

    return peripheral_is_powered_on;
   11244:	7bfb      	ldrb	r3, [r7, #15]
  }
   11246:	4618      	mov	r0, r3
   11248:	3714      	adds	r7, #20
   1124a:	46bd      	mov	sp, r7
   1124c:	f85d 7b04 	ldr.w	r7, [sp], #4
   11250:	4770      	bx	lr
   11252:	bf00      	nop
   11254:	10000088 	.word	0x10000088

00011258 <sjsu::lpc40xx::SystemController::PowerUpPeripheral(sjsu::SystemController::PeripheralID const&) const>:
  void PowerUpPeripheral(
   11258:	b480      	push	{r7}
   1125a:	b085      	sub	sp, #20
   1125c:	af00      	add	r7, sp, #0
   1125e:	6078      	str	r0, [r7, #4]
   11260:	6039      	str	r1, [r7, #0]
      const PeripheralID & peripheral_select) const final override
  {
    auto power_connection_with_enabled_peripheral =
        system_controller->PCONP | (1 << peripheral_select.device_id);
   11262:	4b0b      	ldr	r3, [pc, #44]	; (11290 <sjsu::lpc40xx::SystemController::PowerUpPeripheral(sjsu::SystemController::PeripheralID const&) const+0x38>)
   11264:	681b      	ldr	r3, [r3, #0]
   11266:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
   1126a:	683a      	ldr	r2, [r7, #0]
   1126c:	6812      	ldr	r2, [r2, #0]
   1126e:	2101      	movs	r1, #1
   11270:	fa01 f202 	lsl.w	r2, r1, r2
   11274:	4313      	orrs	r3, r2
   11276:	60fb      	str	r3, [r7, #12]

    system_controller->PCONP = power_connection_with_enabled_peripheral;
   11278:	4b05      	ldr	r3, [pc, #20]	; (11290 <sjsu::lpc40xx::SystemController::PowerUpPeripheral(sjsu::SystemController::PeripheralID const&) const+0x38>)
   1127a:	681b      	ldr	r3, [r3, #0]
   1127c:	68fa      	ldr	r2, [r7, #12]
   1127e:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
  }
   11282:	bf00      	nop
   11284:	3714      	adds	r7, #20
   11286:	46bd      	mov	sp, r7
   11288:	f85d 7b04 	ldr.w	r7, [sp], #4
   1128c:	4770      	bx	lr
   1128e:	bf00      	nop
   11290:	10000088 	.word	0x10000088

00011294 <sjsu::lpc40xx::SystemController::PowerDownPeripheral(sjsu::SystemController::PeripheralID const&) const>:
  void PowerDownPeripheral(
   11294:	b480      	push	{r7}
   11296:	b085      	sub	sp, #20
   11298:	af00      	add	r7, sp, #0
   1129a:	6078      	str	r0, [r7, #4]
   1129c:	6039      	str	r1, [r7, #0]
      const PeripheralID & peripheral_select) const final override
  {
    auto power_connection_without_enabled_peripheral =
        system_controller->PCONP & (1 << peripheral_select.device_id);
   1129e:	4b0b      	ldr	r3, [pc, #44]	; (112cc <sjsu::lpc40xx::SystemController::PowerDownPeripheral(sjsu::SystemController::PeripheralID const&) const+0x38>)
   112a0:	681b      	ldr	r3, [r3, #0]
   112a2:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
   112a6:	683a      	ldr	r2, [r7, #0]
   112a8:	6812      	ldr	r2, [r2, #0]
   112aa:	2101      	movs	r1, #1
   112ac:	fa01 f202 	lsl.w	r2, r1, r2
   112b0:	4013      	ands	r3, r2
   112b2:	60fb      	str	r3, [r7, #12]

    system_controller->PCONP = power_connection_without_enabled_peripheral;
   112b4:	4b05      	ldr	r3, [pc, #20]	; (112cc <sjsu::lpc40xx::SystemController::PowerDownPeripheral(sjsu::SystemController::PeripheralID const&) const+0x38>)
   112b6:	681b      	ldr	r3, [r3, #0]
   112b8:	68fa      	ldr	r2, [r7, #12]
   112ba:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
  }
   112be:	bf00      	nop
   112c0:	3714      	adds	r7, #20
   112c2:	46bd      	mov	sp, r7
   112c4:	f85d 7b04 	ldr.w	r7, [sp], #4
   112c8:	4770      	bx	lr
   112ca:	bf00      	nop
   112cc:	10000088 	.word	0x10000088

000112d0 <sjsu::lpc40xx::SystemController::SelectOscillatorSource(sjsu::lpc40xx::SystemController::OscillatorSource) const>:

 private:
  void SelectOscillatorSource(OscillatorSource source) const
   112d0:	b480      	push	{r7}
   112d2:	b085      	sub	sp, #20
   112d4:	af00      	add	r7, sp, #0
   112d6:	6078      	str	r0, [r7, #4]
   112d8:	460b      	mov	r3, r1
   112da:	807b      	strh	r3, [r7, #2]
  {
    uint32_t source_bit = static_cast<uint32_t>(source);
   112dc:	887b      	ldrh	r3, [r7, #2]
   112de:	60fb      	str	r3, [r7, #12]
    system_controller->CLKSRCSEL =
        (system_controller->CLKSRCSEL & ~(kOscillatorSelect)) | source_bit;
   112e0:	4b08      	ldr	r3, [pc, #32]	; (11304 <sjsu::lpc40xx::SystemController::SelectOscillatorSource(sjsu::lpc40xx::SystemController::OscillatorSource) const+0x34>)
   112e2:	681b      	ldr	r3, [r3, #0]
   112e4:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
   112e8:	f023 0101 	bic.w	r1, r3, #1
    system_controller->CLKSRCSEL =
   112ec:	4b05      	ldr	r3, [pc, #20]	; (11304 <sjsu::lpc40xx::SystemController::SelectOscillatorSource(sjsu::lpc40xx::SystemController::OscillatorSource) const+0x34>)
   112ee:	681b      	ldr	r3, [r3, #0]
        (system_controller->CLKSRCSEL & ~(kOscillatorSelect)) | source_bit;
   112f0:	68fa      	ldr	r2, [r7, #12]
   112f2:	430a      	orrs	r2, r1
    system_controller->CLKSRCSEL =
   112f4:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
  }
   112f8:	bf00      	nop
   112fa:	3714      	adds	r7, #20
   112fc:	46bd      	mov	sp, r7
   112fe:	f85d 7b04 	ldr.w	r7, [sp], #4
   11302:	4770      	bx	lr
   11304:	10000088 	.word	0x10000088

00011308 <sjsu::lpc40xx::SystemController::SelectMainClockSource(sjsu::lpc40xx::SystemController::MainClockSource) const>:

  void SelectMainClockSource(MainClockSource source) const
   11308:	b480      	push	{r7}
   1130a:	b083      	sub	sp, #12
   1130c:	af00      	add	r7, sp, #0
   1130e:	6078      	str	r0, [r7, #4]
   11310:	460b      	mov	r3, r1
   11312:	807b      	strh	r3, [r7, #2]
  {
    system_controller->CCLKSEL =
        (system_controller->CCLKSEL & ~(kBaseClockSelect)) |
   11314:	4b08      	ldr	r3, [pc, #32]	; (11338 <sjsu::lpc40xx::SystemController::SelectMainClockSource(sjsu::lpc40xx::SystemController::MainClockSource) const+0x30>)
   11316:	681b      	ldr	r3, [r3, #0]
   11318:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
   1131c:	f423 7180 	bic.w	r1, r3, #256	; 0x100
        static_cast<uint32_t>(source);
   11320:	887a      	ldrh	r2, [r7, #2]
    system_controller->CCLKSEL =
   11322:	4b05      	ldr	r3, [pc, #20]	; (11338 <sjsu::lpc40xx::SystemController::SelectMainClockSource(sjsu::lpc40xx::SystemController::MainClockSource) const+0x30>)
   11324:	681b      	ldr	r3, [r3, #0]
        (system_controller->CCLKSEL & ~(kBaseClockSelect)) |
   11326:	430a      	orrs	r2, r1
    system_controller->CCLKSEL =
   11328:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
  }
   1132c:	bf00      	nop
   1132e:	370c      	adds	r7, #12
   11330:	46bd      	mov	sp, r7
   11332:	f85d 7b04 	ldr.w	r7, [sp], #4
   11336:	4770      	bx	lr
   11338:	10000088 	.word	0x10000088

0001133c <sjsu::lpc40xx::SystemController::SelectUsbClockSource(sjsu::lpc40xx::SystemController::UsbSource) const>:

  void SelectUsbClockSource(UsbSource usb_clock) const
   1133c:	b480      	push	{r7}
   1133e:	b083      	sub	sp, #12
   11340:	af00      	add	r7, sp, #0
   11342:	6078      	str	r0, [r7, #4]
   11344:	460b      	mov	r3, r1
   11346:	807b      	strh	r3, [r7, #2]
  {
    system_controller->USBCLKSEL =
        (system_controller->USBCLKSEL & ~(kUsbClockSource)) |
   11348:	4b08      	ldr	r3, [pc, #32]	; (1136c <sjsu::lpc40xx::SystemController::SelectUsbClockSource(sjsu::lpc40xx::SystemController::UsbSource) const+0x30>)
   1134a:	681b      	ldr	r3, [r3, #0]
   1134c:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
   11350:	f423 7140 	bic.w	r1, r3, #768	; 0x300
        static_cast<uint32_t>(usb_clock);
   11354:	887a      	ldrh	r2, [r7, #2]
    system_controller->USBCLKSEL =
   11356:	4b05      	ldr	r3, [pc, #20]	; (1136c <sjsu::lpc40xx::SystemController::SelectUsbClockSource(sjsu::lpc40xx::SystemController::UsbSource) const+0x30>)
   11358:	681b      	ldr	r3, [r3, #0]
        (system_controller->USBCLKSEL & ~(kUsbClockSource)) |
   1135a:	430a      	orrs	r2, r1
    system_controller->USBCLKSEL =
   1135c:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
  }
   11360:	bf00      	nop
   11362:	370c      	adds	r7, #12
   11364:	46bd      	mov	sp, r7
   11366:	f85d 7b04 	ldr.w	r7, [sp], #4
   1136a:	4770      	bx	lr
   1136c:	10000088 	.word	0x10000088

00011370 <sjsu::lpc40xx::SystemController::SelectSpifiClockSource(sjsu::lpc40xx::SystemController::SpifiSource) const>:

  void SelectSpifiClockSource(SpifiSource spifi_clock) const
   11370:	b480      	push	{r7}
   11372:	b083      	sub	sp, #12
   11374:	af00      	add	r7, sp, #0
   11376:	6078      	str	r0, [r7, #4]
   11378:	460b      	mov	r3, r1
   1137a:	807b      	strh	r3, [r7, #2]
  {
    system_controller->SPIFISEL =
        (system_controller->SPIFISEL & ~(kSpifiClockSource)) |
   1137c:	4b08      	ldr	r3, [pc, #32]	; (113a0 <sjsu::lpc40xx::SystemController::SelectSpifiClockSource(sjsu::lpc40xx::SystemController::SpifiSource) const+0x30>)
   1137e:	681b      	ldr	r3, [r3, #0]
   11380:	f8d3 31b4 	ldr.w	r3, [r3, #436]	; 0x1b4
   11384:	f423 7140 	bic.w	r1, r3, #768	; 0x300
        static_cast<uint32_t>(spifi_clock);
   11388:	887a      	ldrh	r2, [r7, #2]
    system_controller->SPIFISEL =
   1138a:	4b05      	ldr	r3, [pc, #20]	; (113a0 <sjsu::lpc40xx::SystemController::SelectSpifiClockSource(sjsu::lpc40xx::SystemController::SpifiSource) const+0x30>)
   1138c:	681b      	ldr	r3, [r3, #0]
        (system_controller->SPIFISEL & ~(kSpifiClockSource)) |
   1138e:	430a      	orrs	r2, r1
    system_controller->SPIFISEL =
   11390:	f8c3 21b4 	str.w	r2, [r3, #436]	; 0x1b4
  }
   11394:	bf00      	nop
   11396:	370c      	adds	r7, #12
   11398:	46bd      	mov	sp, r7
   1139a:	f85d 7b04 	ldr.w	r7, [sp], #4
   1139e:	4770      	bx	lr
   113a0:	10000088 	.word	0x10000088

000113a4 <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const>:

  uint32_t CalculatePll(PllInput input_frequency,
   113a4:	b580      	push	{r7, lr}
   113a6:	b086      	sub	sp, #24
   113a8:	af00      	add	r7, sp, #0
   113aa:	6078      	str	r0, [r7, #4]
   113ac:	460b      	mov	r3, r1
   113ae:	807b      	strh	r3, [r7, #2]
   113b0:	4613      	mov	r3, r2
   113b2:	803b      	strh	r3, [r7, #0]
                        uint16_t desired_speed_in_mhz) const
  {
    SJ2_ASSERT_FATAL(desired_speed_in_mhz < 384 && desired_speed_in_mhz > 12,
   113b4:	883b      	ldrh	r3, [r7, #0]
   113b6:	f5b3 7fc0 	cmp.w	r3, #384	; 0x180
   113ba:	d202      	bcs.n	113c2 <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x1e>
   113bc:	883b      	ldrh	r3, [r7, #0]
   113be:	2b0c      	cmp	r3, #12
   113c0:	d80d      	bhi.n	113de <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x3a>
   113c2:	23fc      	movs	r3, #252	; 0xfc
   113c4:	4a2b      	ldr	r2, [pc, #172]	; (11474 <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0xd0>)
   113c6:	492c      	ldr	r1, [pc, #176]	; (11478 <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0xd4>)
   113c8:	482c      	ldr	r0, [pc, #176]	; (1147c <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0xd8>)
   113ca:	f002 f82b 	bl	13424 <printf>
   113ce:	482c      	ldr	r0, [pc, #176]	; (11480 <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0xdc>)
   113d0:	f000 fe58 	bl	12084 <puts>
   113d4:	2100      	movs	r1, #0
   113d6:	2001      	movs	r0, #1
   113d8:	f7ff f950 	bl	1067c <sjsu::debug::PrintBacktrace(bool, void*)>
   113dc:	e7fe      	b.n	113dc <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x38>
                     "Frequency must be lower than 384 MHz"
                     "and greater than or equal to 12 MHz");
    bool calculating = true;
   113de:	2301      	movs	r3, #1
   113e0:	75fb      	strb	r3, [r7, #23]
    uint32_t multiplier_value;
    if ((desired_speed_in_mhz % static_cast<uint16_t>(input_frequency)) >= 1)
   113e2:	883b      	ldrh	r3, [r7, #0]
   113e4:	887a      	ldrh	r2, [r7, #2]
   113e6:	fbb3 f1f2 	udiv	r1, r3, r2
   113ea:	fb02 f201 	mul.w	r2, r2, r1
   113ee:	1a9b      	subs	r3, r3, r2
   113f0:	b29b      	uxth	r3, r3
   113f2:	2b00      	cmp	r3, #0
   113f4:	d007      	beq.n	11406 <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x62>
    {
      multiplier_value = static_cast<uint32_t>(
          (desired_speed_in_mhz / static_cast<uint16_t>(input_frequency)) + 1);
   113f6:	883a      	ldrh	r2, [r7, #0]
   113f8:	887b      	ldrh	r3, [r7, #2]
   113fa:	fbb2 f3f3 	udiv	r3, r2, r3
   113fe:	b29b      	uxth	r3, r3
   11400:	3301      	adds	r3, #1
      multiplier_value = static_cast<uint32_t>(
   11402:	613b      	str	r3, [r7, #16]
   11404:	e005      	b.n	11412 <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x6e>
    }
    else
    {
      multiplier_value = static_cast<uint32_t>(
          desired_speed_in_mhz / static_cast<uint16_t>(input_frequency));
   11406:	883a      	ldrh	r2, [r7, #0]
   11408:	887b      	ldrh	r3, [r7, #2]
   1140a:	fbb2 f3f3 	udiv	r3, r2, r3
   1140e:	b29b      	uxth	r3, r3
      multiplier_value = static_cast<uint32_t>(
   11410:	613b      	str	r3, [r7, #16]
    }
    uint16_t divider_value = 1;
   11412:	2301      	movs	r3, #1
   11414:	81fb      	strh	r3, [r7, #14]
    while (calculating)
   11416:	7dfb      	ldrb	r3, [r7, #23]
   11418:	2b00      	cmp	r3, #0
   1141a:	d026      	beq.n	1146a <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0xc6>
    {
      uint16_t current_controlled_oscillator_frequency;
      current_controlled_oscillator_frequency = static_cast<uint16_t>(
   1141c:	693b      	ldr	r3, [r7, #16]
   1141e:	b29b      	uxth	r3, r3
   11420:	887a      	ldrh	r2, [r7, #2]
   11422:	fb12 f303 	smulbb	r3, r2, r3
   11426:	b29b      	uxth	r3, r3
   11428:	89fa      	ldrh	r2, [r7, #14]
   1142a:	fb12 f303 	smulbb	r3, r2, r3
   1142e:	b29b      	uxth	r3, r3
   11430:	005b      	lsls	r3, r3, #1
   11432:	81bb      	strh	r3, [r7, #12]
          (static_cast<uint16_t>(input_frequency) * multiplier_value * 2) *
          divider_value);
      if (current_controlled_oscillator_frequency >= 156)
   11434:	89bb      	ldrh	r3, [r7, #12]
   11436:	2b9b      	cmp	r3, #155	; 0x9b
   11438:	d902      	bls.n	11440 <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x9c>
      {
        calculating = false;
   1143a:	2300      	movs	r3, #0
   1143c:	75fb      	strb	r3, [r7, #23]
   1143e:	e7ea      	b.n	11416 <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x72>
      }
      else
      {
        divider_value = static_cast<uint16_t>(divider_value * 2);
   11440:	89fb      	ldrh	r3, [r7, #14]
   11442:	005b      	lsls	r3, r3, #1
   11444:	81fb      	strh	r3, [r7, #14]
        SJ2_ASSERT_FATAL(divider_value < 8,
   11446:	89fb      	ldrh	r3, [r7, #14]
   11448:	2b07      	cmp	r3, #7
   1144a:	d9e4      	bls.n	11416 <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x72>
   1144c:	f44f 738c 	mov.w	r3, #280	; 0x118
   11450:	4a08      	ldr	r2, [pc, #32]	; (11474 <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0xd0>)
   11452:	490c      	ldr	r1, [pc, #48]	; (11484 <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0xe0>)
   11454:	480c      	ldr	r0, [pc, #48]	; (11488 <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0xe4>)
   11456:	f001 ffe5 	bl	13424 <printf>
   1145a:	4809      	ldr	r0, [pc, #36]	; (11480 <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0xdc>)
   1145c:	f000 fe12 	bl	12084 <puts>
   11460:	2100      	movs	r1, #0
   11462:	2001      	movs	r0, #1
   11464:	f7ff f90a 	bl	1067c <sjsu::debug::PrintBacktrace(bool, void*)>
   11468:	e7fe      	b.n	11468 <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0xc4>
                         "PLL divider value went out of bounds");
      }
    }

    return multiplier_value;
   1146a:	693b      	ldr	r3, [r7, #16]
  }
   1146c:	4618      	mov	r0, r3
   1146e:	3718      	adds	r7, #24
   11470:	46bd      	mov	sp, r7
   11472:	bd80      	pop	{r7, pc}
   11474:	00015878 	.word	0x00015878
   11478:	000155b0 	.word	0x000155b0
   1147c:	0001504c 	.word	0x0001504c
   11480:	00015034 	.word	0x00015034
   11484:	000155c8 	.word	0x000155c8
   11488:	0001513c 	.word	0x0001513c

0001148c <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const>:

  uint32_t SetMainPll(PllInput input_frequency,
   1148c:	b590      	push	{r4, r7, lr}
   1148e:	b08b      	sub	sp, #44	; 0x2c
   11490:	af00      	add	r7, sp, #0
   11492:	6078      	str	r0, [r7, #4]
   11494:	460b      	mov	r3, r1
   11496:	807b      	strh	r3, [r7, #2]
   11498:	4613      	mov	r3, r2
   1149a:	803b      	strh	r3, [r7, #0]
                      uint16_t desired_speed_in_mhz) const
  {
    uint16_t divider_value = 1;
   1149c:	2301      	movs	r3, #1
   1149e:	837b      	strh	r3, [r7, #26]
    uint64_t timeout_time  = Milliseconds() + kDefaultTimeout;
   114a0:	f7ff f94a 	bl	10738 <sjsu::Milliseconds()>
   114a4:	460a      	mov	r2, r1
   114a6:	4601      	mov	r1, r0
   114a8:	f511 737a 	adds.w	r3, r1, #1000	; 0x3e8
   114ac:	f142 0400 	adc.w	r4, r2, #0
   114b0:	e9c7 3404 	strd	r3, r4, [r7, #16]
    uint64_t current_time  = Milliseconds();
   114b4:	f7ff f940 	bl	10738 <sjsu::Milliseconds()>
   114b8:	e9c7 0108 	strd	r0, r1, [r7, #32]
    uint32_t multiplier_value =
        CalculatePll(input_frequency, desired_speed_in_mhz);
   114bc:	883a      	ldrh	r2, [r7, #0]
   114be:	887b      	ldrh	r3, [r7, #2]
   114c0:	4619      	mov	r1, r3
   114c2:	6878      	ldr	r0, [r7, #4]
   114c4:	f7ff ff6e 	bl	113a4 <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const>
   114c8:	60f8      	str	r0, [r7, #12]
    uint32_t actual_speed =
        static_cast<uint32_t>(input_frequency) * multiplier_value;
   114ca:	887a      	ldrh	r2, [r7, #2]
    uint32_t actual_speed =
   114cc:	68fb      	ldr	r3, [r7, #12]
   114ce:	fb02 f303 	mul.w	r3, r2, r3
   114d2:	61fb      	str	r3, [r7, #28]
    // TO DO: use registers to retreive values
    SelectOscillatorSource(OscillatorSource::kIrc);
   114d4:	2100      	movs	r1, #0
   114d6:	6878      	ldr	r0, [r7, #4]
   114d8:	f7ff fefa 	bl	112d0 <sjsu::lpc40xx::SystemController::SelectOscillatorSource(sjsu::lpc40xx::SystemController::OscillatorSource) const>
    SelectMainClockSource(MainClockSource::kBaseClock);
   114dc:	2100      	movs	r1, #0
   114de:	6878      	ldr	r0, [r7, #4]
   114e0:	f7ff ff12 	bl	11308 <sjsu::lpc40xx::SystemController::SelectMainClockSource(sjsu::lpc40xx::SystemController::MainClockSource) const>
    SelectUsbClockSource(UsbSource::kBaseClock);
   114e4:	2100      	movs	r1, #0
   114e6:	6878      	ldr	r0, [r7, #4]
   114e8:	f7ff ff28 	bl	1133c <sjsu::lpc40xx::SystemController::SelectUsbClockSource(sjsu::lpc40xx::SystemController::UsbSource) const>
    SelectSpifiClockSource(SpifiSource::kBaseClock);
   114ec:	2100      	movs	r1, #0
   114ee:	6878      	ldr	r0, [r7, #4]
   114f0:	f7ff ff3e 	bl	11370 <sjsu::lpc40xx::SystemController::SelectSpifiClockSource(sjsu::lpc40xx::SystemController::SpifiSource) const>
    // must subtract 1 from multiplier value as specified in datasheet
    system_controller->PLL0CFG =
        (system_controller->PLL0CFG & ~kClearPllMultiplier) |
   114f4:	4b39      	ldr	r3, [pc, #228]	; (115dc <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x150>)
   114f6:	681b      	ldr	r3, [r3, #0]
   114f8:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
   114fc:	f023 011f 	bic.w	r1, r3, #31
        (multiplier_value - 1);
   11500:	68fb      	ldr	r3, [r7, #12]
   11502:	1e5a      	subs	r2, r3, #1
    system_controller->PLL0CFG =
   11504:	4b35      	ldr	r3, [pc, #212]	; (115dc <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x150>)
   11506:	681b      	ldr	r3, [r3, #0]
        (system_controller->PLL0CFG & ~kClearPllMultiplier) |
   11508:	430a      	orrs	r2, r1
    system_controller->PLL0CFG =
   1150a:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    system_controller->PLL0CFG =
        (system_controller->PLL0CFG & ~kClearPllDivider) | (divider_value << 5);
   1150e:	4b33      	ldr	r3, [pc, #204]	; (115dc <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x150>)
   11510:	681b      	ldr	r3, [r3, #0]
   11512:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
   11516:	f023 0260 	bic.w	r2, r3, #96	; 0x60
   1151a:	8b7b      	ldrh	r3, [r7, #26]
   1151c:	015b      	lsls	r3, r3, #5
   1151e:	4619      	mov	r1, r3
    system_controller->PLL0CFG =
   11520:	4b2e      	ldr	r3, [pc, #184]	; (115dc <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x150>)
   11522:	681b      	ldr	r3, [r3, #0]
        (system_controller->PLL0CFG & ~kClearPllDivider) | (divider_value << 5);
   11524:	430a      	orrs	r2, r1
    system_controller->PLL0CFG =
   11526:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    system_controller->PLL0CON |= kEnablePll;
   1152a:	4b2c      	ldr	r3, [pc, #176]	; (115dc <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x150>)
   1152c:	681b      	ldr	r3, [r3, #0]
   1152e:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
   11532:	4b2a      	ldr	r3, [pc, #168]	; (115dc <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x150>)
   11534:	681b      	ldr	r3, [r3, #0]
   11536:	f042 0201 	orr.w	r2, r2, #1
   1153a:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    // nessecary feed sequence to ensure the changes are intentional
    system_controller->PLL0FEED = 0xAA;
   1153e:	4b27      	ldr	r3, [pc, #156]	; (115dc <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x150>)
   11540:	681b      	ldr	r3, [r3, #0]
   11542:	22aa      	movs	r2, #170	; 0xaa
   11544:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
    system_controller->PLL0FEED = 0x55;
   11548:	4b24      	ldr	r3, [pc, #144]	; (115dc <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x150>)
   1154a:	681b      	ldr	r3, [r3, #0]
   1154c:	2255      	movs	r2, #85	; 0x55
   1154e:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
    while (!(system_controller->PLL0STAT >> kPlock & 1) &&
   11552:	4b22      	ldr	r3, [pc, #136]	; (115dc <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x150>)
   11554:	681b      	ldr	r3, [r3, #0]
   11556:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   1155a:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   1155e:	2b00      	cmp	r3, #0
   11560:	d109      	bne.n	11576 <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0xea>
   11562:	e9d7 1208 	ldrd	r1, r2, [r7, #32]
   11566:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
   1156a:	42a2      	cmp	r2, r4
   1156c:	bf08      	it	eq
   1156e:	4299      	cmpeq	r1, r3
   11570:	d201      	bcs.n	11576 <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0xea>
   11572:	2301      	movs	r3, #1
   11574:	e000      	b.n	11578 <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0xec>
   11576:	2300      	movs	r3, #0
   11578:	2b00      	cmp	r3, #0
   1157a:	d004      	beq.n	11586 <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0xfa>
           (current_time < timeout_time))
    {
      current_time = Milliseconds();
   1157c:	f7ff f8dc 	bl	10738 <sjsu::Milliseconds()>
   11580:	e9c7 0108 	strd	r0, r1, [r7, #32]
    while (!(system_controller->PLL0STAT >> kPlock & 1) &&
   11584:	e7e5      	b.n	11552 <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0xc6>
    }
    if (!(system_controller->PLL0STAT >> kPlock & 1) &&
   11586:	4b15      	ldr	r3, [pc, #84]	; (115dc <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x150>)
   11588:	681b      	ldr	r3, [r3, #0]
   1158a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   1158e:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   11592:	2b00      	cmp	r3, #0
   11594:	d109      	bne.n	115aa <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x11e>
   11596:	e9d7 1208 	ldrd	r1, r2, [r7, #32]
   1159a:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
   1159e:	42a2      	cmp	r2, r4
   115a0:	bf08      	it	eq
   115a2:	4299      	cmpeq	r1, r3
   115a4:	d301      	bcc.n	115aa <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x11e>
   115a6:	2301      	movs	r3, #1
   115a8:	e000      	b.n	115ac <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x120>
   115aa:	2300      	movs	r3, #0
   115ac:	2b00      	cmp	r3, #0
   115ae:	d00e      	beq.n	115ce <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x142>
        (current_time >= timeout_time))
    {
      SJ2_ASSERT_FATAL(false,
   115b0:	f240 1341 	movw	r3, #321	; 0x141
   115b4:	4a0a      	ldr	r2, [pc, #40]	; (115e0 <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x154>)
   115b6:	490b      	ldr	r1, [pc, #44]	; (115e4 <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x158>)
   115b8:	480b      	ldr	r0, [pc, #44]	; (115e8 <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x15c>)
   115ba:	f001 ff33 	bl	13424 <printf>
   115be:	480b      	ldr	r0, [pc, #44]	; (115ec <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x160>)
   115c0:	f000 fd60 	bl	12084 <puts>
   115c4:	2100      	movs	r1, #0
   115c6:	2001      	movs	r0, #1
   115c8:	f7ff f858 	bl	1067c <sjsu::debug::PrintBacktrace(bool, void*)>
   115cc:	e7fe      	b.n	115cc <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const+0x140>
                       "PLL lock could not be established before timeout");
      actual_speed = kDefaultIRCFrequency;
    }
    return (actual_speed - desired_speed_in_mhz);
   115ce:	883b      	ldrh	r3, [r7, #0]
   115d0:	69fa      	ldr	r2, [r7, #28]
   115d2:	1ad3      	subs	r3, r2, r3
  }
   115d4:	4618      	mov	r0, r3
   115d6:	372c      	adds	r7, #44	; 0x2c
   115d8:	46bd      	mov	sp, r7
   115da:	bd90      	pop	{r4, r7, pc}
   115dc:	10000088 	.word	0x10000088
   115e0:	00015808 	.word	0x00015808
   115e4:	000155e0 	.word	0x000155e0
   115e8:	000151e4 	.word	0x000151e4
   115ec:	00015034 	.word	0x00015034

000115f0 <sjsu::lpc40xx::SystemController::SetCpuClockDivider(unsigned char) const>:
                       "PLL lock could not be established before timeout");
    }
    return (actual_speed - desired_speed_in_mhz);
  }

  void SetCpuClockDivider(uint8_t cpu_divider) const
   115f0:	b580      	push	{r7, lr}
   115f2:	b082      	sub	sp, #8
   115f4:	af00      	add	r7, sp, #0
   115f6:	6078      	str	r0, [r7, #4]
   115f8:	460b      	mov	r3, r1
   115fa:	70fb      	strb	r3, [r7, #3]
  {
    SJ2_ASSERT_FATAL(cpu_divider < 32, "Divider mustn't exceed 32");
   115fc:	78fb      	ldrb	r3, [r7, #3]
   115fe:	2b1f      	cmp	r3, #31
   11600:	d90e      	bls.n	11620 <sjsu::lpc40xx::SystemController::SetCpuClockDivider(unsigned char) const+0x30>
   11602:	f240 136d 	movw	r3, #365	; 0x16d
   11606:	4a0e      	ldr	r2, [pc, #56]	; (11640 <sjsu::lpc40xx::SystemController::SetCpuClockDivider(unsigned char) const+0x50>)
   11608:	490e      	ldr	r1, [pc, #56]	; (11644 <sjsu::lpc40xx::SystemController::SetCpuClockDivider(unsigned char) const+0x54>)
   1160a:	480f      	ldr	r0, [pc, #60]	; (11648 <sjsu::lpc40xx::SystemController::SetCpuClockDivider(unsigned char) const+0x58>)
   1160c:	f001 ff0a 	bl	13424 <printf>
   11610:	480e      	ldr	r0, [pc, #56]	; (1164c <sjsu::lpc40xx::SystemController::SetCpuClockDivider(unsigned char) const+0x5c>)
   11612:	f000 fd37 	bl	12084 <puts>
   11616:	2100      	movs	r1, #0
   11618:	2001      	movs	r0, #1
   1161a:	f7ff f82f 	bl	1067c <sjsu::debug::PrintBacktrace(bool, void*)>
   1161e:	e7fe      	b.n	1161e <sjsu::lpc40xx::SystemController::SetCpuClockDivider(unsigned char) const+0x2e>
    system_controller->CCLKSEL =
        (system_controller->CCLKSEL & ~kClearCpuDivider) | cpu_divider;
   11620:	4b0b      	ldr	r3, [pc, #44]	; (11650 <sjsu::lpc40xx::SystemController::SetCpuClockDivider(unsigned char) const+0x60>)
   11622:	681b      	ldr	r3, [r3, #0]
   11624:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
   11628:	f023 011f 	bic.w	r1, r3, #31
   1162c:	78fa      	ldrb	r2, [r7, #3]
    system_controller->CCLKSEL =
   1162e:	4b08      	ldr	r3, [pc, #32]	; (11650 <sjsu::lpc40xx::SystemController::SetCpuClockDivider(unsigned char) const+0x60>)
   11630:	681b      	ldr	r3, [r3, #0]
        (system_controller->CCLKSEL & ~kClearCpuDivider) | cpu_divider;
   11632:	430a      	orrs	r2, r1
    system_controller->CCLKSEL =
   11634:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
  }
   11638:	bf00      	nop
   1163a:	3708      	adds	r7, #8
   1163c:	46bd      	mov	sp, r7
   1163e:	bd80      	pop	{r7, pc}
   11640:	000158ec 	.word	0x000158ec
   11644:	000155f8 	.word	0x000155f8
   11648:	0001528c 	.word	0x0001528c
   1164c:	00015034 	.word	0x00015034
   11650:	10000088 	.word	0x10000088

00011654 <sjsu::lpc40xx::SystemController::SetEmcClockDivider(sjsu::lpc40xx::SystemController::EmcDivider) const>:

  void SetEmcClockDivider(EmcDivider emc_divider) const
   11654:	b480      	push	{r7}
   11656:	b083      	sub	sp, #12
   11658:	af00      	add	r7, sp, #0
   1165a:	6078      	str	r0, [r7, #4]
   1165c:	460b      	mov	r3, r1
   1165e:	70fb      	strb	r3, [r7, #3]
  {
    system_controller->EMCCLKSEL =
        (system_controller->EMCCLKSEL & ~kClearEmcDivider) |
   11660:	4b08      	ldr	r3, [pc, #32]	; (11684 <sjsu::lpc40xx::SystemController::SetEmcClockDivider(sjsu::lpc40xx::SystemController::EmcDivider) const+0x30>)
   11662:	681b      	ldr	r3, [r3, #0]
   11664:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
   11668:	f023 0101 	bic.w	r1, r3, #1
        static_cast<uint8_t>(emc_divider);
   1166c:	78fa      	ldrb	r2, [r7, #3]
    system_controller->EMCCLKSEL =
   1166e:	4b05      	ldr	r3, [pc, #20]	; (11684 <sjsu::lpc40xx::SystemController::SetEmcClockDivider(sjsu::lpc40xx::SystemController::EmcDivider) const+0x30>)
   11670:	681b      	ldr	r3, [r3, #0]
        (system_controller->EMCCLKSEL & ~kClearEmcDivider) |
   11672:	430a      	orrs	r2, r1
    system_controller->EMCCLKSEL =
   11674:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
  }
   11678:	bf00      	nop
   1167a:	370c      	adds	r7, #12
   1167c:	46bd      	mov	sp, r7
   1167e:	f85d 7b04 	ldr.w	r7, [sp], #4
   11682:	4770      	bx	lr
   11684:	10000088 	.word	0x10000088

00011688 <sjsu::lpc40xx::Timer::TimerHandler(sjsu::lpc40xx::Timer::ChannelPartial_t const&)>:
      .channel = kTimerPartial3,
      .isr     = TimerHandler<kTimerPartial3>,
    };
  };

  static void TimerHandler(const ChannelPartial_t & channel)
   11688:	b580      	push	{r7, lr}
   1168a:	b082      	sub	sp, #8
   1168c:	af00      	add	r7, sp, #0
   1168e:	6078      	str	r0, [r7, #4]
  {
    if (*channel.user_callback != nullptr)
   11690:	687b      	ldr	r3, [r7, #4]
   11692:	68db      	ldr	r3, [r3, #12]
   11694:	681b      	ldr	r3, [r3, #0]
   11696:	2b00      	cmp	r3, #0
   11698:	d003      	beq.n	116a2 <sjsu::lpc40xx::Timer::TimerHandler(sjsu::lpc40xx::Timer::ChannelPartial_t const&)+0x1a>
    {
      (*channel.user_callback)();
   1169a:	687b      	ldr	r3, [r7, #4]
   1169c:	68db      	ldr	r3, [r3, #12]
   1169e:	681b      	ldr	r3, [r3, #0]
   116a0:	4798      	blx	r3
    }
    channel.timer_register->IR |=
   116a2:	687b      	ldr	r3, [r7, #4]
   116a4:	681b      	ldr	r3, [r3, #0]
   116a6:	681a      	ldr	r2, [r3, #0]
   116a8:	687b      	ldr	r3, [r7, #4]
   116aa:	681b      	ldr	r3, [r3, #0]
   116ac:	f042 020f 	orr.w	r2, r2, #15
   116b0:	601a      	str	r2, [r3, #0]
        (1 << kRegMR0) | (1 << kRegMR1) | (1 << kRegMR2) | (1 << kRegMR3);
  }
   116b2:	bf00      	nop
   116b4:	3708      	adds	r7, #8
   116b6:	46bd      	mov	sp, r7
   116b8:	bd80      	pop	{r7, pc}
   116ba:	Address 0x00000000000116ba is out of bounds.


000116bc <sjsu::Timer::Timer()>:
#include "L0_Platform/interrupt.hpp"
#include "utility/status.hpp"

namespace sjsu
{
class Timer
   116bc:	b480      	push	{r7}
   116be:	b083      	sub	sp, #12
   116c0:	af00      	add	r7, sp, #0
   116c2:	6078      	str	r0, [r7, #4]
   116c4:	4a04      	ldr	r2, [pc, #16]	; (116d8 <sjsu::Timer::Timer()+0x1c>)
   116c6:	687b      	ldr	r3, [r7, #4]
   116c8:	601a      	str	r2, [r3, #0]
   116ca:	687b      	ldr	r3, [r7, #4]
   116cc:	4618      	mov	r0, r3
   116ce:	370c      	adds	r7, #12
   116d0:	46bd      	mov	sp, r7
   116d2:	f85d 7b04 	ldr.w	r7, [sp], #4
   116d6:	4770      	bx	lr
   116d8:	00015754 	.word	0x00015754

000116dc <sjsu::SystemController::SystemController()>:
#include <cstddef>
#include <cstdint>

namespace sjsu
{
class SystemController
   116dc:	b480      	push	{r7}
   116de:	b083      	sub	sp, #12
   116e0:	af00      	add	r7, sp, #0
   116e2:	6078      	str	r0, [r7, #4]
   116e4:	4a04      	ldr	r2, [pc, #16]	; (116f8 <sjsu::SystemController::SystemController()+0x1c>)
   116e6:	687b      	ldr	r3, [r7, #4]
   116e8:	601a      	str	r2, [r3, #0]
   116ea:	687b      	ldr	r3, [r7, #4]
   116ec:	4618      	mov	r0, r3
   116ee:	370c      	adds	r7, #12
   116f0:	46bd      	mov	sp, r7
   116f2:	f85d 7b04 	ldr.w	r7, [sp], #4
   116f6:	4770      	bx	lr
   116f8:	00015790 	.word	0x00015790

000116fc <sjsu::lpc40xx::SystemController::SystemController()>:
class SystemController : public sjsu::SystemController
   116fc:	b580      	push	{r7, lr}
   116fe:	b082      	sub	sp, #8
   11700:	af00      	add	r7, sp, #0
   11702:	6078      	str	r0, [r7, #4]
   11704:	687b      	ldr	r3, [r7, #4]
   11706:	4618      	mov	r0, r3
   11708:	f7ff ffe8 	bl	116dc <sjsu::SystemController::SystemController()>
   1170c:	4a03      	ldr	r2, [pc, #12]	; (1171c <sjsu::lpc40xx::SystemController::SystemController()+0x20>)
   1170e:	687b      	ldr	r3, [r7, #4]
   11710:	601a      	str	r2, [r3, #0]
   11712:	687b      	ldr	r3, [r7, #4]
   11714:	4618      	mov	r0, r3
   11716:	3708      	adds	r7, #8
   11718:	46bd      	mov	sp, r7
   1171a:	bd80      	pop	{r7, pc}
   1171c:	00015768 	.word	0x00015768

00011720 <sjsu::lpc40xx::Timer::Timer(sjsu::lpc40xx::Timer::Channel_t)>:

  explicit constexpr Timer(Channel_t timer) : timer_(timer) {}
   11720:	b580      	push	{r7, lr}
   11722:	b084      	sub	sp, #16
   11724:	af00      	add	r7, sp, #0
   11726:	60f8      	str	r0, [r7, #12]
   11728:	1d3b      	adds	r3, r7, #4
   1172a:	e883 0006 	stmia.w	r3, {r1, r2}
   1172e:	68fb      	ldr	r3, [r7, #12]
   11730:	4618      	mov	r0, r3
   11732:	f7ff ffc3 	bl	116bc <sjsu::Timer::Timer()>
   11736:	68fb      	ldr	r3, [r7, #12]
   11738:	3304      	adds	r3, #4
   1173a:	4618      	mov	r0, r3
   1173c:	f7ff ffde 	bl	116fc <sjsu::lpc40xx::SystemController::SystemController()>
   11740:	4a06      	ldr	r2, [pc, #24]	; (1175c <sjsu::lpc40xx::Timer::Timer(sjsu::lpc40xx::Timer::Channel_t)+0x3c>)
   11742:	68fb      	ldr	r3, [r7, #12]
   11744:	601a      	str	r2, [r3, #0]
   11746:	4a06      	ldr	r2, [pc, #24]	; (11760 <sjsu::lpc40xx::Timer::Timer(sjsu::lpc40xx::Timer::Channel_t)+0x40>)
   11748:	68fb      	ldr	r3, [r7, #12]
   1174a:	605a      	str	r2, [r3, #4]
   1174c:	68fb      	ldr	r3, [r7, #12]
   1174e:	1d3a      	adds	r2, r7, #4
   11750:	609a      	str	r2, [r3, #8]
   11752:	68fb      	ldr	r3, [r7, #12]
   11754:	4618      	mov	r0, r3
   11756:	3710      	adds	r7, #16
   11758:	46bd      	mov	sp, r7
   1175a:	bd80      	pop	{r7, pc}
   1175c:	00015718 	.word	0x00015718
   11760:	0001572c 	.word	0x0001572c

00011764 <sjsu::lpc40xx::Timer::Initialize(unsigned long, void (*)(), long) const>:
  ///        register will be 10 ms.
  /// @param isr - an ISR that will fire when the condition set by SetTimer
  ///        method is achieved.
  /// @param priority - sets the Timer interrupt's priority level, defaults to
  ///        -1 which uses the platforms default priority.
  Status Initialize(uint32_t frequency, IsrPointer isr = nullptr,
   11764:	b580      	push	{r7, lr}
   11766:	b086      	sub	sp, #24
   11768:	af00      	add	r7, sp, #0
   1176a:	60f8      	str	r0, [r7, #12]
   1176c:	60b9      	str	r1, [r7, #8]
   1176e:	607a      	str	r2, [r7, #4]
   11770:	603b      	str	r3, [r7, #0]
                    int32_t priority = -1) const override
  {
    constexpr uint32_t kClear = std::numeric_limits<uint32_t>::max();
   11772:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   11776:	617b      	str	r3, [r7, #20]
    PowerUpPeripheral(timer_.channel.power_id);
   11778:	68fb      	ldr	r3, [r7, #12]
   1177a:	1d1a      	adds	r2, r3, #4
   1177c:	68fb      	ldr	r3, [r7, #12]
   1177e:	689b      	ldr	r3, [r3, #8]
   11780:	681b      	ldr	r3, [r3, #0]
   11782:	3304      	adds	r3, #4
   11784:	4619      	mov	r1, r3
   11786:	4610      	mov	r0, r2
   11788:	f7ff fd66 	bl	11258 <sjsu::lpc40xx::SystemController::PowerUpPeripheral(sjsu::SystemController::PeripheralID const&) const>
    SJ2_ASSERT_FATAL(
   1178c:	68bb      	ldr	r3, [r7, #8]
   1178e:	2b00      	cmp	r3, #0
   11790:	d10d      	bne.n	117ae <sjsu::lpc40xx::Timer::Initialize(unsigned long, void (*)(), long) const+0x4a>
   11792:	2387      	movs	r3, #135	; 0x87
   11794:	4a29      	ldr	r2, [pc, #164]	; (1183c <sjsu::lpc40xx::Timer::Initialize(unsigned long, void (*)(), long) const+0xd8>)
   11796:	492a      	ldr	r1, [pc, #168]	; (11840 <sjsu::lpc40xx::Timer::Initialize(unsigned long, void (*)(), long) const+0xdc>)
   11798:	482a      	ldr	r0, [pc, #168]	; (11844 <sjsu::lpc40xx::Timer::Initialize(unsigned long, void (*)(), long) const+0xe0>)
   1179a:	f001 fe43 	bl	13424 <printf>
   1179e:	482a      	ldr	r0, [pc, #168]	; (11848 <sjsu::lpc40xx::Timer::Initialize(unsigned long, void (*)(), long) const+0xe4>)
   117a0:	f000 fc70 	bl	12084 <puts>
   117a4:	2100      	movs	r1, #0
   117a6:	2001      	movs	r0, #1
   117a8:	f7fe ff68 	bl	1067c <sjsu::debug::PrintBacktrace(bool, void*)>
   117ac:	e7fe      	b.n	117ac <sjsu::lpc40xx::Timer::Initialize(unsigned long, void (*)(), long) const+0x48>
        frequency != 0,
        "Cannot have zero ticks per microsecond, please choose 1 or more.");
    // Set Prescale register for Prescale Counter to milliseconds
    uint32_t prescaler = GetPeripheralFrequency() / frequency;
   117ae:	68fb      	ldr	r3, [r7, #12]
   117b0:	3304      	adds	r3, #4
   117b2:	4618      	mov	r0, r3
   117b4:	f7ff fd18 	bl	111e8 <sjsu::lpc40xx::SystemController::GetPeripheralFrequency() const>
   117b8:	4602      	mov	r2, r0
   117ba:	68bb      	ldr	r3, [r7, #8]
   117bc:	fbb2 f3f3 	udiv	r3, r2, r3
   117c0:	613b      	str	r3, [r7, #16]
    timer_.channel.timer_register->PR &= ~(kClear << 1);
   117c2:	68fb      	ldr	r3, [r7, #12]
   117c4:	689b      	ldr	r3, [r3, #8]
   117c6:	681b      	ldr	r3, [r3, #0]
   117c8:	681b      	ldr	r3, [r3, #0]
   117ca:	68da      	ldr	r2, [r3, #12]
   117cc:	68fb      	ldr	r3, [r7, #12]
   117ce:	689b      	ldr	r3, [r3, #8]
   117d0:	681b      	ldr	r3, [r3, #0]
   117d2:	681b      	ldr	r3, [r3, #0]
   117d4:	f002 0201 	and.w	r2, r2, #1
   117d8:	60da      	str	r2, [r3, #12]
    timer_.channel.timer_register->PR |= (prescaler << 1);
   117da:	68fb      	ldr	r3, [r7, #12]
   117dc:	689b      	ldr	r3, [r3, #8]
   117de:	681b      	ldr	r3, [r3, #0]
   117e0:	681b      	ldr	r3, [r3, #0]
   117e2:	68d9      	ldr	r1, [r3, #12]
   117e4:	693b      	ldr	r3, [r7, #16]
   117e6:	005a      	lsls	r2, r3, #1
   117e8:	68fb      	ldr	r3, [r7, #12]
   117ea:	689b      	ldr	r3, [r3, #8]
   117ec:	681b      	ldr	r3, [r3, #0]
   117ee:	681b      	ldr	r3, [r3, #0]
   117f0:	430a      	orrs	r2, r1
   117f2:	60da      	str	r2, [r3, #12]
    timer_.channel.timer_register->TCR |= (1 << 0);
   117f4:	68fb      	ldr	r3, [r7, #12]
   117f6:	689b      	ldr	r3, [r3, #8]
   117f8:	681b      	ldr	r3, [r3, #0]
   117fa:	681b      	ldr	r3, [r3, #0]
   117fc:	685a      	ldr	r2, [r3, #4]
   117fe:	68fb      	ldr	r3, [r7, #12]
   11800:	689b      	ldr	r3, [r3, #8]
   11802:	681b      	ldr	r3, [r3, #0]
   11804:	681b      	ldr	r3, [r3, #0]
   11806:	f042 0201 	orr.w	r2, r2, #1
   1180a:	605a      	str	r2, [r3, #4]
    *timer_.channel.user_callback = isr;
   1180c:	68fb      	ldr	r3, [r7, #12]
   1180e:	689b      	ldr	r3, [r3, #8]
   11810:	681b      	ldr	r3, [r3, #0]
   11812:	68db      	ldr	r3, [r3, #12]
   11814:	687a      	ldr	r2, [r7, #4]
   11816:	601a      	str	r2, [r3, #0]
    RegisterIsr(timer_.channel.irq, timer_.isr, true, priority);
   11818:	68fb      	ldr	r3, [r7, #12]
   1181a:	689b      	ldr	r3, [r3, #8]
   1181c:	681b      	ldr	r3, [r3, #0]
   1181e:	f993 0008 	ldrsb.w	r0, [r3, #8]
   11822:	68fb      	ldr	r3, [r7, #12]
   11824:	689b      	ldr	r3, [r3, #8]
   11826:	6859      	ldr	r1, [r3, #4]
   11828:	683b      	ldr	r3, [r7, #0]
   1182a:	2201      	movs	r2, #1
   1182c:	f000 fb82 	bl	11f34 <RegisterIsr(IRQn, void (*)(), bool, long)>

    return Status::kSuccess;
   11830:	2300      	movs	r3, #0
  }
   11832:	4618      	mov	r0, r3
   11834:	3718      	adds	r7, #24
   11836:	46bd      	mov	sp, r7
   11838:	bd80      	pop	{r7, pc}
   1183a:	bf00      	nop
   1183c:	00015934 	.word	0x00015934
   11840:	00015628 	.word	0x00015628
   11844:	00015328 	.word	0x00015328
   11848:	00015034 	.word	0x00015034

0001184c <sjsu::lpc40xx::Timer::SetTimer(unsigned long, sjsu::Timer::TimerIsrCondition, unsigned char) const>:
  /// @param ticks - the count of the timer register (TC) to have an ISR fire
  /// @param condition - the condition for which a timer interrupt will occur
  /// @param match_register - which match register (from 0 to 3) should be used
  ///        for holding the ticks for the condition. Only the two least
  ///        significant bits are used for the LPC40xx.
  void SetTimer(uint32_t ticks, TimerIsrCondition condition,
   1184c:	b580      	push	{r7, lr}
   1184e:	b088      	sub	sp, #32
   11850:	af02      	add	r7, sp, #8
   11852:	60f8      	str	r0, [r7, #12]
   11854:	60b9      	str	r1, [r7, #8]
   11856:	4611      	mov	r1, r2
   11858:	461a      	mov	r2, r3
   1185a:	460b      	mov	r3, r1
   1185c:	71fb      	strb	r3, [r7, #7]
   1185e:	4613      	mov	r3, r2
   11860:	71bb      	strb	r3, [r7, #6]
                uint8_t match_register = 0) const override
  {
    SJ2_ASSERT_FATAL(match_register > 3,
   11862:	79bb      	ldrb	r3, [r7, #6]
   11864:	2b03      	cmp	r3, #3
   11866:	d80f      	bhi.n	11888 <sjsu::lpc40xx::Timer::SetTimer(unsigned long, sjsu::Timer::TimerIsrCondition, unsigned char) const+0x3c>
   11868:	79bb      	ldrb	r3, [r7, #6]
   1186a:	9300      	str	r3, [sp, #0]
   1186c:	23a2      	movs	r3, #162	; 0xa2
   1186e:	4a20      	ldr	r2, [pc, #128]	; (118f0 <sjsu::lpc40xx::Timer::SetTimer(unsigned long, sjsu::Timer::TimerIsrCondition, unsigned char) const+0xa4>)
   11870:	4920      	ldr	r1, [pc, #128]	; (118f4 <sjsu::lpc40xx::Timer::SetTimer(unsigned long, sjsu::Timer::TimerIsrCondition, unsigned char) const+0xa8>)
   11872:	4821      	ldr	r0, [pc, #132]	; (118f8 <sjsu::lpc40xx::Timer::SetTimer(unsigned long, sjsu::Timer::TimerIsrCondition, unsigned char) const+0xac>)
   11874:	f001 fdd6 	bl	13424 <printf>
   11878:	4820      	ldr	r0, [pc, #128]	; (118fc <sjsu::lpc40xx::Timer::SetTimer(unsigned long, sjsu::Timer::TimerIsrCondition, unsigned char) const+0xb0>)
   1187a:	f000 fc03 	bl	12084 <puts>
   1187e:	2100      	movs	r1, #0
   11880:	2001      	movs	r0, #1
   11882:	f7fe fefb 	bl	1067c <sjsu::debug::PrintBacktrace(bool, void*)>
   11886:	e7fe      	b.n	11886 <sjsu::lpc40xx::Timer::SetTimer(unsigned long, sjsu::Timer::TimerIsrCondition, unsigned char) const+0x3a>
                     "to set match register %d was attempted.",
                     match_register);

    static constexpr uint8_t kClearMode = 0b0111;

    timer_.channel.timer_register->MCR &= ~(kClearMode << match_register);
   11888:	68fb      	ldr	r3, [r7, #12]
   1188a:	689b      	ldr	r3, [r3, #8]
   1188c:	681b      	ldr	r3, [r3, #0]
   1188e:	681b      	ldr	r3, [r3, #0]
   11890:	695a      	ldr	r2, [r3, #20]
   11892:	79bb      	ldrb	r3, [r7, #6]
   11894:	2107      	movs	r1, #7
   11896:	fa01 f303 	lsl.w	r3, r1, r3
   1189a:	43db      	mvns	r3, r3
   1189c:	4619      	mov	r1, r3
   1189e:	68fb      	ldr	r3, [r7, #12]
   118a0:	689b      	ldr	r3, [r3, #8]
   118a2:	681b      	ldr	r3, [r3, #0]
   118a4:	681b      	ldr	r3, [r3, #0]
   118a6:	400a      	ands	r2, r1
   118a8:	615a      	str	r2, [r3, #20]
    timer_.channel.timer_register->MCR |= condition << match_register;
   118aa:	68fb      	ldr	r3, [r7, #12]
   118ac:	689b      	ldr	r3, [r3, #8]
   118ae:	681b      	ldr	r3, [r3, #0]
   118b0:	681b      	ldr	r3, [r3, #0]
   118b2:	695a      	ldr	r2, [r3, #20]
   118b4:	79f9      	ldrb	r1, [r7, #7]
   118b6:	79bb      	ldrb	r3, [r7, #6]
   118b8:	fa01 f303 	lsl.w	r3, r1, r3
   118bc:	4619      	mov	r1, r3
   118be:	68fb      	ldr	r3, [r7, #12]
   118c0:	689b      	ldr	r3, [r3, #8]
   118c2:	681b      	ldr	r3, [r3, #0]
   118c4:	681b      	ldr	r3, [r3, #0]
   118c6:	430a      	orrs	r2, r1
   118c8:	615a      	str	r2, [r3, #20]
    // MR0, MR1, MR2, and MR3 are contiguous, so we can point to the first
    // match register and index from there to get the other match registers.
    volatile uint32_t * match_register_ptr =
        &timer_.channel.timer_register->MR0;
   118ca:	68fb      	ldr	r3, [r7, #12]
   118cc:	689b      	ldr	r3, [r3, #8]
   118ce:	681b      	ldr	r3, [r3, #0]
   118d0:	681b      	ldr	r3, [r3, #0]
    volatile uint32_t * match_register_ptr =
   118d2:	3318      	adds	r3, #24
   118d4:	617b      	str	r3, [r7, #20]

    match_register_ptr[match_register & 0b11] = ticks / 2;
   118d6:	79bb      	ldrb	r3, [r7, #6]
   118d8:	f003 0303 	and.w	r3, r3, #3
   118dc:	009b      	lsls	r3, r3, #2
   118de:	697a      	ldr	r2, [r7, #20]
   118e0:	4413      	add	r3, r2
   118e2:	68ba      	ldr	r2, [r7, #8]
   118e4:	0852      	lsrs	r2, r2, #1
   118e6:	601a      	str	r2, [r3, #0]
  }
   118e8:	bf00      	nop
   118ea:	3718      	adds	r7, #24
   118ec:	46bd      	mov	sp, r7
   118ee:	bd80      	pop	{r7, pc}
   118f0:	00015990 	.word	0x00015990
   118f4:	00015634 	.word	0x00015634
   118f8:	000153e8 	.word	0x000153e8
   118fc:	00015034 	.word	0x00015034

00011900 <sjsu::lpc40xx::Timer::GetTimer() const>:

  uint32_t GetTimer() const override
   11900:	b480      	push	{r7}
   11902:	b083      	sub	sp, #12
   11904:	af00      	add	r7, sp, #0
   11906:	6078      	str	r0, [r7, #4]
  {
    return timer_.channel.timer_register->TC;
   11908:	687b      	ldr	r3, [r7, #4]
   1190a:	689b      	ldr	r3, [r3, #8]
   1190c:	681b      	ldr	r3, [r3, #0]
   1190e:	681b      	ldr	r3, [r3, #0]
   11910:	689b      	ldr	r3, [r3, #8]
  }
   11912:	4618      	mov	r0, r3
   11914:	370c      	adds	r7, #12
   11916:	46bd      	mov	sp, r7
   11918:	f85d 7b04 	ldr.w	r7, [sp], #4
   1191c:	4770      	bx	lr
   1191e:	Address 0x000000000001191e is out of bounds.


00011920 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const>:

  explicit constexpr Uart(const Port_t & port) : port_(port) {}

  /// For LPC40xx only supports the following baud rates:
  ///   4800, 9600, 19200, 38400, 57600, 115200, 230400, 460800, 921600
  bool SetBaudRate(uint32_t baud_rate) const override
   11920:	b480      	push	{r7}
   11922:	b087      	sub	sp, #28
   11924:	af00      	add	r7, sp, #0
   11926:	6078      	str	r0, [r7, #4]
   11928:	6039      	str	r1, [r7, #0]
  {
    uart::UartCalibration_t calibration;
   1192a:	2300      	movs	r3, #0
   1192c:	60bb      	str	r3, [r7, #8]
   1192e:	2300      	movs	r3, #0
   11930:	60fb      	str	r3, [r7, #12]
   11932:	2301      	movs	r3, #1
   11934:	613b      	str	r3, [r7, #16]
    switch (baud_rate)
   11936:	683b      	ldr	r3, [r7, #0]
   11938:	f5b3 4f61 	cmp.w	r3, #57600	; 0xe100
   1193c:	d043      	beq.n	119c6 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0xa6>
   1193e:	f5b3 4f61 	cmp.w	r3, #57600	; 0xe100
   11942:	d810      	bhi.n	11966 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0x46>
   11944:	f5b3 5f16 	cmp.w	r3, #9600	; 0x2580
   11948:	d025      	beq.n	11996 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0x76>
   1194a:	f5b3 5f16 	cmp.w	r3, #9600	; 0x2580
   1194e:	d803      	bhi.n	11958 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0x38>
   11950:	f5b3 5f96 	cmp.w	r3, #4800	; 0x12c0
   11954:	d018      	beq.n	11988 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0x68>
   11956:	e05e      	b.n	11a16 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0xf6>
   11958:	f5b3 4f96 	cmp.w	r3, #19200	; 0x4b00
   1195c:	d023      	beq.n	119a6 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0x86>
   1195e:	f5b3 4f16 	cmp.w	r3, #38400	; 0x9600
   11962:	d028      	beq.n	119b6 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0x96>
   11964:	e057      	b.n	11a16 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0xf6>
   11966:	f5b3 3f61 	cmp.w	r3, #230400	; 0x38400
   1196a:	d03c      	beq.n	119e6 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0xc6>
   1196c:	f5b3 3f61 	cmp.w	r3, #230400	; 0x38400
   11970:	d803      	bhi.n	1197a <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0x5a>
   11972:	f5b3 3fe1 	cmp.w	r3, #115200	; 0x1c200
   11976:	d02e      	beq.n	119d6 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0xb6>
   11978:	e04d      	b.n	11a16 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0xf6>
   1197a:	f5b3 2fe1 	cmp.w	r3, #460800	; 0x70800
   1197e:	d03a      	beq.n	119f6 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0xd6>
   11980:	f5b3 2f61 	cmp.w	r3, #921600	; 0xe1000
   11984:	d03f      	beq.n	11a06 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0xe6>
   11986:	e046      	b.n	11a16 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0xf6>
    {
      case 4800: calibration = kBaudRateLUT[0]; break;
   11988:	4a3d      	ldr	r2, [pc, #244]	; (11a80 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0x160>)
   1198a:	f107 0308 	add.w	r3, r7, #8
   1198e:	ca07      	ldmia	r2, {r0, r1, r2}
   11990:	e883 0007 	stmia.w	r3, {r0, r1, r2}
   11994:	e041      	b.n	11a1a <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0xfa>
      case 9600: calibration = kBaudRateLUT[1]; break;
   11996:	4a3a      	ldr	r2, [pc, #232]	; (11a80 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0x160>)
   11998:	f107 0308 	add.w	r3, r7, #8
   1199c:	320c      	adds	r2, #12
   1199e:	ca07      	ldmia	r2, {r0, r1, r2}
   119a0:	e883 0007 	stmia.w	r3, {r0, r1, r2}
   119a4:	e039      	b.n	11a1a <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0xfa>
      case 19200: calibration = kBaudRateLUT[2]; break;
   119a6:	4a36      	ldr	r2, [pc, #216]	; (11a80 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0x160>)
   119a8:	f107 0308 	add.w	r3, r7, #8
   119ac:	3218      	adds	r2, #24
   119ae:	ca07      	ldmia	r2, {r0, r1, r2}
   119b0:	e883 0007 	stmia.w	r3, {r0, r1, r2}
   119b4:	e031      	b.n	11a1a <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0xfa>
      case 38400: calibration = kBaudRateLUT[3]; break;
   119b6:	4a32      	ldr	r2, [pc, #200]	; (11a80 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0x160>)
   119b8:	f107 0308 	add.w	r3, r7, #8
   119bc:	3224      	adds	r2, #36	; 0x24
   119be:	ca07      	ldmia	r2, {r0, r1, r2}
   119c0:	e883 0007 	stmia.w	r3, {r0, r1, r2}
   119c4:	e029      	b.n	11a1a <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0xfa>
      case 57600: calibration = kBaudRateLUT[4]; break;
   119c6:	4a2e      	ldr	r2, [pc, #184]	; (11a80 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0x160>)
   119c8:	f107 0308 	add.w	r3, r7, #8
   119cc:	3230      	adds	r2, #48	; 0x30
   119ce:	ca07      	ldmia	r2, {r0, r1, r2}
   119d0:	e883 0007 	stmia.w	r3, {r0, r1, r2}
   119d4:	e021      	b.n	11a1a <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0xfa>
      case 115200: calibration = kBaudRateLUT[5]; break;
   119d6:	4a2a      	ldr	r2, [pc, #168]	; (11a80 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0x160>)
   119d8:	f107 0308 	add.w	r3, r7, #8
   119dc:	323c      	adds	r2, #60	; 0x3c
   119de:	ca07      	ldmia	r2, {r0, r1, r2}
   119e0:	e883 0007 	stmia.w	r3, {r0, r1, r2}
   119e4:	e019      	b.n	11a1a <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0xfa>
      case 230400: calibration = kBaudRateLUT[6]; break;
   119e6:	4a26      	ldr	r2, [pc, #152]	; (11a80 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0x160>)
   119e8:	f107 0308 	add.w	r3, r7, #8
   119ec:	3248      	adds	r2, #72	; 0x48
   119ee:	ca07      	ldmia	r2, {r0, r1, r2}
   119f0:	e883 0007 	stmia.w	r3, {r0, r1, r2}
   119f4:	e011      	b.n	11a1a <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0xfa>
      case 460800: calibration = kBaudRateLUT[7]; break;
   119f6:	4a22      	ldr	r2, [pc, #136]	; (11a80 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0x160>)
   119f8:	f107 0308 	add.w	r3, r7, #8
   119fc:	3254      	adds	r2, #84	; 0x54
   119fe:	ca07      	ldmia	r2, {r0, r1, r2}
   11a00:	e883 0007 	stmia.w	r3, {r0, r1, r2}
   11a04:	e009      	b.n	11a1a <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0xfa>
      case 921600: calibration = kBaudRateLUT[8]; break;
   11a06:	4a1e      	ldr	r2, [pc, #120]	; (11a80 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0x160>)
   11a08:	f107 0308 	add.w	r3, r7, #8
   11a0c:	3260      	adds	r2, #96	; 0x60
   11a0e:	ca07      	ldmia	r2, {r0, r1, r2}
   11a10:	e883 0007 	stmia.w	r3, {r0, r1, r2}
   11a14:	e001      	b.n	11a1a <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0xfa>
      default: return false;
   11a16:	2300      	movs	r3, #0
   11a18:	e02c      	b.n	11a74 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const+0x154>
    }
    constexpr uint8_t kDlabBit = (1 << 7);
   11a1a:	2380      	movs	r3, #128	; 0x80
   11a1c:	75fb      	strb	r3, [r7, #23]

    uint8_t dlm = static_cast<uint8_t>((calibration.divide_latch >> 8) & 0xFF);
   11a1e:	68bb      	ldr	r3, [r7, #8]
   11a20:	0a1b      	lsrs	r3, r3, #8
   11a22:	75bb      	strb	r3, [r7, #22]
    uint8_t dll = static_cast<uint8_t>(calibration.divide_latch & 0xFF);
   11a24:	68bb      	ldr	r3, [r7, #8]
   11a26:	757b      	strb	r3, [r7, #21]
    uint8_t fdr = static_cast<uint8_t>((calibration.multiply & 0xF) << 4 |
   11a28:	693b      	ldr	r3, [r7, #16]
   11a2a:	b2db      	uxtb	r3, r3
   11a2c:	011b      	lsls	r3, r3, #4
   11a2e:	b2da      	uxtb	r2, r3
                                       (calibration.divide_add & 0xF));
   11a30:	68fb      	ldr	r3, [r7, #12]
   11a32:	b2db      	uxtb	r3, r3
   11a34:	f003 030f 	and.w	r3, r3, #15
   11a38:	b2db      	uxtb	r3, r3
    uint8_t fdr = static_cast<uint8_t>((calibration.multiply & 0xF) << 4 |
   11a3a:	4313      	orrs	r3, r2
   11a3c:	753b      	strb	r3, [r7, #20]

    port_.registers->LCR = kDlabBit;
   11a3e:	687b      	ldr	r3, [r7, #4]
   11a40:	689b      	ldr	r3, [r3, #8]
   11a42:	681b      	ldr	r3, [r3, #0]
   11a44:	2280      	movs	r2, #128	; 0x80
   11a46:	731a      	strb	r2, [r3, #12]
    port_.registers->DLM = dlm;
   11a48:	687b      	ldr	r3, [r7, #4]
   11a4a:	689b      	ldr	r3, [r3, #8]
   11a4c:	681b      	ldr	r3, [r3, #0]
   11a4e:	7dba      	ldrb	r2, [r7, #22]
   11a50:	711a      	strb	r2, [r3, #4]
    port_.registers->DLL = dll;
   11a52:	687b      	ldr	r3, [r7, #4]
   11a54:	689b      	ldr	r3, [r3, #8]
   11a56:	681b      	ldr	r3, [r3, #0]
   11a58:	7d7a      	ldrb	r2, [r7, #21]
   11a5a:	701a      	strb	r2, [r3, #0]
    port_.registers->FDR = fdr;
   11a5c:	687b      	ldr	r3, [r7, #4]
   11a5e:	689b      	ldr	r3, [r3, #8]
   11a60:	681b      	ldr	r3, [r3, #0]
   11a62:	7d3a      	ldrb	r2, [r7, #20]
   11a64:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
    port_.registers->LCR = kStandardUart;
   11a68:	687b      	ldr	r3, [r7, #4]
   11a6a:	689b      	ldr	r3, [r3, #8]
   11a6c:	681b      	ldr	r3, [r3, #0]
   11a6e:	2203      	movs	r2, #3
   11a70:	731a      	strb	r2, [r3, #12]
    return true;
   11a72:	2301      	movs	r3, #1
  }
   11a74:	4618      	mov	r0, r3
   11a76:	371c      	adds	r7, #28
   11a78:	46bd      	mov	sp, r7
   11a7a:	f85d 7b04 	ldr.w	r7, [sp], #4
   11a7e:	4770      	bx	lr
   11a80:	00015640 	.word	0x00015640

00011a84 <sjsu::lpc40xx::Uart::Initialize(unsigned long) const>:
    port_.registers->DLL = dll;
    port_.registers->FDR = fdr;
    port_.registers->LCR = kStandardUart;
  }

  Status Initialize(uint32_t baud_rate) const override
   11a84:	b580      	push	{r7, lr}
   11a86:	b084      	sub	sp, #16
   11a88:	af00      	add	r7, sp, #0
   11a8a:	6078      	str	r0, [r7, #4]
   11a8c:	6039      	str	r1, [r7, #0]
  {
    constexpr uint8_t kFIFOEnableAndReset = 0b111;
   11a8e:	2307      	movs	r3, #7
   11a90:	73fb      	strb	r3, [r7, #15]
    // Powering the port
    PowerUpPeripheral(port_.power_on_id);
   11a92:	687b      	ldr	r3, [r7, #4]
   11a94:	1d1a      	adds	r2, r3, #4
   11a96:	687b      	ldr	r3, [r7, #4]
   11a98:	689b      	ldr	r3, [r3, #8]
   11a9a:	3304      	adds	r3, #4
   11a9c:	4619      	mov	r1, r3
   11a9e:	4610      	mov	r0, r2
   11aa0:	f7ff fbda 	bl	11258 <sjsu::lpc40xx::SystemController::PowerUpPeripheral(sjsu::SystemController::PeripheralID const&) const>
    SetBaudRate(baud_rate);
   11aa4:	6839      	ldr	r1, [r7, #0]
   11aa6:	6878      	ldr	r0, [r7, #4]
   11aa8:	f7ff ff3a 	bl	11920 <sjsu::lpc40xx::Uart::SetBaudRate(unsigned long) const>
    // Setting the pin functions and modes
    port_.rx.SetPinFunction(port_.rx_function_id);
   11aac:	687b      	ldr	r3, [r7, #4]
   11aae:	689b      	ldr	r3, [r3, #8]
   11ab0:	68d8      	ldr	r0, [r3, #12]
   11ab2:	687b      	ldr	r3, [r7, #4]
   11ab4:	689b      	ldr	r3, [r3, #8]
   11ab6:	68db      	ldr	r3, [r3, #12]
   11ab8:	681b      	ldr	r3, [r3, #0]
   11aba:	681b      	ldr	r3, [r3, #0]
   11abc:	687a      	ldr	r2, [r7, #4]
   11abe:	6892      	ldr	r2, [r2, #8]
   11ac0:	7c12      	ldrb	r2, [r2, #16]
   11ac2:	f3c2 02c2 	ubfx	r2, r2, #3, #3
   11ac6:	b2d2      	uxtb	r2, r2
   11ac8:	4611      	mov	r1, r2
   11aca:	4798      	blx	r3
    port_.tx.SetPinFunction(port_.tx_function_id);
   11acc:	687b      	ldr	r3, [r7, #4]
   11ace:	689b      	ldr	r3, [r3, #8]
   11ad0:	6898      	ldr	r0, [r3, #8]
   11ad2:	687b      	ldr	r3, [r7, #4]
   11ad4:	689b      	ldr	r3, [r3, #8]
   11ad6:	689b      	ldr	r3, [r3, #8]
   11ad8:	681b      	ldr	r3, [r3, #0]
   11ada:	681b      	ldr	r3, [r3, #0]
   11adc:	687a      	ldr	r2, [r7, #4]
   11ade:	6892      	ldr	r2, [r2, #8]
   11ae0:	7c12      	ldrb	r2, [r2, #16]
   11ae2:	f3c2 0202 	ubfx	r2, r2, #0, #3
   11ae6:	b2d2      	uxtb	r2, r2
   11ae8:	4611      	mov	r1, r2
   11aea:	4798      	blx	r3
    port_.rx.SetMode(sjsu::Pin::Mode::kPullUp);
   11aec:	687b      	ldr	r3, [r7, #4]
   11aee:	689b      	ldr	r3, [r3, #8]
   11af0:	68da      	ldr	r2, [r3, #12]
   11af2:	687b      	ldr	r3, [r7, #4]
   11af4:	689b      	ldr	r3, [r3, #8]
   11af6:	68db      	ldr	r3, [r3, #12]
   11af8:	681b      	ldr	r3, [r3, #0]
   11afa:	3304      	adds	r3, #4
   11afc:	681b      	ldr	r3, [r3, #0]
   11afe:	2102      	movs	r1, #2
   11b00:	4610      	mov	r0, r2
   11b02:	4798      	blx	r3
    port_.tx.SetMode(sjsu::Pin::Mode::kPullUp);
   11b04:	687b      	ldr	r3, [r7, #4]
   11b06:	689b      	ldr	r3, [r3, #8]
   11b08:	689a      	ldr	r2, [r3, #8]
   11b0a:	687b      	ldr	r3, [r7, #4]
   11b0c:	689b      	ldr	r3, [r3, #8]
   11b0e:	689b      	ldr	r3, [r3, #8]
   11b10:	681b      	ldr	r3, [r3, #0]
   11b12:	3304      	adds	r3, #4
   11b14:	681b      	ldr	r3, [r3, #0]
   11b16:	2102      	movs	r1, #2
   11b18:	4610      	mov	r0, r2
   11b1a:	4798      	blx	r3
    port_.registers->FCR |= kFIFOEnableAndReset;
   11b1c:	687b      	ldr	r3, [r7, #4]
   11b1e:	689b      	ldr	r3, [r3, #8]
   11b20:	681b      	ldr	r3, [r3, #0]
   11b22:	7a1b      	ldrb	r3, [r3, #8]
   11b24:	b2da      	uxtb	r2, r3
   11b26:	687b      	ldr	r3, [r7, #4]
   11b28:	689b      	ldr	r3, [r3, #8]
   11b2a:	681b      	ldr	r3, [r3, #0]
   11b2c:	f042 0207 	orr.w	r2, r2, #7
   11b30:	b2d2      	uxtb	r2, r2
   11b32:	721a      	strb	r2, [r3, #8]

    return Status::kSuccess;
   11b34:	2300      	movs	r3, #0
  }
   11b36:	4618      	mov	r0, r3
   11b38:	3710      	adds	r7, #16
   11b3a:	46bd      	mov	sp, r7
   11b3c:	bd80      	pop	{r7, pc}

00011b3e <sjsu::lpc40xx::Uart::Send(unsigned char) const::{lambda()#1}::operator()() const>:

  void Send(uint8_t data) const override
  {
    port_.registers->THR             = data;
    auto wait_for_transfer_to_finish = [this]() -> bool {
   11b3e:	b480      	push	{r7}
   11b40:	b083      	sub	sp, #12
   11b42:	af00      	add	r7, sp, #0
   11b44:	6078      	str	r0, [r7, #4]
   11b46:	687b      	ldr	r3, [r7, #4]
   11b48:	681b      	ldr	r3, [r3, #0]
      return (port_.registers->LSR & (1 << 5));
   11b4a:	689b      	ldr	r3, [r3, #8]
   11b4c:	681b      	ldr	r3, [r3, #0]
   11b4e:	7d1b      	ldrb	r3, [r3, #20]
   11b50:	b2db      	uxtb	r3, r3
   11b52:	f003 0320 	and.w	r3, r3, #32
   11b56:	2b00      	cmp	r3, #0
   11b58:	bf14      	ite	ne
   11b5a:	2301      	movne	r3, #1
   11b5c:	2300      	moveq	r3, #0
   11b5e:	b2db      	uxtb	r3, r3
    };
   11b60:	4618      	mov	r0, r3
   11b62:	370c      	adds	r7, #12
   11b64:	46bd      	mov	sp, r7
   11b66:	f85d 7b04 	ldr.w	r7, [sp], #4
   11b6a:	4770      	bx	lr

00011b6c <sjsu::lpc40xx::Uart::Send(unsigned char) const>:
  void Send(uint8_t data) const override
   11b6c:	b5f0      	push	{r4, r5, r6, r7, lr}
   11b6e:	b08b      	sub	sp, #44	; 0x2c
   11b70:	af00      	add	r7, sp, #0
   11b72:	6078      	str	r0, [r7, #4]
   11b74:	460b      	mov	r3, r1
   11b76:	70fb      	strb	r3, [r7, #3]
    port_.registers->THR             = data;
   11b78:	687b      	ldr	r3, [r7, #4]
   11b7a:	689b      	ldr	r3, [r3, #8]
   11b7c:	681b      	ldr	r3, [r3, #0]
   11b7e:	78fa      	ldrb	r2, [r7, #3]
   11b80:	701a      	strb	r2, [r3, #0]
    };
   11b82:	687b      	ldr	r3, [r7, #4]
   11b84:	613b      	str	r3, [r7, #16]
   11b86:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   11b8a:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   11b8e:	e9c7 3408 	strd	r3, r4, [r7, #32]
   11b92:	693b      	ldr	r3, [r7, #16]
   11b94:	60fb      	str	r3, [r7, #12]
  uint64_t timeout_time = 0;
   11b96:	f04f 0300 	mov.w	r3, #0
   11b9a:	f04f 0400 	mov.w	r4, #0
   11b9e:	e9c7 3406 	strd	r3, r4, [r7, #24]
  if (timeout == kMaxWait)
   11ba2:	e9d7 3408 	ldrd	r3, r4, [r7, #32]
   11ba6:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   11baa:	bf08      	it	eq
   11bac:	f1b3 3fff 	cmpeq.w	r3, #4294967295	; 0xffffffff
   11bb0:	d106      	bne.n	11bc0 <sjsu::lpc40xx::Uart::Send(unsigned char) const+0x54>
    timeout_time = kMaxWait;
   11bb2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   11bb6:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   11bba:	e9c7 3406 	strd	r3, r4, [r7, #24]
   11bbe:	e00a      	b.n	11bd6 <sjsu::lpc40xx::Uart::Send(unsigned char) const+0x6a>
    timeout_time = Milliseconds() + timeout;
   11bc0:	f7fe fdba 	bl	10738 <sjsu::Milliseconds()>
   11bc4:	460a      	mov	r2, r1
   11bc6:	4601      	mov	r1, r0
   11bc8:	e9d7 3408 	ldrd	r3, r4, [r7, #32]
   11bcc:	185d      	adds	r5, r3, r1
   11bce:	eb44 0602 	adc.w	r6, r4, r2
   11bd2:	e9c7 5606 	strd	r5, r6, [r7, #24]
  Status status = Status::kTimedOut;
   11bd6:	2301      	movs	r3, #1
   11bd8:	617b      	str	r3, [r7, #20]
  while (Milliseconds() < timeout_time)
   11bda:	f7fe fdad 	bl	10738 <sjsu::Milliseconds()>
   11bde:	460a      	mov	r2, r1
   11be0:	4601      	mov	r1, r0
   11be2:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
   11be6:	42a2      	cmp	r2, r4
   11be8:	bf08      	it	eq
   11bea:	4299      	cmpeq	r1, r3
   11bec:	bf34      	ite	cc
   11bee:	2301      	movcc	r3, #1
   11bf0:	2300      	movcs	r3, #0
   11bf2:	b2db      	uxtb	r3, r3
   11bf4:	2b00      	cmp	r3, #0
   11bf6:	d009      	beq.n	11c0c <sjsu::lpc40xx::Uart::Send(unsigned char) const+0xa0>
    if (is_done())
   11bf8:	f107 030c 	add.w	r3, r7, #12
   11bfc:	4618      	mov	r0, r3
   11bfe:	f7ff ff9e 	bl	11b3e <sjsu::lpc40xx::Uart::Send(unsigned char) const::{lambda()#1}::operator()() const>
   11c02:	4603      	mov	r3, r0
   11c04:	2b00      	cmp	r3, #0
   11c06:	d0e8      	beq.n	11bda <sjsu::lpc40xx::Uart::Send(unsigned char) const+0x6e>
      status = Status::kSuccess;
   11c08:	2300      	movs	r3, #0
   11c0a:	617b      	str	r3, [r7, #20]
    Wait(kMaxWait, wait_for_transfer_to_finish);
  }
   11c0c:	bf00      	nop
   11c0e:	372c      	adds	r7, #44	; 0x2c
   11c10:	46bd      	mov	sp, r7
   11c12:	bdf0      	pop	{r4, r5, r6, r7, pc}

00011c14 <sjsu::lpc40xx::Uart::Receive(unsigned long) const::{lambda()#1}::operator()() const>:

  uint8_t Receive([[maybe_unused]] uint32_t timeout = 0x7FFFFFFF) const override
  {
    uint8_t receiver   = '\xFF';
    auto byte_recieved = [this]() -> bool {
   11c14:	b480      	push	{r7}
   11c16:	b083      	sub	sp, #12
   11c18:	af00      	add	r7, sp, #0
   11c1a:	6078      	str	r0, [r7, #4]
   11c1c:	687b      	ldr	r3, [r7, #4]
   11c1e:	681b      	ldr	r3, [r3, #0]
      return (port_.registers->LSR & (1 << 0));
   11c20:	689b      	ldr	r3, [r3, #8]
   11c22:	681b      	ldr	r3, [r3, #0]
   11c24:	7d1b      	ldrb	r3, [r3, #20]
   11c26:	b2db      	uxtb	r3, r3
   11c28:	f003 0301 	and.w	r3, r3, #1
   11c2c:	2b00      	cmp	r3, #0
   11c2e:	bf14      	ite	ne
   11c30:	2301      	movne	r3, #1
   11c32:	2300      	moveq	r3, #0
   11c34:	b2db      	uxtb	r3, r3
    };
   11c36:	4618      	mov	r0, r3
   11c38:	370c      	adds	r7, #12
   11c3a:	46bd      	mov	sp, r7
   11c3c:	f85d 7b04 	ldr.w	r7, [sp], #4
   11c40:	4770      	bx	lr

00011c42 <sjsu::lpc40xx::Uart::Receive(unsigned long) const>:
  uint8_t Receive([[maybe_unused]] uint32_t timeout = 0x7FFFFFFF) const override
   11c42:	b5f0      	push	{r4, r5, r6, r7, lr}
   11c44:	b08d      	sub	sp, #52	; 0x34
   11c46:	af00      	add	r7, sp, #0
   11c48:	6078      	str	r0, [r7, #4]
   11c4a:	6039      	str	r1, [r7, #0]
    uint8_t receiver   = '\xFF';
   11c4c:	23ff      	movs	r3, #255	; 0xff
   11c4e:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
    };
   11c52:	687b      	ldr	r3, [r7, #4]
   11c54:	613b      	str	r3, [r7, #16]

    Status status = Wait(timeout, byte_recieved);
   11c56:	683b      	ldr	r3, [r7, #0]
   11c58:	f04f 0400 	mov.w	r4, #0
   11c5c:	e9c7 3408 	strd	r3, r4, [r7, #32]
   11c60:	693b      	ldr	r3, [r7, #16]
   11c62:	60fb      	str	r3, [r7, #12]
  uint64_t timeout_time = 0;
   11c64:	f04f 0300 	mov.w	r3, #0
   11c68:	f04f 0400 	mov.w	r4, #0
   11c6c:	e9c7 3406 	strd	r3, r4, [r7, #24]
  if (timeout == kMaxWait)
   11c70:	e9d7 3408 	ldrd	r3, r4, [r7, #32]
   11c74:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   11c78:	bf08      	it	eq
   11c7a:	f1b3 3fff 	cmpeq.w	r3, #4294967295	; 0xffffffff
   11c7e:	d106      	bne.n	11c8e <sjsu::lpc40xx::Uart::Receive(unsigned long) const+0x4c>
    timeout_time = kMaxWait;
   11c80:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   11c84:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   11c88:	e9c7 3406 	strd	r3, r4, [r7, #24]
   11c8c:	e00a      	b.n	11ca4 <sjsu::lpc40xx::Uart::Receive(unsigned long) const+0x62>
    timeout_time = Milliseconds() + timeout;
   11c8e:	f7fe fd53 	bl	10738 <sjsu::Milliseconds()>
   11c92:	460a      	mov	r2, r1
   11c94:	4601      	mov	r1, r0
   11c96:	e9d7 3408 	ldrd	r3, r4, [r7, #32]
   11c9a:	185d      	adds	r5, r3, r1
   11c9c:	eb44 0602 	adc.w	r6, r4, r2
   11ca0:	e9c7 5606 	strd	r5, r6, [r7, #24]
  Status status = Status::kTimedOut;
   11ca4:	2301      	movs	r3, #1
   11ca6:	617b      	str	r3, [r7, #20]
  while (Milliseconds() < timeout_time)
   11ca8:	f7fe fd46 	bl	10738 <sjsu::Milliseconds()>
   11cac:	460a      	mov	r2, r1
   11cae:	4601      	mov	r1, r0
   11cb0:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
   11cb4:	42a2      	cmp	r2, r4
   11cb6:	bf08      	it	eq
   11cb8:	4299      	cmpeq	r1, r3
   11cba:	bf34      	ite	cc
   11cbc:	2301      	movcc	r3, #1
   11cbe:	2300      	movcs	r3, #0
   11cc0:	b2db      	uxtb	r3, r3
   11cc2:	2b00      	cmp	r3, #0
   11cc4:	d009      	beq.n	11cda <sjsu::lpc40xx::Uart::Receive(unsigned long) const+0x98>
    if (is_done())
   11cc6:	f107 030c 	add.w	r3, r7, #12
   11cca:	4618      	mov	r0, r3
   11ccc:	f7ff ffa2 	bl	11c14 <sjsu::lpc40xx::Uart::Receive(unsigned long) const::{lambda()#1}::operator()() const>
   11cd0:	4603      	mov	r3, r0
   11cd2:	2b00      	cmp	r3, #0
   11cd4:	d0e8      	beq.n	11ca8 <sjsu::lpc40xx::Uart::Receive(unsigned long) const+0x66>
      status = Status::kSuccess;
   11cd6:	2300      	movs	r3, #0
   11cd8:	617b      	str	r3, [r7, #20]
  return status;
   11cda:	697b      	ldr	r3, [r7, #20]
   11cdc:	62bb      	str	r3, [r7, #40]	; 0x28

    if (status == Status::kSuccess)
   11cde:	6abb      	ldr	r3, [r7, #40]	; 0x28
   11ce0:	2b00      	cmp	r3, #0
   11ce2:	d105      	bne.n	11cf0 <sjsu::lpc40xx::Uart::Receive(unsigned long) const+0xae>
    {
      receiver = static_cast<uint8_t>(port_.registers->RBR);
   11ce4:	687b      	ldr	r3, [r7, #4]
   11ce6:	689b      	ldr	r3, [r3, #8]
   11ce8:	681b      	ldr	r3, [r3, #0]
   11cea:	781b      	ldrb	r3, [r3, #0]
   11cec:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
    }
    return receiver;
   11cf0:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  }
   11cf4:	4618      	mov	r0, r3
   11cf6:	3734      	adds	r7, #52	; 0x34
   11cf8:	46bd      	mov	sp, r7
   11cfa:	bdf0      	pop	{r4, r5, r6, r7, pc}

00011cfc <(anonymous namespace)::Lpc40xxUptime()>:
{
   11cfc:	b598      	push	{r3, r4, r7, lr}
   11cfe:	af00      	add	r7, sp, #0
  return timer0.GetTimer();
   11d00:	4804      	ldr	r0, [pc, #16]	; (11d14 <(anonymous namespace)::Lpc40xxUptime()+0x18>)
   11d02:	f7ff fdfd 	bl	11900 <sjsu::lpc40xx::Timer::GetTimer() const>
   11d06:	4603      	mov	r3, r0
   11d08:	f04f 0400 	mov.w	r4, #0
}
   11d0c:	4618      	mov	r0, r3
   11d0e:	4621      	mov	r1, r4
   11d10:	bd98      	pop	{r3, r4, r7, pc}
   11d12:	bf00      	nop
   11d14:	1000031c 	.word	0x1000031c

00011d18 <UptimeRTOS>:
{
   11d18:	b598      	push	{r3, r4, r7, lr}
   11d1a:	af00      	add	r7, sp, #0
  return timer0.GetTimer();
   11d1c:	4804      	ldr	r0, [pc, #16]	; (11d30 <UptimeRTOS+0x18>)
   11d1e:	f7ff fdef 	bl	11900 <sjsu::lpc40xx::Timer::GetTimer() const>
   11d22:	4603      	mov	r3, r0
   11d24:	f04f 0400 	mov.w	r4, #0
}
   11d28:	4618      	mov	r0, r3
   11d2a:	4621      	mov	r1, r4
   11d2c:	bd98      	pop	{r3, r4, r7, pc}
   11d2e:	bf00      	nop
   11d30:	1000031c 	.word	0x1000031c

00011d34 <InitializePlatform()>:

void InitializePlatform()
{
   11d34:	b580      	push	{r7, lr}
   11d36:	af00      	add	r7, sp, #0
  // Set Clock Speed
  // SetClockFrequency will timeout return the offset between desire clockspeed
  // and actual clockspeed if the PLL doesn't get a frequency fix within a
  // defined timeout (see L1/system_clock.hpp:kDefaultTimeout)
  while (system_controller.SetClockFrequency(config::kSystemClockRateMhz) != 0)
   11d38:	2130      	movs	r1, #48	; 0x30
   11d3a:	4811      	ldr	r0, [pc, #68]	; (11d80 <InitializePlatform()+0x4c>)
   11d3c:	f7ff f9ca 	bl	110d4 <sjsu::lpc40xx::SystemController::SetClockFrequency(unsigned char) const>
   11d40:	4603      	mov	r3, r0
   11d42:	2b00      	cmp	r3, #0
   11d44:	bf14      	ite	ne
   11d46:	2301      	movne	r3, #1
   11d48:	2300      	moveq	r3, #0
   11d4a:	b2db      	uxtb	r3, r3
   11d4c:	2b00      	cmp	r3, #0
   11d4e:	d001      	beq.n	11d54 <InitializePlatform()+0x20>
  {
    // Continually attempt to set the clock frequency to the desired until the
    // delta between desired and actual are 0.
    continue;
   11d50:	bf00      	nop
  while (system_controller.SetClockFrequency(config::kSystemClockRateMhz) != 0)
   11d52:	e7f1      	b.n	11d38 <InitializePlatform()+0x4>
  }
  // Enable Peripheral Clock and set its divider to 1 meaning the clock speed
  // fed to all peripherals will be 48Mhz.
  system_controller.SetPeripheralClockDivider(1);
   11d54:	2101      	movs	r1, #1
   11d56:	480a      	ldr	r0, [pc, #40]	; (11d80 <InitializePlatform()+0x4c>)
   11d58:	f7ff f9fe 	bl	11158 <sjsu::lpc40xx::SystemController::SetPeripheralClockDivider(unsigned char) const>
  // Set timer0 to 1 MHz (1,000,000 Hz) so that the timer increments every 1
  // micro second.
  timer0.Initialize(1'000'000UL);
   11d5c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   11d60:	2200      	movs	r2, #0
   11d62:	4908      	ldr	r1, [pc, #32]	; (11d84 <InitializePlatform()+0x50>)
   11d64:	4808      	ldr	r0, [pc, #32]	; (11d88 <InitializePlatform()+0x54>)
   11d66:	f7ff fcfd 	bl	11764 <sjsu::lpc40xx::Timer::Initialize(unsigned long, void (*)(), long) const>
  sjsu::SetUptimeFunction(Lpc40xxUptime);
   11d6a:	4808      	ldr	r0, [pc, #32]	; (11d8c <InitializePlatform()+0x58>)
   11d6c:	f7ff f9a2 	bl	110b4 <sjsu::SetUptimeFunction(unsigned long long (*)())>
  // Set UART0 baudrate, which is required for printf and scanf to work properly
  sjsu::lpc40xx::uart0.Initialize(config::kBaudRate);
   11d70:	f44f 4116 	mov.w	r1, #38400	; 0x9600
   11d74:	4806      	ldr	r0, [pc, #24]	; (11d90 <InitializePlatform()+0x5c>)
   11d76:	f7ff fe85 	bl	11a84 <sjsu::lpc40xx::Uart::Initialize(unsigned long) const>
}
   11d7a:	bf00      	nop
   11d7c:	bd80      	pop	{r7, pc}
   11d7e:	bf00      	nop
   11d80:	1000009c 	.word	0x1000009c
   11d84:	000f4240 	.word	0x000f4240
   11d88:	1000031c 	.word	0x1000031c
   11d8c:	00011cfd 	.word	0x00011cfd
   11d90:	10000090 	.word	0x10000090

00011d94 <SystemInitialize()>:

void SystemInitialize()
{
   11d94:	b580      	push	{r7, lr}
   11d96:	af00      	add	r7, sp, #0
  // Transfer data section values from flash to RAM
  InitializeDataSection();
   11d98:	f7fe f9b8 	bl	1010c <InitializeDataSection()>
  // Clear BSS section of RAM
  // This is required because the nano implementation of the standard C/C++
  // libraries assumes that the BSS section is initialized to 0.
  InitializeBssSection();
   11d9c:	f7fe fa04 	bl	101a8 <InitializeBssSection()>
  // Enable FPU (F.loating P.oint U.nit)
  // System will crash if floating point instruction is executed before
  // Initializing the FPU first.
  InitializeFloatingPointUnit();
   11da0:	f7fe fa38 	bl	10214 <InitializeFloatingPointUnit()>
  // Initialisation C++ libraries
  __libc_init_array();
   11da4:	f002 fcce 	bl	14744 <__libc_init_array>
  // Run Low Level Platform Initialization
  InitializePlatform();
   11da8:	f7ff ffc4 	bl	11d34 <InitializePlatform()>
}
   11dac:	bf00      	nop
   11dae:	bd80      	pop	{r7, pc}

00011db0 <ResetIsr>:
SJ2_SECTION(".crp") const uint32_t kCrpWord = 0xFFFFFFFF;
// Reset entry point for your code.
// Sets up a simple runtime environment and initializes the C/C++ library.

extern "C" void ResetIsr()
{
   11db0:	b580      	push	{r7, lr}
   11db2:	b084      	sub	sp, #16
   11db4:	af00      	add	r7, sp, #0
  // The Hyperload bootloader takes up stack space to execute. The Hyperload
  // bootloader function launches this ISR manually, but it never returns thus
  // it never cleans up the memory it uses. To get that memory back, we have
  // to manually move the stack pointers back to the top of stack.
  const uint32_t kTopOfStack = reinterpret_cast<intptr_t>(&StackTop);
   11db6:	4b09      	ldr	r3, [pc, #36]	; (11ddc <ResetIsr+0x2c>)
   11db8:	60fb      	str	r3, [r7, #12]
   11dba:	68fb      	ldr	r3, [r7, #12]
   11dbc:	603b      	str	r3, [r7, #0]
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
   11dbe:	683b      	ldr	r3, [r7, #0]
   11dc0:	f383 8809 	msr	PSP, r3
   11dc4:	68fb      	ldr	r3, [r7, #12]
   11dc6:	607b      	str	r3, [r7, #4]

    \param [in]    topOfMainStack  Main Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
{
  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
   11dc8:	687b      	ldr	r3, [r7, #4]
   11dca:	f383 8808 	msr	MSP, r3
  __set_PSP(kTopOfStack);
  __set_MSP(kTopOfStack);

  SystemInitialize();
   11dce:	f7ff ffe1 	bl	11d94 <SystemInitialize()>
// #pragma ignored "-Wpedantic" to suppress main function call warning
#pragma GCC diagnostic push ignored "-Wpedantic"
  [[maybe_unused]] int32_t result = main();
   11dd2:	f7ff f89f 	bl	10f14 <main>
   11dd6:	60b8      	str	r0, [r7, #8]
   11dd8:	e7fe      	b.n	11dd8 <ResetIsr+0x28>
   11dda:	bf00      	nop
   11ddc:	10010000 	.word	0x10010000

00011de0 <void sjsu::lpc40xx::Timer::TimerHandler<sjsu::lpc40xx::Timer::Channel::kTimerPartial0>()>:
  static void TimerHandler()
   11de0:	b580      	push	{r7, lr}
   11de2:	af00      	add	r7, sp, #0
    TimerHandler(port);
   11de4:	4802      	ldr	r0, [pc, #8]	; (11df0 <void sjsu::lpc40xx::Timer::TimerHandler<sjsu::lpc40xx::Timer::Channel::kTimerPartial0>()+0x10>)
   11de6:	f7ff fc4f 	bl	11688 <sjsu::lpc40xx::Timer::TimerHandler(sjsu::lpc40xx::Timer::ChannelPartial_t const&)>
  }
   11dea:	bf00      	nop
   11dec:	bd80      	pop	{r7, pc}
   11dee:	bf00      	nop
   11df0:	00015610 	.word	0x00015610

00011df4 <__static_initialization_and_destruction_0(int, int)>:
// Enforce the warning after this point
#pragma GCC diagnostic pop
  // main() shouldn't return, but if it does, we'll just enter an infinite
  // loop
  sjsu::Halt();
}
   11df4:	b580      	push	{r7, lr}
   11df6:	b082      	sub	sp, #8
   11df8:	af00      	add	r7, sp, #0
   11dfa:	6078      	str	r0, [r7, #4]
   11dfc:	6039      	str	r1, [r7, #0]
   11dfe:	687b      	ldr	r3, [r7, #4]
   11e00:	2b01      	cmp	r3, #1
   11e02:	d10a      	bne.n	11e1a <__static_initialization_and_destruction_0(int, int)+0x26>
   11e04:	683b      	ldr	r3, [r7, #0]
   11e06:	f64f 72ff 	movw	r2, #65535	; 0xffff
   11e0a:	4293      	cmp	r3, r2
   11e0c:	d105      	bne.n	11e1a <__static_initialization_and_destruction_0(int, int)+0x26>
sjsu::lpc40xx::Timer timer0(sjsu::lpc40xx::Timer::Channel::kTimer0);
   11e0e:	4b05      	ldr	r3, [pc, #20]	; (11e24 <__static_initialization_and_destruction_0(int, int)+0x30>)
   11e10:	e893 0006 	ldmia.w	r3, {r1, r2}
   11e14:	4804      	ldr	r0, [pc, #16]	; (11e28 <__static_initialization_and_destruction_0(int, int)+0x34>)
   11e16:	f7ff fc83 	bl	11720 <sjsu::lpc40xx::Timer::Timer(sjsu::lpc40xx::Timer::Channel_t)>
}
   11e1a:	bf00      	nop
   11e1c:	3708      	adds	r7, #8
   11e1e:	46bd      	mov	sp, r7
   11e20:	bd80      	pop	{r7, pc}
   11e22:	bf00      	nop
   11e24:	00015620 	.word	0x00015620
   11e28:	1000031c 	.word	0x1000031c

00011e2c <_GLOBAL__sub_I_UptimeRTOS>:
   11e2c:	b580      	push	{r7, lr}
   11e2e:	af00      	add	r7, sp, #0
   11e30:	f64f 71ff 	movw	r1, #65535	; 0xffff
   11e34:	2001      	movs	r0, #1
   11e36:	f7ff ffdd 	bl	11df4 <__static_initialization_and_destruction_0(int, int)>
   11e3a:	bd80      	pop	{r7, pc}

00011e3c <NVIC_EnableIRQ>:
  \brief   Enable External Interrupt
  \details Enables a device-specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
   11e3c:	b480      	push	{r7}
   11e3e:	b083      	sub	sp, #12
   11e40:	af00      	add	r7, sp, #0
   11e42:	4603      	mov	r3, r0
   11e44:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
   11e46:	f997 3007 	ldrsb.w	r3, [r7, #7]
   11e4a:	f003 021f 	and.w	r2, r3, #31
   11e4e:	4907      	ldr	r1, [pc, #28]	; (11e6c <NVIC_EnableIRQ+0x30>)
   11e50:	f997 3007 	ldrsb.w	r3, [r7, #7]
   11e54:	095b      	lsrs	r3, r3, #5
   11e56:	2001      	movs	r0, #1
   11e58:	fa00 f202 	lsl.w	r2, r0, r2
   11e5c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   11e60:	bf00      	nop
   11e62:	370c      	adds	r7, #12
   11e64:	46bd      	mov	sp, r7
   11e66:	f85d 7b04 	ldr.w	r7, [sp], #4
   11e6a:	4770      	bx	lr
   11e6c:	e000e100 	.word	0xe000e100

00011e70 <NVIC_SetPriority>:
  \note    The priority cannot be set for every core interrupt.
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
   11e70:	b480      	push	{r7}
   11e72:	b083      	sub	sp, #12
   11e74:	af00      	add	r7, sp, #0
   11e76:	4603      	mov	r3, r0
   11e78:	6039      	str	r1, [r7, #0]
   11e7a:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) < 0)
   11e7c:	f997 3007 	ldrsb.w	r3, [r7, #7]
   11e80:	2b00      	cmp	r3, #0
   11e82:	da0c      	bge.n	11e9e <NVIC_SetPriority+0x2e>
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   11e84:	683b      	ldr	r3, [r7, #0]
   11e86:	b2da      	uxtb	r2, r3
   11e88:	490e      	ldr	r1, [pc, #56]	; (11ec4 <NVIC_SetPriority+0x54>)
   11e8a:	f997 3007 	ldrsb.w	r3, [r7, #7]
   11e8e:	f003 030f 	and.w	r3, r3, #15
   11e92:	3b04      	subs	r3, #4
   11e94:	0152      	lsls	r2, r2, #5
   11e96:	b2d2      	uxtb	r2, r2
   11e98:	440b      	add	r3, r1
   11e9a:	761a      	strb	r2, [r3, #24]
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
   11e9c:	e00b      	b.n	11eb6 <NVIC_SetPriority+0x46>
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   11e9e:	683b      	ldr	r3, [r7, #0]
   11ea0:	b2db      	uxtb	r3, r3
   11ea2:	4a09      	ldr	r2, [pc, #36]	; (11ec8 <NVIC_SetPriority+0x58>)
   11ea4:	f997 1007 	ldrsb.w	r1, [r7, #7]
   11ea8:	4608      	mov	r0, r1
   11eaa:	015b      	lsls	r3, r3, #5
   11eac:	b2d9      	uxtb	r1, r3
   11eae:	1813      	adds	r3, r2, r0
   11eb0:	460a      	mov	r2, r1
   11eb2:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
   11eb6:	bf00      	nop
   11eb8:	370c      	adds	r7, #12
   11eba:	46bd      	mov	sp, r7
   11ebc:	f85d 7b04 	ldr.w	r7, [sp], #4
   11ec0:	4770      	bx	lr
   11ec2:	bf00      	nop
   11ec4:	e000ed00 	.word	0xe000ed00
   11ec8:	e000e100 	.word	0xe000e100

00011ecc <InterruptLookupHandler>:
{
   11ecc:	b580      	push	{r7, lr}
   11ece:	b084      	sub	sp, #16
   11ed0:	af02      	add	r7, sp, #8
  uint8_t active_isr = (SCB->ICSR & 0xFF);
   11ed2:	4b11      	ldr	r3, [pc, #68]	; (11f18 <InterruptLookupHandler+0x4c>)
   11ed4:	685b      	ldr	r3, [r3, #4]
   11ed6:	71fb      	strb	r3, [r7, #7]
  IsrPointer isr     = dynamic_isr_vector_table[active_isr];
   11ed8:	79fb      	ldrb	r3, [r7, #7]
   11eda:	4a10      	ldr	r2, [pc, #64]	; (11f1c <InterruptLookupHandler+0x50>)
   11edc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11ee0:	603b      	str	r3, [r7, #0]
  SJ2_ASSERT_FATAL(isr != InterruptLookupHandler,
   11ee2:	683b      	ldr	r3, [r7, #0]
   11ee4:	4a0e      	ldr	r2, [pc, #56]	; (11f20 <InterruptLookupHandler+0x54>)
   11ee6:	4293      	cmp	r3, r2
   11ee8:	d10f      	bne.n	11f0a <InterruptLookupHandler+0x3e>
   11eea:	79fb      	ldrb	r3, [r7, #7]
   11eec:	9300      	str	r3, [sp, #0]
   11eee:	23dd      	movs	r3, #221	; 0xdd
   11ef0:	4a0c      	ldr	r2, [pc, #48]	; (11f24 <InterruptLookupHandler+0x58>)
   11ef2:	490d      	ldr	r1, [pc, #52]	; (11f28 <InterruptLookupHandler+0x5c>)
   11ef4:	480d      	ldr	r0, [pc, #52]	; (11f2c <InterruptLookupHandler+0x60>)
   11ef6:	f001 fa95 	bl	13424 <printf>
   11efa:	480d      	ldr	r0, [pc, #52]	; (11f30 <InterruptLookupHandler+0x64>)
   11efc:	f000 f8c2 	bl	12084 <puts>
   11f00:	2100      	movs	r1, #0
   11f02:	2001      	movs	r0, #1
   11f04:	f7fe fbba 	bl	1067c <sjsu::debug::PrintBacktrace(bool, void*)>
   11f08:	e7fe      	b.n	11f08 <InterruptLookupHandler+0x3c>
  isr();
   11f0a:	683b      	ldr	r3, [r7, #0]
   11f0c:	4798      	blx	r3
}
   11f0e:	bf00      	nop
   11f10:	3708      	adds	r7, #8
   11f12:	46bd      	mov	sp, r7
   11f14:	bd80      	pop	{r7, pc}
   11f16:	bf00      	nop
   11f18:	e000ed00 	.word	0xe000ed00
   11f1c:	100000a0 	.word	0x100000a0
   11f20:	00011ecd 	.word	0x00011ecd
   11f24:	00015c74 	.word	0x00015c74
   11f28:	00015c64 	.word	0x00015c64
   11f2c:	00015b08 	.word	0x00015b08
   11f30:	00015bb4 	.word	0x00015bb4

00011f34 <RegisterIsr(IRQn, void (*)(), bool, long)>:
{
   11f34:	b580      	push	{r7, lr}
   11f36:	b084      	sub	sp, #16
   11f38:	af00      	add	r7, sp, #0
   11f3a:	60b9      	str	r1, [r7, #8]
   11f3c:	607b      	str	r3, [r7, #4]
   11f3e:	4603      	mov	r3, r0
   11f40:	73fb      	strb	r3, [r7, #15]
   11f42:	4613      	mov	r3, r2
   11f44:	73bb      	strb	r3, [r7, #14]
  dynamic_isr_vector_table[irq + kIrqOffset] = isr;
   11f46:	f997 300f 	ldrsb.w	r3, [r7, #15]
   11f4a:	3310      	adds	r3, #16
   11f4c:	490e      	ldr	r1, [pc, #56]	; (11f88 <RegisterIsr(IRQn, void (*)(), bool, long)+0x54>)
   11f4e:	68ba      	ldr	r2, [r7, #8]
   11f50:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  if (enable_interrupt && irq >= 0)
   11f54:	7bbb      	ldrb	r3, [r7, #14]
   11f56:	2b00      	cmp	r3, #0
   11f58:	d008      	beq.n	11f6c <RegisterIsr(IRQn, void (*)(), bool, long)+0x38>
   11f5a:	f997 300f 	ldrsb.w	r3, [r7, #15]
   11f5e:	2b00      	cmp	r3, #0
   11f60:	db04      	blt.n	11f6c <RegisterIsr(IRQn, void (*)(), bool, long)+0x38>
    NVIC_EnableIRQ(irq);
   11f62:	f997 300f 	ldrsb.w	r3, [r7, #15]
   11f66:	4618      	mov	r0, r3
   11f68:	f7ff ff68 	bl	11e3c <NVIC_EnableIRQ>
  if (priority > -1)
   11f6c:	687b      	ldr	r3, [r7, #4]
   11f6e:	2b00      	cmp	r3, #0
   11f70:	db06      	blt.n	11f80 <RegisterIsr(IRQn, void (*)(), bool, long)+0x4c>
    NVIC_SetPriority(irq, priority);
   11f72:	687a      	ldr	r2, [r7, #4]
   11f74:	f997 300f 	ldrsb.w	r3, [r7, #15]
   11f78:	4611      	mov	r1, r2
   11f7a:	4618      	mov	r0, r3
   11f7c:	f7ff ff78 	bl	11e70 <NVIC_SetPriority>
}
   11f80:	bf00      	nop
   11f82:	3710      	adds	r7, #16
   11f84:	46bd      	mov	sp, r7
   11f86:	bd80      	pop	{r7, pc}
   11f88:	100000a0 	.word	0x100000a0

00011f8c <GetRegistersFromStack>:
{
   11f8c:	b580      	push	{r7, lr}
   11f8e:	b08c      	sub	sp, #48	; 0x30
   11f90:	af02      	add	r7, sp, #8
   11f92:	6078      	str	r0, [r7, #4]
  volatile uint32_t r0  = fault_stack_address[0];
   11f94:	687b      	ldr	r3, [r7, #4]
   11f96:	681b      	ldr	r3, [r3, #0]
   11f98:	627b      	str	r3, [r7, #36]	; 0x24
  volatile uint32_t r1  = fault_stack_address[1];
   11f9a:	687b      	ldr	r3, [r7, #4]
   11f9c:	685b      	ldr	r3, [r3, #4]
   11f9e:	623b      	str	r3, [r7, #32]
  volatile uint32_t r2  = fault_stack_address[2];
   11fa0:	687b      	ldr	r3, [r7, #4]
   11fa2:	689b      	ldr	r3, [r3, #8]
   11fa4:	61fb      	str	r3, [r7, #28]
  volatile uint32_t r3  = fault_stack_address[3];
   11fa6:	687b      	ldr	r3, [r7, #4]
   11fa8:	68db      	ldr	r3, [r3, #12]
   11faa:	61bb      	str	r3, [r7, #24]
  volatile uint32_t r12 = fault_stack_address[4];
   11fac:	687b      	ldr	r3, [r7, #4]
   11fae:	691b      	ldr	r3, [r3, #16]
   11fb0:	617b      	str	r3, [r7, #20]
  volatile uint32_t lr = fault_stack_address[5];
   11fb2:	687b      	ldr	r3, [r7, #4]
   11fb4:	695b      	ldr	r3, [r3, #20]
   11fb6:	613b      	str	r3, [r7, #16]
  volatile uint32_t pc = fault_stack_address[6];
   11fb8:	687b      	ldr	r3, [r7, #4]
   11fba:	699b      	ldr	r3, [r3, #24]
   11fbc:	60fb      	str	r3, [r7, #12]
  volatile uint32_t psr = fault_stack_address[7];
   11fbe:	687b      	ldr	r3, [r7, #4]
   11fc0:	69db      	ldr	r3, [r3, #28]
   11fc2:	60bb      	str	r3, [r7, #8]
  printf(SJ2_BACKGROUND_RED "Hard Fault Exception Occurred!\n" SJ2_COLOR_RESET);
   11fc4:	480d      	ldr	r0, [pc, #52]	; (11ffc <GetRegistersFromStack+0x70>)
   11fc6:	f001 fa2d 	bl	13424 <printf>
  printf("r0: 0x%08" PRIX32 ", r1: 0x%08" PRIX32
   11fca:	6a79      	ldr	r1, [r7, #36]	; 0x24
   11fcc:	6a3a      	ldr	r2, [r7, #32]
   11fce:	69f8      	ldr	r0, [r7, #28]
   11fd0:	69bb      	ldr	r3, [r7, #24]
   11fd2:	9300      	str	r3, [sp, #0]
   11fd4:	4603      	mov	r3, r0
   11fd6:	480a      	ldr	r0, [pc, #40]	; (12000 <GetRegistersFromStack+0x74>)
   11fd8:	f001 fa24 	bl	13424 <printf>
  printf("r12: 0x%08" PRIX32 ", lr: 0x%08" PRIX32
   11fdc:	6979      	ldr	r1, [r7, #20]
   11fde:	693a      	ldr	r2, [r7, #16]
   11fe0:	68f8      	ldr	r0, [r7, #12]
   11fe2:	68bb      	ldr	r3, [r7, #8]
   11fe4:	9300      	str	r3, [sp, #0]
   11fe6:	4603      	mov	r3, r0
   11fe8:	4806      	ldr	r0, [pc, #24]	; (12004 <GetRegistersFromStack+0x78>)
   11fea:	f001 fa1b 	bl	13424 <printf>
  sjsu::debug::PrintBacktrace(true, reinterpret_cast<void *>(pc));
   11fee:	68fb      	ldr	r3, [r7, #12]
   11ff0:	4619      	mov	r1, r3
   11ff2:	2001      	movs	r0, #1
   11ff4:	f7fe fb42 	bl	1067c <sjsu::debug::PrintBacktrace(bool, void*)>
   11ff8:	e7fe      	b.n	11ff8 <GetRegistersFromStack+0x6c>
   11ffa:	bf00      	nop
   11ffc:	00015bcc 	.word	0x00015bcc
   12000:	00015bf8 	.word	0x00015bf8
   12004:	00015c2c 	.word	0x00015c2c

00012008 <FirmwareStdOut(int)>:
}
Stdout out = HostWrite;
Stdin in   = HostRead;
#else
int FirmwareStdOut(int data)
{
   12008:	b580      	push	{r7, lr}
   1200a:	b082      	sub	sp, #8
   1200c:	af00      	add	r7, sp, #0
   1200e:	6078      	str	r0, [r7, #4]
  sjsu::lpc40xx::uart0.Send(static_cast<uint8_t>(data));
   12010:	687b      	ldr	r3, [r7, #4]
   12012:	b2db      	uxtb	r3, r3
   12014:	4619      	mov	r1, r3
   12016:	4804      	ldr	r0, [pc, #16]	; (12028 <FirmwareStdOut(int)+0x20>)
   12018:	f7ff fda8 	bl	11b6c <sjsu::lpc40xx::Uart::Send(unsigned char) const>
  return 1;
   1201c:	2301      	movs	r3, #1
}
   1201e:	4618      	mov	r0, r3
   12020:	3708      	adds	r7, #8
   12022:	46bd      	mov	sp, r7
   12024:	bd80      	pop	{r7, pc}
   12026:	bf00      	nop
   12028:	10000090 	.word	0x10000090

0001202c <_exit>:
  }
  // Dummy implementation of exit with return code placed into
  // Arm register r3
  // NOLINTNEXTLINE(readability-identifier-naming)
  void _exit([[maybe_unused]] int rc)
  {
   1202c:	b480      	push	{r7}
   1202e:	b083      	sub	sp, #12
   12030:	af00      	add	r7, sp, #0
   12032:	6078      	str	r0, [r7, #4]
    while (1)
    {
      continue;
   12034:	bf00      	nop
    while (1)
   12036:	e7fd      	b.n	12034 <_exit+0x8>

00012038 <_getpid>:
    }
  }
  // Dummy implementation of getpid
  // NOLINTNEXTLINE(readability-identifier-naming)
  int _getpid()
  {
   12038:	b480      	push	{r7}
   1203a:	af00      	add	r7, sp, #0
    return 1;
   1203c:	2301      	movs	r3, #1
  }
   1203e:	4618      	mov	r0, r3
   12040:	46bd      	mov	sp, r7
   12042:	f85d 7b04 	ldr.w	r7, [sp], #4
   12046:	4770      	bx	lr

00012048 <_kill>:
  // Dummy implementation of kill
  // NOLINTNEXTLINE(readability-identifier-naming)
  int _kill(int, int)
  {
   12048:	b480      	push	{r7}
   1204a:	b083      	sub	sp, #12
   1204c:	af00      	add	r7, sp, #0
   1204e:	6078      	str	r0, [r7, #4]
   12050:	6039      	str	r1, [r7, #0]
    return -1;
   12052:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  }
   12056:	4618      	mov	r0, r3
   12058:	370c      	adds	r7, #12
   1205a:	46bd      	mov	sp, r7
   1205c:	f85d 7b04 	ldr.w	r7, [sp], #4
   12060:	4770      	bx	lr
   12062:	Address 0x0000000000012062 is out of bounds.


00012064 <_putchar>:
    }
    return length;
  }
  // Needed by third party printf library
  void _putchar(char character)  // NOLINT
  {
   12064:	b580      	push	{r7, lr}
   12066:	b082      	sub	sp, #8
   12068:	af00      	add	r7, sp, #0
   1206a:	4603      	mov	r3, r0
   1206c:	71fb      	strb	r3, [r7, #7]
    out(character);
   1206e:	4b04      	ldr	r3, [pc, #16]	; (12080 <_putchar+0x1c>)
   12070:	681b      	ldr	r3, [r3, #0]
   12072:	79fa      	ldrb	r2, [r7, #7]
   12074:	4610      	mov	r0, r2
   12076:	4798      	blx	r3
  }
   12078:	bf00      	nop
   1207a:	3708      	adds	r7, #8
   1207c:	46bd      	mov	sp, r7
   1207e:	bd80      	pop	{r7, pc}
   12080:	10000184 	.word	0x10000184

00012084 <puts>:
  }

  // Overload default libnano puts() with a more optimal version that does
  // not use dynamic memory
  int puts(const char * str)  // NOLINT
  {
   12084:	b580      	push	{r7, lr}
   12086:	b084      	sub	sp, #16
   12088:	af00      	add	r7, sp, #0
   1208a:	6078      	str	r0, [r7, #4]
    int i;
    for (i = 0; str[i] != '\0'; i++)
   1208c:	2300      	movs	r3, #0
   1208e:	60fb      	str	r3, [r7, #12]
   12090:	68fb      	ldr	r3, [r7, #12]
   12092:	687a      	ldr	r2, [r7, #4]
   12094:	4413      	add	r3, r2
   12096:	781b      	ldrb	r3, [r3, #0]
   12098:	2b00      	cmp	r3, #0
   1209a:	d00b      	beq.n	120b4 <puts+0x30>
    {
      out(str[i]);
   1209c:	4b0a      	ldr	r3, [pc, #40]	; (120c8 <puts+0x44>)
   1209e:	681b      	ldr	r3, [r3, #0]
   120a0:	68fa      	ldr	r2, [r7, #12]
   120a2:	6879      	ldr	r1, [r7, #4]
   120a4:	440a      	add	r2, r1
   120a6:	7812      	ldrb	r2, [r2, #0]
   120a8:	4610      	mov	r0, r2
   120aa:	4798      	blx	r3
    for (i = 0; str[i] != '\0'; i++)
   120ac:	68fb      	ldr	r3, [r7, #12]
   120ae:	3301      	adds	r3, #1
   120b0:	60fb      	str	r3, [r7, #12]
   120b2:	e7ed      	b.n	12090 <puts+0xc>
    }
    out('\n');
   120b4:	4b04      	ldr	r3, [pc, #16]	; (120c8 <puts+0x44>)
   120b6:	681b      	ldr	r3, [r3, #0]
   120b8:	200a      	movs	r0, #10
   120ba:	4798      	blx	r3
    return i;
   120bc:	68fb      	ldr	r3, [r7, #12]
  }
   120be:	4618      	mov	r0, r3
   120c0:	3710      	adds	r7, #16
   120c2:	46bd      	mov	sp, r7
   120c4:	bd80      	pop	{r7, pc}
   120c6:	bf00      	nop
   120c8:	10000184 	.word	0x10000184

000120cc <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
   120cc:	b590      	push	{r4, r7, lr}
   120ce:	b085      	sub	sp, #20
   120d0:	af00      	add	r7, sp, #0
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
   120d2:	4b29      	ldr	r3, [pc, #164]	; (12178 <vTaskSwitchContext+0xac>)
   120d4:	681b      	ldr	r3, [r3, #0]
   120d6:	2b00      	cmp	r3, #0
   120d8:	d003      	beq.n	120e2 <vTaskSwitchContext+0x16>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
   120da:	4b28      	ldr	r3, [pc, #160]	; (1217c <vTaskSwitchContext+0xb0>)
   120dc:	2201      	movs	r2, #1
   120de:	601a      	str	r2, [r3, #0]
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
   120e0:	e045      	b.n	1216e <vTaskSwitchContext+0xa2>
		xYieldPending = pdFALSE;
   120e2:	4b26      	ldr	r3, [pc, #152]	; (1217c <vTaskSwitchContext+0xb0>)
   120e4:	2200      	movs	r2, #0
   120e6:	601a      	str	r2, [r3, #0]
					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
   120e8:	f7ff fe16 	bl	11d18 <UptimeRTOS>
   120ec:	4603      	mov	r3, r0
   120ee:	460c      	mov	r4, r1
   120f0:	461a      	mov	r2, r3
   120f2:	4b23      	ldr	r3, [pc, #140]	; (12180 <vTaskSwitchContext+0xb4>)
   120f4:	601a      	str	r2, [r3, #0]
				if( ulTotalRunTime > ulTaskSwitchedInTime )
   120f6:	4b22      	ldr	r3, [pc, #136]	; (12180 <vTaskSwitchContext+0xb4>)
   120f8:	681a      	ldr	r2, [r3, #0]
   120fa:	4b22      	ldr	r3, [pc, #136]	; (12184 <vTaskSwitchContext+0xb8>)
   120fc:	681b      	ldr	r3, [r3, #0]
   120fe:	429a      	cmp	r2, r3
   12100:	d909      	bls.n	12116 <vTaskSwitchContext+0x4a>
					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
   12102:	4b21      	ldr	r3, [pc, #132]	; (12188 <vTaskSwitchContext+0xbc>)
   12104:	681b      	ldr	r3, [r3, #0]
   12106:	6d59      	ldr	r1, [r3, #84]	; 0x54
   12108:	4a1d      	ldr	r2, [pc, #116]	; (12180 <vTaskSwitchContext+0xb4>)
   1210a:	6810      	ldr	r0, [r2, #0]
   1210c:	4a1d      	ldr	r2, [pc, #116]	; (12184 <vTaskSwitchContext+0xb8>)
   1210e:	6812      	ldr	r2, [r2, #0]
   12110:	1a82      	subs	r2, r0, r2
   12112:	440a      	add	r2, r1
   12114:	655a      	str	r2, [r3, #84]	; 0x54
				ulTaskSwitchedInTime = ulTotalRunTime;
   12116:	4b1a      	ldr	r3, [pc, #104]	; (12180 <vTaskSwitchContext+0xb4>)
   12118:	681b      	ldr	r3, [r3, #0]
   1211a:	4a1a      	ldr	r2, [pc, #104]	; (12184 <vTaskSwitchContext+0xb8>)
   1211c:	6013      	str	r3, [r2, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK();
   1211e:	4b1b      	ldr	r3, [pc, #108]	; (1218c <vTaskSwitchContext+0xc0>)
   12120:	681b      	ldr	r3, [r3, #0]
   12122:	607b      	str	r3, [r7, #4]
	/* Generic helper function. */
	__attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitmap )
	{
	uint8_t ucReturn;

		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
   12124:	687b      	ldr	r3, [r7, #4]
   12126:	fab3 f383 	clz	r3, r3
   1212a:	70fb      	strb	r3, [r7, #3]
		return ucReturn;
   1212c:	78fb      	ldrb	r3, [r7, #3]
   1212e:	f1c3 031f 	rsb	r3, r3, #31
   12132:	60fb      	str	r3, [r7, #12]
   12134:	68fa      	ldr	r2, [r7, #12]
   12136:	4613      	mov	r3, r2
   12138:	009b      	lsls	r3, r3, #2
   1213a:	4413      	add	r3, r2
   1213c:	009b      	lsls	r3, r3, #2
   1213e:	4a14      	ldr	r2, [pc, #80]	; (12190 <vTaskSwitchContext+0xc4>)
   12140:	4413      	add	r3, r2
   12142:	60bb      	str	r3, [r7, #8]
   12144:	68bb      	ldr	r3, [r7, #8]
   12146:	685b      	ldr	r3, [r3, #4]
   12148:	685a      	ldr	r2, [r3, #4]
   1214a:	68bb      	ldr	r3, [r7, #8]
   1214c:	605a      	str	r2, [r3, #4]
   1214e:	68bb      	ldr	r3, [r7, #8]
   12150:	685a      	ldr	r2, [r3, #4]
   12152:	68bb      	ldr	r3, [r7, #8]
   12154:	3308      	adds	r3, #8
   12156:	429a      	cmp	r2, r3
   12158:	d104      	bne.n	12164 <vTaskSwitchContext+0x98>
   1215a:	68bb      	ldr	r3, [r7, #8]
   1215c:	685b      	ldr	r3, [r3, #4]
   1215e:	685a      	ldr	r2, [r3, #4]
   12160:	68bb      	ldr	r3, [r7, #8]
   12162:	605a      	str	r2, [r3, #4]
   12164:	68bb      	ldr	r3, [r7, #8]
   12166:	685b      	ldr	r3, [r3, #4]
   12168:	68db      	ldr	r3, [r3, #12]
   1216a:	4a07      	ldr	r2, [pc, #28]	; (12188 <vTaskSwitchContext+0xbc>)
   1216c:	6013      	str	r3, [r2, #0]
}
   1216e:	bf00      	nop
   12170:	3714      	adds	r7, #20
   12172:	46bd      	mov	sp, r7
   12174:	bd90      	pop	{r4, r7, pc}
   12176:	bf00      	nop
   12178:	10000398 	.word	0x10000398
   1217c:	10000394 	.word	0x10000394
   12180:	100003a0 	.word	0x100003a0
   12184:	1000039c 	.word	0x1000039c
   12188:	10000328 	.word	0x10000328
   1218c:	10000390 	.word	0x10000390
   12190:	1000032c 	.word	0x1000032c
   12194:	ffffffff 	.word	0xffffffff
   12198:	ffffffff 	.word	0xffffffff
   1219c:	ffffffff 	.word	0xffffffff

000121a0 <vPortSVCHandler>:
}
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
   121a0:	4b07      	ldr	r3, [pc, #28]	; (121c0 <pxCurrentTCBConst2>)
   121a2:	6819      	ldr	r1, [r3, #0]
   121a4:	6808      	ldr	r0, [r1, #0]
   121a6:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   121aa:	f380 8809 	msr	PSP, r0
   121ae:	f3bf 8f6f 	isb	sy
   121b2:	f04f 0000 	mov.w	r0, #0
   121b6:	f380 8811 	msr	BASEPRI, r0
   121ba:	4770      	bx	lr
   121bc:	f3af 8000 	nop.w

000121c0 <pxCurrentTCBConst2>:
   121c0:	10000328 	.word	0x10000328
					"	bx r14							\n"
					"									\n"
					"	.align 4						\n"
					"pxCurrentTCBConst2: .word pxCurrentTCB				\n"
				);
}
   121c4:	bf00      	nop
   121c6:	bf00      	nop
   121c8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   121cc:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff

000121d0 <xPortPendSVHandler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
   121d0:	f3ef 8009 	mrs	r0, PSP
   121d4:	f3bf 8f6f 	isb	sy
   121d8:	4b15      	ldr	r3, [pc, #84]	; (12230 <pxCurrentTCBConst>)
   121da:	681a      	ldr	r2, [r3, #0]
   121dc:	f01e 0f10 	tst.w	lr, #16
   121e0:	bf08      	it	eq
   121e2:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
   121e6:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   121ea:	6010      	str	r0, [r2, #0]
   121ec:	e92d 0009 	stmdb	sp!, {r0, r3}
   121f0:	f04f 0028 	mov.w	r0, #40	; 0x28
   121f4:	f380 8811 	msr	BASEPRI, r0
   121f8:	f3bf 8f4f 	dsb	sy
   121fc:	f3bf 8f6f 	isb	sy
   12200:	f7ff ff64 	bl	120cc <vTaskSwitchContext>
   12204:	f04f 0000 	mov.w	r0, #0
   12208:	f380 8811 	msr	BASEPRI, r0
   1220c:	bc09      	pop	{r0, r3}
   1220e:	6819      	ldr	r1, [r3, #0]
   12210:	6808      	ldr	r0, [r1, #0]
   12212:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   12216:	f01e 0f10 	tst.w	lr, #16
   1221a:	bf08      	it	eq
   1221c:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
   12220:	f380 8809 	msr	PSP, r0
   12224:	f3bf 8f6f 	isb	sy
   12228:	4770      	bx	lr
   1222a:	bf00      	nop
   1222c:	f3af 8000 	nop.w

00012230 <pxCurrentTCBConst>:
   12230:	10000328 	.word	0x10000328
	"										\n"
	"	.align 4							\n"
	"pxCurrentTCBConst: .word pxCurrentTCB	\n"
	::"i"(configMAX_SYSCALL_INTERRUPT_PRIORITY)
	);
}
   12234:	bf00      	nop
   12236:	bf00      	nop

00012238 <_out_null(char, void*, unsigned int, unsigned int)>:
}


// internal null output
static inline void _out_null(char character, void* buffer, size_t idx, size_t maxlen)
{
   12238:	b480      	push	{r7}
   1223a:	b085      	sub	sp, #20
   1223c:	af00      	add	r7, sp, #0
   1223e:	60b9      	str	r1, [r7, #8]
   12240:	607a      	str	r2, [r7, #4]
   12242:	603b      	str	r3, [r7, #0]
   12244:	4603      	mov	r3, r0
   12246:	73fb      	strb	r3, [r7, #15]
  (void)character; (void)buffer; (void)idx; (void)maxlen;
}
   12248:	bf00      	nop
   1224a:	3714      	adds	r7, #20
   1224c:	46bd      	mov	sp, r7
   1224e:	f85d 7b04 	ldr.w	r7, [sp], #4
   12252:	4770      	bx	lr

00012254 <_out_char(char, void*, unsigned int, unsigned int)>:


// internal _putchar wrapper
static inline void _out_char(char character, void* buffer, size_t idx, size_t maxlen)
{
   12254:	b580      	push	{r7, lr}
   12256:	b084      	sub	sp, #16
   12258:	af00      	add	r7, sp, #0
   1225a:	60b9      	str	r1, [r7, #8]
   1225c:	607a      	str	r2, [r7, #4]
   1225e:	603b      	str	r3, [r7, #0]
   12260:	4603      	mov	r3, r0
   12262:	73fb      	strb	r3, [r7, #15]
  (void)buffer; (void)idx; (void)maxlen;
  if (character) {
   12264:	7bfb      	ldrb	r3, [r7, #15]
   12266:	2b00      	cmp	r3, #0
   12268:	d003      	beq.n	12272 <_out_char(char, void*, unsigned int, unsigned int)+0x1e>
    _putchar(character);
   1226a:	7bfb      	ldrb	r3, [r7, #15]
   1226c:	4618      	mov	r0, r3
   1226e:	f7ff fef9 	bl	12064 <_putchar>
  }
}
   12272:	bf00      	nop
   12274:	3710      	adds	r7, #16
   12276:	46bd      	mov	sp, r7
   12278:	bd80      	pop	{r7, pc}

0001227a <_strlen(char const*)>:


// internal strlen
// \return The length of the string (excluding the terminating 0)
static inline unsigned int _strlen(const char* str)
{
   1227a:	b480      	push	{r7}
   1227c:	b085      	sub	sp, #20
   1227e:	af00      	add	r7, sp, #0
   12280:	6078      	str	r0, [r7, #4]
  const char* s;
  for (s = str; *s; ++s);
   12282:	687b      	ldr	r3, [r7, #4]
   12284:	60fb      	str	r3, [r7, #12]
   12286:	68fb      	ldr	r3, [r7, #12]
   12288:	781b      	ldrb	r3, [r3, #0]
   1228a:	2b00      	cmp	r3, #0
   1228c:	d003      	beq.n	12296 <_strlen(char const*)+0x1c>
   1228e:	68fb      	ldr	r3, [r7, #12]
   12290:	3301      	adds	r3, #1
   12292:	60fb      	str	r3, [r7, #12]
   12294:	e7f7      	b.n	12286 <_strlen(char const*)+0xc>
  return (unsigned int)(s - str);
   12296:	68fa      	ldr	r2, [r7, #12]
   12298:	687b      	ldr	r3, [r7, #4]
   1229a:	1ad3      	subs	r3, r2, r3
}
   1229c:	4618      	mov	r0, r3
   1229e:	3714      	adds	r7, #20
   122a0:	46bd      	mov	sp, r7
   122a2:	f85d 7b04 	ldr.w	r7, [sp], #4
   122a6:	4770      	bx	lr

000122a8 <_is_digit(char)>:


// internal test if char is a digit (0-9)
// \return true if char is a digit
static inline bool _is_digit(char ch)
{
   122a8:	b480      	push	{r7}
   122aa:	b083      	sub	sp, #12
   122ac:	af00      	add	r7, sp, #0
   122ae:	4603      	mov	r3, r0
   122b0:	71fb      	strb	r3, [r7, #7]
  return (ch >= '0') && (ch <= '9');
   122b2:	79fb      	ldrb	r3, [r7, #7]
   122b4:	2b2f      	cmp	r3, #47	; 0x2f
   122b6:	d904      	bls.n	122c2 <_is_digit(char)+0x1a>
   122b8:	79fb      	ldrb	r3, [r7, #7]
   122ba:	2b39      	cmp	r3, #57	; 0x39
   122bc:	d801      	bhi.n	122c2 <_is_digit(char)+0x1a>
   122be:	2301      	movs	r3, #1
   122c0:	e000      	b.n	122c4 <_is_digit(char)+0x1c>
   122c2:	2300      	movs	r3, #0
}
   122c4:	4618      	mov	r0, r3
   122c6:	370c      	adds	r7, #12
   122c8:	46bd      	mov	sp, r7
   122ca:	f85d 7b04 	ldr.w	r7, [sp], #4
   122ce:	4770      	bx	lr

000122d0 <_atoi(char const**)>:


// internal ASCII string to unsigned int conversion
static unsigned int _atoi(const char** str)
{
   122d0:	b580      	push	{r7, lr}
   122d2:	b084      	sub	sp, #16
   122d4:	af00      	add	r7, sp, #0
   122d6:	6078      	str	r0, [r7, #4]
  unsigned int i = 0U;
   122d8:	2300      	movs	r3, #0
   122da:	60fb      	str	r3, [r7, #12]
  while (_is_digit(**str)) {
   122dc:	687b      	ldr	r3, [r7, #4]
   122de:	681b      	ldr	r3, [r3, #0]
   122e0:	781b      	ldrb	r3, [r3, #0]
   122e2:	4618      	mov	r0, r3
   122e4:	f7ff ffe0 	bl	122a8 <_is_digit(char)>
   122e8:	4603      	mov	r3, r0
   122ea:	2b00      	cmp	r3, #0
   122ec:	d00f      	beq.n	1230e <_atoi(char const**)+0x3e>
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
   122ee:	68fa      	ldr	r2, [r7, #12]
   122f0:	4613      	mov	r3, r2
   122f2:	009b      	lsls	r3, r3, #2
   122f4:	4413      	add	r3, r2
   122f6:	005b      	lsls	r3, r3, #1
   122f8:	4618      	mov	r0, r3
   122fa:	687b      	ldr	r3, [r7, #4]
   122fc:	681b      	ldr	r3, [r3, #0]
   122fe:	1c59      	adds	r1, r3, #1
   12300:	687a      	ldr	r2, [r7, #4]
   12302:	6011      	str	r1, [r2, #0]
   12304:	781b      	ldrb	r3, [r3, #0]
   12306:	4403      	add	r3, r0
   12308:	3b30      	subs	r3, #48	; 0x30
   1230a:	60fb      	str	r3, [r7, #12]
  while (_is_digit(**str)) {
   1230c:	e7e6      	b.n	122dc <_atoi(char const**)+0xc>
  }
  return i;
   1230e:	68fb      	ldr	r3, [r7, #12]
}
   12310:	4618      	mov	r0, r3
   12312:	3710      	adds	r7, #16
   12314:	46bd      	mov	sp, r7
   12316:	bd80      	pop	{r7, pc}

00012318 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)>:


// internal itoa format
static size_t _ntoa_format(out_fct_type out, char* buffer, size_t idx, size_t maxlen, char* buf, size_t len, bool negative, unsigned int base, unsigned int prec, unsigned int width, unsigned int flags)
{
   12318:	b590      	push	{r4, r7, lr}
   1231a:	b089      	sub	sp, #36	; 0x24
   1231c:	af00      	add	r7, sp, #0
   1231e:	60f8      	str	r0, [r7, #12]
   12320:	60b9      	str	r1, [r7, #8]
   12322:	607a      	str	r2, [r7, #4]
   12324:	603b      	str	r3, [r7, #0]
  const size_t start_idx = idx;
   12326:	687b      	ldr	r3, [r7, #4]
   12328:	617b      	str	r3, [r7, #20]

  // pad leading zeros
  while (!(flags & FLAGS_LEFT) && (len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   1232a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   1232c:	f003 0302 	and.w	r3, r3, #2
   12330:	2b00      	cmp	r3, #0
   12332:	d10e      	bne.n	12352 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x3a>
   12334:	6b7a      	ldr	r2, [r7, #52]	; 0x34
   12336:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   12338:	429a      	cmp	r2, r3
   1233a:	d20a      	bcs.n	12352 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x3a>
   1233c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   1233e:	2b1f      	cmp	r3, #31
   12340:	d807      	bhi.n	12352 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x3a>
    buf[len++] = '0';
   12342:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   12344:	1c5a      	adds	r2, r3, #1
   12346:	637a      	str	r2, [r7, #52]	; 0x34
   12348:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   1234a:	4413      	add	r3, r2
   1234c:	2230      	movs	r2, #48	; 0x30
   1234e:	701a      	strb	r2, [r3, #0]
  while (!(flags & FLAGS_LEFT) && (len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   12350:	e7eb      	b.n	1232a <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x12>
  }
  while (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   12352:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   12354:	f003 0302 	and.w	r3, r3, #2
   12358:	2b00      	cmp	r3, #0
   1235a:	d113      	bne.n	12384 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x6c>
   1235c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   1235e:	f003 0301 	and.w	r3, r3, #1
   12362:	2b00      	cmp	r3, #0
   12364:	d00e      	beq.n	12384 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x6c>
   12366:	6b7a      	ldr	r2, [r7, #52]	; 0x34
   12368:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   1236a:	429a      	cmp	r2, r3
   1236c:	d20a      	bcs.n	12384 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x6c>
   1236e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   12370:	2b1f      	cmp	r3, #31
   12372:	d807      	bhi.n	12384 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x6c>
    buf[len++] = '0';
   12374:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   12376:	1c5a      	adds	r2, r3, #1
   12378:	637a      	str	r2, [r7, #52]	; 0x34
   1237a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   1237c:	4413      	add	r3, r2
   1237e:	2230      	movs	r2, #48	; 0x30
   12380:	701a      	strb	r2, [r3, #0]
  while (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   12382:	e7e6      	b.n	12352 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x3a>
  }

  // handle hash
  if (flags & FLAGS_HASH) {
   12384:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   12386:	f003 0310 	and.w	r3, r3, #16
   1238a:	2b00      	cmp	r3, #0
   1238c:	d058      	beq.n	12440 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x128>
    if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
   1238e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   12390:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   12394:	2b00      	cmp	r3, #0
   12396:	d116      	bne.n	123c6 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xae>
   12398:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   1239a:	2b00      	cmp	r3, #0
   1239c:	d013      	beq.n	123c6 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xae>
   1239e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
   123a0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   123a2:	429a      	cmp	r2, r3
   123a4:	d003      	beq.n	123ae <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x96>
   123a6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
   123a8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   123aa:	429a      	cmp	r2, r3
   123ac:	d10b      	bne.n	123c6 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xae>
      len--;
   123ae:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   123b0:	3b01      	subs	r3, #1
   123b2:	637b      	str	r3, [r7, #52]	; 0x34
      if (len && (base == 16U)) {
   123b4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   123b6:	2b00      	cmp	r3, #0
   123b8:	d005      	beq.n	123c6 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xae>
   123ba:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   123bc:	2b10      	cmp	r3, #16
   123be:	d102      	bne.n	123c6 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xae>
        len--;
   123c0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   123c2:	3b01      	subs	r3, #1
   123c4:	637b      	str	r3, [r7, #52]	; 0x34
      }
    }
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   123c6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   123c8:	2b10      	cmp	r3, #16
   123ca:	d10f      	bne.n	123ec <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xd4>
   123cc:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   123ce:	f003 0320 	and.w	r3, r3, #32
   123d2:	2b00      	cmp	r3, #0
   123d4:	d10a      	bne.n	123ec <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xd4>
   123d6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   123d8:	2b1f      	cmp	r3, #31
   123da:	d807      	bhi.n	123ec <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xd4>
      buf[len++] = 'x';
   123dc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   123de:	1c5a      	adds	r2, r3, #1
   123e0:	637a      	str	r2, [r7, #52]	; 0x34
   123e2:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   123e4:	4413      	add	r3, r2
   123e6:	2278      	movs	r2, #120	; 0x78
   123e8:	701a      	strb	r2, [r3, #0]
   123ea:	e01f      	b.n	1242c <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x114>
    }
    else if ((base == 16U) && (flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   123ec:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   123ee:	2b10      	cmp	r3, #16
   123f0:	d10f      	bne.n	12412 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xfa>
   123f2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   123f4:	f003 0320 	and.w	r3, r3, #32
   123f8:	2b00      	cmp	r3, #0
   123fa:	d00a      	beq.n	12412 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xfa>
   123fc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   123fe:	2b1f      	cmp	r3, #31
   12400:	d807      	bhi.n	12412 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xfa>
      buf[len++] = 'X';
   12402:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   12404:	1c5a      	adds	r2, r3, #1
   12406:	637a      	str	r2, [r7, #52]	; 0x34
   12408:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   1240a:	4413      	add	r3, r2
   1240c:	2258      	movs	r2, #88	; 0x58
   1240e:	701a      	strb	r2, [r3, #0]
   12410:	e00c      	b.n	1242c <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x114>
    }
    else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   12412:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   12414:	2b02      	cmp	r3, #2
   12416:	d109      	bne.n	1242c <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x114>
   12418:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   1241a:	2b1f      	cmp	r3, #31
   1241c:	d806      	bhi.n	1242c <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x114>
      buf[len++] = 'b';
   1241e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   12420:	1c5a      	adds	r2, r3, #1
   12422:	637a      	str	r2, [r7, #52]	; 0x34
   12424:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   12426:	4413      	add	r3, r2
   12428:	2262      	movs	r2, #98	; 0x62
   1242a:	701a      	strb	r2, [r3, #0]
    }
    if (len < PRINTF_NTOA_BUFFER_SIZE) {
   1242c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   1242e:	2b1f      	cmp	r3, #31
   12430:	d806      	bhi.n	12440 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x128>
      buf[len++] = '0';
   12432:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   12434:	1c5a      	adds	r2, r3, #1
   12436:	637a      	str	r2, [r7, #52]	; 0x34
   12438:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   1243a:	4413      	add	r3, r2
   1243c:	2230      	movs	r2, #48	; 0x30
   1243e:	701a      	strb	r2, [r3, #0]
    }
  }

  // handle sign
  if (len && (len == width) && (negative || (flags & FLAGS_PLUS) || (flags & FLAGS_SPACE))) {
   12440:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   12442:	2b00      	cmp	r3, #0
   12444:	d014      	beq.n	12470 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x158>
   12446:	6b7a      	ldr	r2, [r7, #52]	; 0x34
   12448:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   1244a:	429a      	cmp	r2, r3
   1244c:	d110      	bne.n	12470 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x158>
   1244e:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
   12452:	2b00      	cmp	r3, #0
   12454:	d109      	bne.n	1246a <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x152>
   12456:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   12458:	f003 0304 	and.w	r3, r3, #4
   1245c:	2b00      	cmp	r3, #0
   1245e:	d104      	bne.n	1246a <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x152>
   12460:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   12462:	f003 0308 	and.w	r3, r3, #8
   12466:	2b00      	cmp	r3, #0
   12468:	d002      	beq.n	12470 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x158>
    len--;
   1246a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   1246c:	3b01      	subs	r3, #1
   1246e:	637b      	str	r3, [r7, #52]	; 0x34
  }
  if (len < PRINTF_NTOA_BUFFER_SIZE) {
   12470:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   12472:	2b1f      	cmp	r3, #31
   12474:	d824      	bhi.n	124c0 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1a8>
    if (negative) {
   12476:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
   1247a:	2b00      	cmp	r3, #0
   1247c:	d007      	beq.n	1248e <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x176>
      buf[len++] = '-';
   1247e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   12480:	1c5a      	adds	r2, r3, #1
   12482:	637a      	str	r2, [r7, #52]	; 0x34
   12484:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   12486:	4413      	add	r3, r2
   12488:	222d      	movs	r2, #45	; 0x2d
   1248a:	701a      	strb	r2, [r3, #0]
   1248c:	e018      	b.n	124c0 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1a8>
    }
    else if (flags & FLAGS_PLUS) {
   1248e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   12490:	f003 0304 	and.w	r3, r3, #4
   12494:	2b00      	cmp	r3, #0
   12496:	d007      	beq.n	124a8 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x190>
      buf[len++] = '+';  // ignore the space if the '+' exists
   12498:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   1249a:	1c5a      	adds	r2, r3, #1
   1249c:	637a      	str	r2, [r7, #52]	; 0x34
   1249e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   124a0:	4413      	add	r3, r2
   124a2:	222b      	movs	r2, #43	; 0x2b
   124a4:	701a      	strb	r2, [r3, #0]
   124a6:	e00b      	b.n	124c0 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1a8>
    }
    else if (flags & FLAGS_SPACE) {
   124a8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   124aa:	f003 0308 	and.w	r3, r3, #8
   124ae:	2b00      	cmp	r3, #0
   124b0:	d006      	beq.n	124c0 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1a8>
      buf[len++] = ' ';
   124b2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   124b4:	1c5a      	adds	r2, r3, #1
   124b6:	637a      	str	r2, [r7, #52]	; 0x34
   124b8:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   124ba:	4413      	add	r3, r2
   124bc:	2220      	movs	r2, #32
   124be:	701a      	strb	r2, [r3, #0]
    }
  }

  // pad spaces up to given width
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
   124c0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   124c2:	f003 0302 	and.w	r3, r3, #2
   124c6:	2b00      	cmp	r3, #0
   124c8:	d116      	bne.n	124f8 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1e0>
   124ca:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   124cc:	f003 0301 	and.w	r3, r3, #1
   124d0:	2b00      	cmp	r3, #0
   124d2:	d111      	bne.n	124f8 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1e0>
    for (size_t i = len; i < width; i++) {
   124d4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   124d6:	61fb      	str	r3, [r7, #28]
   124d8:	69fa      	ldr	r2, [r7, #28]
   124da:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   124dc:	429a      	cmp	r2, r3
   124de:	d20b      	bcs.n	124f8 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1e0>
      out(' ', buffer, idx++, maxlen);
   124e0:	687a      	ldr	r2, [r7, #4]
   124e2:	1c53      	adds	r3, r2, #1
   124e4:	607b      	str	r3, [r7, #4]
   124e6:	68fc      	ldr	r4, [r7, #12]
   124e8:	683b      	ldr	r3, [r7, #0]
   124ea:	68b9      	ldr	r1, [r7, #8]
   124ec:	2020      	movs	r0, #32
   124ee:	47a0      	blx	r4
    for (size_t i = len; i < width; i++) {
   124f0:	69fb      	ldr	r3, [r7, #28]
   124f2:	3301      	adds	r3, #1
   124f4:	61fb      	str	r3, [r7, #28]
   124f6:	e7ef      	b.n	124d8 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1c0>
    }
  }

  // reverse string
  for (size_t i = 0U; i < len; i++) {
   124f8:	2300      	movs	r3, #0
   124fa:	61bb      	str	r3, [r7, #24]
   124fc:	69ba      	ldr	r2, [r7, #24]
   124fe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   12500:	429a      	cmp	r2, r3
   12502:	d211      	bcs.n	12528 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x210>
    out(buf[len - i - 1U], buffer, idx++, maxlen);
   12504:	6b7a      	ldr	r2, [r7, #52]	; 0x34
   12506:	69bb      	ldr	r3, [r7, #24]
   12508:	1ad3      	subs	r3, r2, r3
   1250a:	3b01      	subs	r3, #1
   1250c:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   1250e:	4413      	add	r3, r2
   12510:	7818      	ldrb	r0, [r3, #0]
   12512:	687a      	ldr	r2, [r7, #4]
   12514:	1c53      	adds	r3, r2, #1
   12516:	607b      	str	r3, [r7, #4]
   12518:	68fc      	ldr	r4, [r7, #12]
   1251a:	683b      	ldr	r3, [r7, #0]
   1251c:	68b9      	ldr	r1, [r7, #8]
   1251e:	47a0      	blx	r4
  for (size_t i = 0U; i < len; i++) {
   12520:	69bb      	ldr	r3, [r7, #24]
   12522:	3301      	adds	r3, #1
   12524:	61bb      	str	r3, [r7, #24]
   12526:	e7e9      	b.n	124fc <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1e4>
  }

  // append pad spaces up to given width
  if (flags & FLAGS_LEFT) {
   12528:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   1252a:	f003 0302 	and.w	r3, r3, #2
   1252e:	2b00      	cmp	r3, #0
   12530:	d00e      	beq.n	12550 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x238>
    while (idx - start_idx < width) {
   12532:	687a      	ldr	r2, [r7, #4]
   12534:	697b      	ldr	r3, [r7, #20]
   12536:	1ad3      	subs	r3, r2, r3
   12538:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   1253a:	429a      	cmp	r2, r3
   1253c:	d908      	bls.n	12550 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x238>
      out(' ', buffer, idx++, maxlen);
   1253e:	687a      	ldr	r2, [r7, #4]
   12540:	1c53      	adds	r3, r2, #1
   12542:	607b      	str	r3, [r7, #4]
   12544:	68fc      	ldr	r4, [r7, #12]
   12546:	683b      	ldr	r3, [r7, #0]
   12548:	68b9      	ldr	r1, [r7, #8]
   1254a:	2020      	movs	r0, #32
   1254c:	47a0      	blx	r4
    while (idx - start_idx < width) {
   1254e:	e7f0      	b.n	12532 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x21a>
    }
  }

  return idx;
   12550:	687b      	ldr	r3, [r7, #4]
}
   12552:	4618      	mov	r0, r3
   12554:	3724      	adds	r7, #36	; 0x24
   12556:	46bd      	mov	sp, r7
   12558:	bd90      	pop	{r4, r7, pc}

0001255a <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)>:


// internal itoa for 'long' type
static size_t _ntoa_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long value, bool negative, unsigned long base, unsigned int prec, unsigned int width, unsigned int flags)
{
   1255a:	b580      	push	{r7, lr}
   1255c:	b096      	sub	sp, #88	; 0x58
   1255e:	af08      	add	r7, sp, #32
   12560:	60f8      	str	r0, [r7, #12]
   12562:	60b9      	str	r1, [r7, #8]
   12564:	607a      	str	r2, [r7, #4]
   12566:	603b      	str	r3, [r7, #0]
  char buf[PRINTF_NTOA_BUFFER_SIZE];
  size_t len = 0U;
   12568:	2300      	movs	r3, #0
   1256a:	637b      	str	r3, [r7, #52]	; 0x34

  // no hash for 0 values
  if (!value) {
   1256c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   1256e:	2b00      	cmp	r3, #0
   12570:	d103      	bne.n	1257a <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x20>
    flags &= ~FLAGS_HASH;
   12572:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   12574:	f023 0310 	bic.w	r3, r3, #16
   12578:	657b      	str	r3, [r7, #84]	; 0x54
  }

  // write if precision != 0 and value is != 0
  if (!(flags & FLAGS_PRECISION) || value) {
   1257a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   1257c:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   12580:	2b00      	cmp	r3, #0
   12582:	d002      	beq.n	1258a <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x30>
   12584:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   12586:	2b00      	cmp	r3, #0
   12588:	d034      	beq.n	125f4 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x9a>
    do {
      const char digit = (char)(value % base);
   1258a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   1258c:	6cba      	ldr	r2, [r7, #72]	; 0x48
   1258e:	fbb3 f2f2 	udiv	r2, r3, r2
   12592:	6cb9      	ldr	r1, [r7, #72]	; 0x48
   12594:	fb01 f202 	mul.w	r2, r1, r2
   12598:	1a9b      	subs	r3, r3, r2
   1259a:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
   1259e:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
   125a2:	2b09      	cmp	r3, #9
   125a4:	d804      	bhi.n	125b0 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x56>
   125a6:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
   125aa:	3330      	adds	r3, #48	; 0x30
   125ac:	b2da      	uxtb	r2, r3
   125ae:	e00d      	b.n	125cc <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x72>
   125b0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   125b2:	f003 0320 	and.w	r3, r3, #32
   125b6:	2b00      	cmp	r3, #0
   125b8:	d001      	beq.n	125be <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x64>
   125ba:	2241      	movs	r2, #65	; 0x41
   125bc:	e000      	b.n	125c0 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x66>
   125be:	2261      	movs	r2, #97	; 0x61
   125c0:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
   125c4:	4413      	add	r3, r2
   125c6:	b2db      	uxtb	r3, r3
   125c8:	3b0a      	subs	r3, #10
   125ca:	b2da      	uxtb	r2, r3
   125cc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   125ce:	1c59      	adds	r1, r3, #1
   125d0:	6379      	str	r1, [r7, #52]	; 0x34
   125d2:	f107 0138 	add.w	r1, r7, #56	; 0x38
   125d6:	440b      	add	r3, r1
   125d8:	f803 2c28 	strb.w	r2, [r3, #-40]
      value /= base;
   125dc:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   125de:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   125e0:	fbb2 f3f3 	udiv	r3, r2, r3
   125e4:	643b      	str	r3, [r7, #64]	; 0x40
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
   125e6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   125e8:	2b00      	cmp	r3, #0
   125ea:	d003      	beq.n	125f4 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x9a>
   125ec:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   125ee:	2b1f      	cmp	r3, #31
   125f0:	d800      	bhi.n	125f4 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x9a>
    do {
   125f2:	e7ca      	b.n	1258a <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x30>
  }

  return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
   125f4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   125f6:	9306      	str	r3, [sp, #24]
   125f8:	6d3b      	ldr	r3, [r7, #80]	; 0x50
   125fa:	9305      	str	r3, [sp, #20]
   125fc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   125fe:	9304      	str	r3, [sp, #16]
   12600:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   12602:	9303      	str	r3, [sp, #12]
   12604:	f897 3044 	ldrb.w	r3, [r7, #68]	; 0x44
   12608:	9302      	str	r3, [sp, #8]
   1260a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   1260c:	9301      	str	r3, [sp, #4]
   1260e:	f107 0310 	add.w	r3, r7, #16
   12612:	9300      	str	r3, [sp, #0]
   12614:	683b      	ldr	r3, [r7, #0]
   12616:	687a      	ldr	r2, [r7, #4]
   12618:	68b9      	ldr	r1, [r7, #8]
   1261a:	68f8      	ldr	r0, [r7, #12]
   1261c:	f7ff fe7c 	bl	12318 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)>
   12620:	4603      	mov	r3, r0
}
   12622:	4618      	mov	r0, r3
   12624:	3738      	adds	r7, #56	; 0x38
   12626:	46bd      	mov	sp, r7
   12628:	bd80      	pop	{r7, pc}

0001262a <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)>:


// internal itoa for 'long long' type
#if defined(PRINTF_SUPPORT_LONG_LONG)
static size_t _ntoa_long_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long long value, bool negative, unsigned long long base, unsigned int prec, unsigned int width, unsigned int flags)
{
   1262a:	b590      	push	{r4, r7, lr}
   1262c:	b097      	sub	sp, #92	; 0x5c
   1262e:	af08      	add	r7, sp, #32
   12630:	60f8      	str	r0, [r7, #12]
   12632:	60b9      	str	r1, [r7, #8]
   12634:	607a      	str	r2, [r7, #4]
   12636:	603b      	str	r3, [r7, #0]
  char buf[PRINTF_NTOA_BUFFER_SIZE];
  size_t len = 0U;
   12638:	2300      	movs	r3, #0
   1263a:	637b      	str	r3, [r7, #52]	; 0x34

  // no hash for 0 values
  if (!value) {
   1263c:	e9d7 3412 	ldrd	r3, r4, [r7, #72]	; 0x48
   12640:	4323      	orrs	r3, r4
   12642:	d103      	bne.n	1264c <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x22>
    flags &= ~FLAGS_HASH;
   12644:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   12646:	f023 0310 	bic.w	r3, r3, #16
   1264a:	66bb      	str	r3, [r7, #104]	; 0x68
  }

  // write if precision != 0 and value is != 0
  if (!(flags & FLAGS_PRECISION) || value) {
   1264c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   1264e:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   12652:	2b00      	cmp	r3, #0
   12654:	d003      	beq.n	1265e <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x34>
   12656:	e9d7 3412 	ldrd	r3, r4, [r7, #72]	; 0x48
   1265a:	4323      	orrs	r3, r4
   1265c:	d03a      	beq.n	126d4 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0xaa>
    do {
      const char digit = (char)(value % base);
   1265e:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	; 0x48
   12662:	e9d7 2316 	ldrd	r2, r3, [r7, #88]	; 0x58
   12666:	f000 ff5f 	bl	13528 <__aeabi_uldivmod>
   1266a:	461c      	mov	r4, r3
   1266c:	4613      	mov	r3, r2
   1266e:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
   12672:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
   12676:	2b09      	cmp	r3, #9
   12678:	d804      	bhi.n	12684 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x5a>
   1267a:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
   1267e:	3330      	adds	r3, #48	; 0x30
   12680:	b2da      	uxtb	r2, r3
   12682:	e00d      	b.n	126a0 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x76>
   12684:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   12686:	f003 0320 	and.w	r3, r3, #32
   1268a:	2b00      	cmp	r3, #0
   1268c:	d001      	beq.n	12692 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x68>
   1268e:	2241      	movs	r2, #65	; 0x41
   12690:	e000      	b.n	12694 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x6a>
   12692:	2261      	movs	r2, #97	; 0x61
   12694:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
   12698:	4413      	add	r3, r2
   1269a:	b2db      	uxtb	r3, r3
   1269c:	3b0a      	subs	r3, #10
   1269e:	b2da      	uxtb	r2, r3
   126a0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   126a2:	1c59      	adds	r1, r3, #1
   126a4:	6379      	str	r1, [r7, #52]	; 0x34
   126a6:	f107 0138 	add.w	r1, r7, #56	; 0x38
   126aa:	440b      	add	r3, r1
   126ac:	f803 2c28 	strb.w	r2, [r3, #-40]
      value /= base;
   126b0:	e9d7 2316 	ldrd	r2, r3, [r7, #88]	; 0x58
   126b4:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	; 0x48
   126b8:	f000 ff36 	bl	13528 <__aeabi_uldivmod>
   126bc:	4603      	mov	r3, r0
   126be:	460c      	mov	r4, r1
   126c0:	e9c7 3412 	strd	r3, r4, [r7, #72]	; 0x48
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
   126c4:	e9d7 3412 	ldrd	r3, r4, [r7, #72]	; 0x48
   126c8:	4323      	orrs	r3, r4
   126ca:	d003      	beq.n	126d4 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0xaa>
   126cc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   126ce:	2b1f      	cmp	r3, #31
   126d0:	d800      	bhi.n	126d4 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0xaa>
    do {
   126d2:	e7c4      	b.n	1265e <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x34>
  }

  return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
   126d4:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   126d6:	6eba      	ldr	r2, [r7, #104]	; 0x68
   126d8:	9206      	str	r2, [sp, #24]
   126da:	6e7a      	ldr	r2, [r7, #100]	; 0x64
   126dc:	9205      	str	r2, [sp, #20]
   126de:	6e3a      	ldr	r2, [r7, #96]	; 0x60
   126e0:	9204      	str	r2, [sp, #16]
   126e2:	9303      	str	r3, [sp, #12]
   126e4:	f897 3050 	ldrb.w	r3, [r7, #80]	; 0x50
   126e8:	9302      	str	r3, [sp, #8]
   126ea:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   126ec:	9301      	str	r3, [sp, #4]
   126ee:	f107 0310 	add.w	r3, r7, #16
   126f2:	9300      	str	r3, [sp, #0]
   126f4:	683b      	ldr	r3, [r7, #0]
   126f6:	687a      	ldr	r2, [r7, #4]
   126f8:	68b9      	ldr	r1, [r7, #8]
   126fa:	68f8      	ldr	r0, [r7, #12]
   126fc:	f7ff fe0c 	bl	12318 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)>
   12700:	4603      	mov	r3, r0
}
   12702:	4618      	mov	r0, r3
   12704:	373c      	adds	r7, #60	; 0x3c
   12706:	46bd      	mov	sp, r7
   12708:	bd90      	pop	{r4, r7, pc}
   1270a:	Address 0x000000000001270a is out of bounds.


0001270c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)>:
#endif  // PRINTF_SUPPORT_LONG_LONG


#if defined(PRINTF_SUPPORT_FLOAT)
static size_t _ftoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value_param, unsigned int prec, unsigned int width, unsigned int flags)
{
   1270c:	b590      	push	{r4, r7, lr}
   1270e:	b09b      	sub	sp, #108	; 0x6c
   12710:	af00      	add	r7, sp, #0
   12712:	6178      	str	r0, [r7, #20]
   12714:	6139      	str	r1, [r7, #16]
   12716:	60fa      	str	r2, [r7, #12]
   12718:	60bb      	str	r3, [r7, #8]
   1271a:	ed87 0b00 	vstr	d0, [r7]
  const size_t start_idx = idx;
   1271e:	68fb      	ldr	r3, [r7, #12]
   12720:	647b      	str	r3, [r7, #68]	; 0x44

  float value = static_cast<float>(value_param);
   12722:	e9d7 0100 	ldrd	r0, r1, [r7]
   12726:	f000 feaf 	bl	13488 <__aeabi_d2f>
   1272a:	4603      	mov	r3, r0
   1272c:	667b      	str	r3, [r7, #100]	; 0x64

  char buf[PRINTF_FTOA_BUFFER_SIZE];
  size_t len  = 0U;
   1272e:	2300      	movs	r3, #0
   12730:	663b      	str	r3, [r7, #96]	; 0x60
  float diff = 0.0;
   12732:	f04f 0300 	mov.w	r3, #0
   12736:	643b      	str	r3, [r7, #64]	; 0x40

  // if input is larger than thres_max, revert to exponential
  const float thres_max = (float)0x7FFFFFFF;
   12738:	f04f 439e 	mov.w	r3, #1325400064	; 0x4f000000
   1273c:	63fb      	str	r3, [r7, #60]	; 0x3c

  // powers of 10
  static const float pow10[] = { 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000 };

  // test for negative
  bool negative = false;
   1273e:	2300      	movs	r3, #0
   12740:	f887 305f 	strb.w	r3, [r7, #95]	; 0x5f
  if (value < 0) {
   12744:	edd7 7a19 	vldr	s15, [r7, #100]	; 0x64
   12748:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   1274c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   12750:	d50a      	bpl.n	12768 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x5c>
    negative = true;
   12752:	2301      	movs	r3, #1
   12754:	f887 305f 	strb.w	r3, [r7, #95]	; 0x5f
    value = 0 - value;
   12758:	ed9f 7aab 	vldr	s14, [pc, #684]	; 12a08 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x2fc>
   1275c:	edd7 7a19 	vldr	s15, [r7, #100]	; 0x64
   12760:	ee77 7a67 	vsub.f32	s15, s14, s15
   12764:	edc7 7a19 	vstr	s15, [r7, #100]	; 0x64
  }

  // set default precision to 6, if not set explicitly
  if (!(flags & FLAGS_PRECISION)) {
   12768:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
   1276c:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   12770:	2b00      	cmp	r3, #0
   12772:	d101      	bne.n	12778 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x6c>
    prec = 6U;
   12774:	2306      	movs	r3, #6
   12776:	67bb      	str	r3, [r7, #120]	; 0x78
  }
  // limit precision to 9, cause a prec >= 10 can lead to overflow errors
  while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
   12778:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   1277a:	2b1f      	cmp	r3, #31
   1277c:	d80f      	bhi.n	1279e <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x92>
   1277e:	6fbb      	ldr	r3, [r7, #120]	; 0x78
   12780:	2b09      	cmp	r3, #9
   12782:	d90c      	bls.n	1279e <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x92>
    buf[len++] = '0';
   12784:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   12786:	1c5a      	adds	r2, r3, #1
   12788:	663a      	str	r2, [r7, #96]	; 0x60
   1278a:	f107 0268 	add.w	r2, r7, #104	; 0x68
   1278e:	4413      	add	r3, r2
   12790:	2230      	movs	r2, #48	; 0x30
   12792:	f803 2c50 	strb.w	r2, [r3, #-80]
    prec--;
   12796:	6fbb      	ldr	r3, [r7, #120]	; 0x78
   12798:	3b01      	subs	r3, #1
   1279a:	67bb      	str	r3, [r7, #120]	; 0x78
  while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
   1279c:	e7ec      	b.n	12778 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x6c>
  }

  int whole = (int)value;
   1279e:	edd7 7a19 	vldr	s15, [r7, #100]	; 0x64
   127a2:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   127a6:	ee17 3a90 	vmov	r3, s15
   127aa:	65bb      	str	r3, [r7, #88]	; 0x58
  float tmp = (value - whole) * pow10[prec];
   127ac:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   127ae:	ee07 3a90 	vmov	s15, r3
   127b2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   127b6:	ed97 7a19 	vldr	s14, [r7, #100]	; 0x64
   127ba:	ee37 7a67 	vsub.f32	s14, s14, s15
   127be:	4a93      	ldr	r2, [pc, #588]	; (12a0c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x300>)
   127c0:	6fbb      	ldr	r3, [r7, #120]	; 0x78
   127c2:	009b      	lsls	r3, r3, #2
   127c4:	4413      	add	r3, r2
   127c6:	edd3 7a00 	vldr	s15, [r3]
   127ca:	ee67 7a27 	vmul.f32	s15, s14, s15
   127ce:	edc7 7a0e 	vstr	s15, [r7, #56]	; 0x38
  unsigned long frac = (unsigned long)tmp;
   127d2:	edd7 7a0e 	vldr	s15, [r7, #56]	; 0x38
   127d6:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   127da:	ee17 3a90 	vmov	r3, s15
   127de:	657b      	str	r3, [r7, #84]	; 0x54
  diff = tmp - frac;
   127e0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   127e2:	ee07 3a90 	vmov	s15, r3
   127e6:	eef8 7a67 	vcvt.f32.u32	s15, s15
   127ea:	ed97 7a0e 	vldr	s14, [r7, #56]	; 0x38
   127ee:	ee77 7a67 	vsub.f32	s15, s14, s15
   127f2:	edc7 7a10 	vstr	s15, [r7, #64]	; 0x40

  if (diff > 0.5) {
   127f6:	edd7 7a10 	vldr	s15, [r7, #64]	; 0x40
   127fa:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
   127fe:	eef4 7ac7 	vcmpe.f32	s15, s14
   12802:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   12806:	dd18      	ble.n	1283a <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x12e>
    ++frac;
   12808:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   1280a:	3301      	adds	r3, #1
   1280c:	657b      	str	r3, [r7, #84]	; 0x54
    // handle rollover, e.g. case 0.99 with prec 1 is 1.0
    if (frac >= pow10[prec]) {
   1280e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   12810:	ee07 3a90 	vmov	s15, r3
   12814:	eeb8 7a67 	vcvt.f32.u32	s14, s15
   12818:	4a7c      	ldr	r2, [pc, #496]	; (12a0c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x300>)
   1281a:	6fbb      	ldr	r3, [r7, #120]	; 0x78
   1281c:	009b      	lsls	r3, r3, #2
   1281e:	4413      	add	r3, r2
   12820:	edd3 7a00 	vldr	s15, [r3]
   12824:	eeb4 7ae7 	vcmpe.f32	s14, s15
   12828:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1282c:	db19      	blt.n	12862 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x156>
      frac = 0;
   1282e:	2300      	movs	r3, #0
   12830:	657b      	str	r3, [r7, #84]	; 0x54
      ++whole;
   12832:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   12834:	3301      	adds	r3, #1
   12836:	65bb      	str	r3, [r7, #88]	; 0x58
   12838:	e013      	b.n	12862 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x156>
    }
  }
  else if ((diff == 0.5) && ((frac == 0U) || (frac & 1U))) {
   1283a:	edd7 7a10 	vldr	s15, [r7, #64]	; 0x40
   1283e:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
   12842:	eef4 7a47 	vcmp.f32	s15, s14
   12846:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1284a:	d10a      	bne.n	12862 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x156>
   1284c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   1284e:	2b00      	cmp	r3, #0
   12850:	d004      	beq.n	1285c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x150>
   12852:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   12854:	f003 0301 	and.w	r3, r3, #1
   12858:	2b00      	cmp	r3, #0
   1285a:	d002      	beq.n	12862 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x156>
    // if halfway, round up if odd, OR if last digit is 0
    ++frac;
   1285c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   1285e:	3301      	adds	r3, #1
   12860:	657b      	str	r3, [r7, #84]	; 0x54
  }

  // TBD: for very large numbers switch back to native sprintf for exponentials. Anyone want to write code to replace this?
  // Normal printf behavior is to print EVERY whole number digit which can be 100s of characters overflowing your buffers == bad
  if (value > thres_max) {
   12862:	edd7 7a19 	vldr	s15, [r7, #100]	; 0x64
   12866:	ed9f 7a6a 	vldr	s14, [pc, #424]	; 12a10 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x304>
   1286a:	eef4 7ac7 	vcmpe.f32	s15, s14
   1286e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   12872:	dd01      	ble.n	12878 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x16c>
    return 0U;
   12874:	2300      	movs	r3, #0
   12876:	e166      	b.n	12b46 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x43a>
  }

  if (prec == 0U) {
   12878:	6fbb      	ldr	r3, [r7, #120]	; 0x78
   1287a:	2b00      	cmp	r3, #0
   1287c:	d129      	bne.n	128d2 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x1c6>
    diff = value - (float)whole;
   1287e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   12880:	ee07 3a90 	vmov	s15, r3
   12884:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   12888:	ed97 7a19 	vldr	s14, [r7, #100]	; 0x64
   1288c:	ee77 7a67 	vsub.f32	s15, s14, s15
   12890:	edc7 7a10 	vstr	s15, [r7, #64]	; 0x40
    if (diff > 0.5) {
   12894:	edd7 7a10 	vldr	s15, [r7, #64]	; 0x40
   12898:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
   1289c:	eef4 7ac7 	vcmpe.f32	s15, s14
   128a0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   128a4:	dd03      	ble.n	128ae <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x1a2>
      // greater than 0.5, round up, e.g. 1.6 -> 2
      ++whole;
   128a6:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   128a8:	3301      	adds	r3, #1
   128aa:	65bb      	str	r3, [r7, #88]	; 0x58
   128ac:	e062      	b.n	12974 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x268>
    }
    else if ((diff == 0.5) && (whole & 1)) {
   128ae:	edd7 7a10 	vldr	s15, [r7, #64]	; 0x40
   128b2:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
   128b6:	eef4 7a47 	vcmp.f32	s15, s14
   128ba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   128be:	d159      	bne.n	12974 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x268>
   128c0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   128c2:	f003 0301 	and.w	r3, r3, #1
   128c6:	2b00      	cmp	r3, #0
   128c8:	d054      	beq.n	12974 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x268>
      // exactly 0.5 and ODD, then round up
      // 1.5 -> 2, but 2.5 -> 2
      ++whole;
   128ca:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   128cc:	3301      	adds	r3, #1
   128ce:	65bb      	str	r3, [r7, #88]	; 0x58
   128d0:	e050      	b.n	12974 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x268>
    }
  }
  else {
    unsigned int count = prec;
   128d2:	6fbb      	ldr	r3, [r7, #120]	; 0x78
   128d4:	653b      	str	r3, [r7, #80]	; 0x50
    // now do fractional part, as an unsigned number
    while (len < PRINTF_FTOA_BUFFER_SIZE) {
   128d6:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   128d8:	2b1f      	cmp	r3, #31
   128da:	d828      	bhi.n	1292e <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x222>
      --count;
   128dc:	6d3b      	ldr	r3, [r7, #80]	; 0x50
   128de:	3b01      	subs	r3, #1
   128e0:	653b      	str	r3, [r7, #80]	; 0x50
      buf[len++] = (char)(48U + (frac % 10U));
   128e2:	6d79      	ldr	r1, [r7, #84]	; 0x54
   128e4:	4b4b      	ldr	r3, [pc, #300]	; (12a14 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x308>)
   128e6:	fba3 2301 	umull	r2, r3, r3, r1
   128ea:	08da      	lsrs	r2, r3, #3
   128ec:	4613      	mov	r3, r2
   128ee:	009b      	lsls	r3, r3, #2
   128f0:	4413      	add	r3, r2
   128f2:	005b      	lsls	r3, r3, #1
   128f4:	1aca      	subs	r2, r1, r3
   128f6:	b2d3      	uxtb	r3, r2
   128f8:	3330      	adds	r3, #48	; 0x30
   128fa:	b2d9      	uxtb	r1, r3
   128fc:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   128fe:	1c5a      	adds	r2, r3, #1
   12900:	663a      	str	r2, [r7, #96]	; 0x60
   12902:	f107 0268 	add.w	r2, r7, #104	; 0x68
   12906:	4413      	add	r3, r2
   12908:	460a      	mov	r2, r1
   1290a:	f803 2c50 	strb.w	r2, [r3, #-80]
      if (!(frac /= 10U)) {
   1290e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   12910:	4a40      	ldr	r2, [pc, #256]	; (12a14 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x308>)
   12912:	fba2 2303 	umull	r2, r3, r2, r3
   12916:	08db      	lsrs	r3, r3, #3
   12918:	657b      	str	r3, [r7, #84]	; 0x54
   1291a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   1291c:	2b00      	cmp	r3, #0
   1291e:	bf0c      	ite	eq
   12920:	2301      	moveq	r3, #1
   12922:	2300      	movne	r3, #0
   12924:	b2db      	uxtb	r3, r3
   12926:	2b00      	cmp	r3, #0
   12928:	d100      	bne.n	1292c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x220>
    while (len < PRINTF_FTOA_BUFFER_SIZE) {
   1292a:	e7d4      	b.n	128d6 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x1ca>
        break;
   1292c:	bf00      	nop
      }
    }
    // add extra 0s
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
   1292e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   12930:	2b1f      	cmp	r3, #31
   12932:	d806      	bhi.n	12942 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x236>
   12934:	6d3b      	ldr	r3, [r7, #80]	; 0x50
   12936:	1e5a      	subs	r2, r3, #1
   12938:	653a      	str	r2, [r7, #80]	; 0x50
   1293a:	2b00      	cmp	r3, #0
   1293c:	d001      	beq.n	12942 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x236>
   1293e:	2301      	movs	r3, #1
   12940:	e000      	b.n	12944 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x238>
   12942:	2300      	movs	r3, #0
   12944:	2b00      	cmp	r3, #0
   12946:	d009      	beq.n	1295c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x250>
      buf[len++] = '0';
   12948:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   1294a:	1c5a      	adds	r2, r3, #1
   1294c:	663a      	str	r2, [r7, #96]	; 0x60
   1294e:	f107 0268 	add.w	r2, r7, #104	; 0x68
   12952:	4413      	add	r3, r2
   12954:	2230      	movs	r2, #48	; 0x30
   12956:	f803 2c50 	strb.w	r2, [r3, #-80]
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
   1295a:	e7e8      	b.n	1292e <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x222>
    }
    if (len < PRINTF_FTOA_BUFFER_SIZE) {
   1295c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   1295e:	2b1f      	cmp	r3, #31
   12960:	d808      	bhi.n	12974 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x268>
      // add decimal
      buf[len++] = '.';
   12962:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   12964:	1c5a      	adds	r2, r3, #1
   12966:	663a      	str	r2, [r7, #96]	; 0x60
   12968:	f107 0268 	add.w	r2, r7, #104	; 0x68
   1296c:	4413      	add	r3, r2
   1296e:	222e      	movs	r2, #46	; 0x2e
   12970:	f803 2c50 	strb.w	r2, [r3, #-80]
    }
  }

  // do whole part, number is reversed
  while (len < PRINTF_FTOA_BUFFER_SIZE) {
   12974:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   12976:	2b1f      	cmp	r3, #31
   12978:	d829      	bhi.n	129ce <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x2c2>
    buf[len++] = (char)(48 + (whole % 10));
   1297a:	6dba      	ldr	r2, [r7, #88]	; 0x58
   1297c:	4b26      	ldr	r3, [pc, #152]	; (12a18 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x30c>)
   1297e:	fb83 1302 	smull	r1, r3, r3, r2
   12982:	1099      	asrs	r1, r3, #2
   12984:	17d3      	asrs	r3, r2, #31
   12986:	1ac9      	subs	r1, r1, r3
   12988:	460b      	mov	r3, r1
   1298a:	009b      	lsls	r3, r3, #2
   1298c:	440b      	add	r3, r1
   1298e:	005b      	lsls	r3, r3, #1
   12990:	1ad1      	subs	r1, r2, r3
   12992:	b2cb      	uxtb	r3, r1
   12994:	3330      	adds	r3, #48	; 0x30
   12996:	b2d9      	uxtb	r1, r3
   12998:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   1299a:	1c5a      	adds	r2, r3, #1
   1299c:	663a      	str	r2, [r7, #96]	; 0x60
   1299e:	f107 0268 	add.w	r2, r7, #104	; 0x68
   129a2:	4413      	add	r3, r2
   129a4:	460a      	mov	r2, r1
   129a6:	f803 2c50 	strb.w	r2, [r3, #-80]
    if (!(whole /= 10)) {
   129aa:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   129ac:	4a1a      	ldr	r2, [pc, #104]	; (12a18 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x30c>)
   129ae:	fb82 1203 	smull	r1, r2, r2, r3
   129b2:	1092      	asrs	r2, r2, #2
   129b4:	17db      	asrs	r3, r3, #31
   129b6:	1ad3      	subs	r3, r2, r3
   129b8:	65bb      	str	r3, [r7, #88]	; 0x58
   129ba:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   129bc:	2b00      	cmp	r3, #0
   129be:	bf0c      	ite	eq
   129c0:	2301      	moveq	r3, #1
   129c2:	2300      	movne	r3, #0
   129c4:	b2db      	uxtb	r3, r3
   129c6:	2b00      	cmp	r3, #0
   129c8:	d100      	bne.n	129cc <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x2c0>
  while (len < PRINTF_FTOA_BUFFER_SIZE) {
   129ca:	e7d3      	b.n	12974 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x268>
      break;
   129cc:	bf00      	nop
    }
  }

  // pad leading zeros
  while (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
   129ce:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
   129d2:	f003 0302 	and.w	r3, r3, #2
   129d6:	2b00      	cmp	r3, #0
   129d8:	d120      	bne.n	12a1c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x310>
   129da:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
   129de:	f003 0301 	and.w	r3, r3, #1
   129e2:	2b00      	cmp	r3, #0
   129e4:	d01a      	beq.n	12a1c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x310>
   129e6:	6e3a      	ldr	r2, [r7, #96]	; 0x60
   129e8:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
   129ea:	429a      	cmp	r2, r3
   129ec:	d216      	bcs.n	12a1c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x310>
   129ee:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   129f0:	2b1f      	cmp	r3, #31
   129f2:	d813      	bhi.n	12a1c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x310>
    buf[len++] = '0';
   129f4:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   129f6:	1c5a      	adds	r2, r3, #1
   129f8:	663a      	str	r2, [r7, #96]	; 0x60
   129fa:	f107 0268 	add.w	r2, r7, #104	; 0x68
   129fe:	4413      	add	r3, r2
   12a00:	2230      	movs	r2, #48	; 0x30
   12a02:	f803 2c50 	strb.w	r2, [r3, #-80]
  while (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
   12a06:	e7e2      	b.n	129ce <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x2c2>
   12a08:	00000000 	.word	0x00000000
   12a0c:	00015c94 	.word	0x00015c94
   12a10:	4f000000 	.word	0x4f000000
   12a14:	cccccccd 	.word	0xcccccccd
   12a18:	66666667 	.word	0x66666667
  }

  // handle sign
  if ((len == width) && (negative || (flags & FLAGS_PLUS) || (flags & FLAGS_SPACE))) {
   12a1c:	6e3a      	ldr	r2, [r7, #96]	; 0x60
   12a1e:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
   12a20:	429a      	cmp	r2, r3
   12a22:	d112      	bne.n	12a4a <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x33e>
   12a24:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
   12a28:	2b00      	cmp	r3, #0
   12a2a:	d10b      	bne.n	12a44 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x338>
   12a2c:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
   12a30:	f003 0304 	and.w	r3, r3, #4
   12a34:	2b00      	cmp	r3, #0
   12a36:	d105      	bne.n	12a44 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x338>
   12a38:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
   12a3c:	f003 0308 	and.w	r3, r3, #8
   12a40:	2b00      	cmp	r3, #0
   12a42:	d002      	beq.n	12a4a <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x33e>
    len--;
   12a44:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   12a46:	3b01      	subs	r3, #1
   12a48:	663b      	str	r3, [r7, #96]	; 0x60
  }
  if (len < PRINTF_FTOA_BUFFER_SIZE) {
   12a4a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   12a4c:	2b1f      	cmp	r3, #31
   12a4e:	d82c      	bhi.n	12aaa <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x39e>
    if (negative) {
   12a50:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
   12a54:	2b00      	cmp	r3, #0
   12a56:	d009      	beq.n	12a6c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x360>
      buf[len++] = '-';
   12a58:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   12a5a:	1c5a      	adds	r2, r3, #1
   12a5c:	663a      	str	r2, [r7, #96]	; 0x60
   12a5e:	f107 0268 	add.w	r2, r7, #104	; 0x68
   12a62:	4413      	add	r3, r2
   12a64:	222d      	movs	r2, #45	; 0x2d
   12a66:	f803 2c50 	strb.w	r2, [r3, #-80]
   12a6a:	e01e      	b.n	12aaa <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x39e>
    }
    else if (flags & FLAGS_PLUS) {
   12a6c:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
   12a70:	f003 0304 	and.w	r3, r3, #4
   12a74:	2b00      	cmp	r3, #0
   12a76:	d009      	beq.n	12a8c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x380>
      buf[len++] = '+';  // ignore the space if the '+' exists
   12a78:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   12a7a:	1c5a      	adds	r2, r3, #1
   12a7c:	663a      	str	r2, [r7, #96]	; 0x60
   12a7e:	f107 0268 	add.w	r2, r7, #104	; 0x68
   12a82:	4413      	add	r3, r2
   12a84:	222b      	movs	r2, #43	; 0x2b
   12a86:	f803 2c50 	strb.w	r2, [r3, #-80]
   12a8a:	e00e      	b.n	12aaa <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x39e>
    }
    else if (flags & FLAGS_SPACE) {
   12a8c:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
   12a90:	f003 0308 	and.w	r3, r3, #8
   12a94:	2b00      	cmp	r3, #0
   12a96:	d008      	beq.n	12aaa <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x39e>
      buf[len++] = ' ';
   12a98:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   12a9a:	1c5a      	adds	r2, r3, #1
   12a9c:	663a      	str	r2, [r7, #96]	; 0x60
   12a9e:	f107 0268 	add.w	r2, r7, #104	; 0x68
   12aa2:	4413      	add	r3, r2
   12aa4:	2220      	movs	r2, #32
   12aa6:	f803 2c50 	strb.w	r2, [r3, #-80]
    }
  }

  // pad spaces up to given width
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
   12aaa:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
   12aae:	f003 0302 	and.w	r3, r3, #2
   12ab2:	2b00      	cmp	r3, #0
   12ab4:	d117      	bne.n	12ae6 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x3da>
   12ab6:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
   12aba:	f003 0301 	and.w	r3, r3, #1
   12abe:	2b00      	cmp	r3, #0
   12ac0:	d111      	bne.n	12ae6 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x3da>
    for (size_t i = len; i < width; i++) {
   12ac2:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   12ac4:	64fb      	str	r3, [r7, #76]	; 0x4c
   12ac6:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
   12ac8:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
   12aca:	429a      	cmp	r2, r3
   12acc:	d20b      	bcs.n	12ae6 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x3da>
      out(' ', buffer, idx++, maxlen);
   12ace:	68fa      	ldr	r2, [r7, #12]
   12ad0:	1c53      	adds	r3, r2, #1
   12ad2:	60fb      	str	r3, [r7, #12]
   12ad4:	697c      	ldr	r4, [r7, #20]
   12ad6:	68bb      	ldr	r3, [r7, #8]
   12ad8:	6939      	ldr	r1, [r7, #16]
   12ada:	2020      	movs	r0, #32
   12adc:	47a0      	blx	r4
    for (size_t i = len; i < width; i++) {
   12ade:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   12ae0:	3301      	adds	r3, #1
   12ae2:	64fb      	str	r3, [r7, #76]	; 0x4c
   12ae4:	e7ef      	b.n	12ac6 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x3ba>
    }
  }

  // reverse string
  for (size_t i = 0U; i < len; i++) {
   12ae6:	2300      	movs	r3, #0
   12ae8:	64bb      	str	r3, [r7, #72]	; 0x48
   12aea:	6cba      	ldr	r2, [r7, #72]	; 0x48
   12aec:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   12aee:	429a      	cmp	r2, r3
   12af0:	d213      	bcs.n	12b1a <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x40e>
    out(buf[len - i - 1U], buffer, idx++, maxlen);
   12af2:	6e3a      	ldr	r2, [r7, #96]	; 0x60
   12af4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   12af6:	1ad3      	subs	r3, r2, r3
   12af8:	3b01      	subs	r3, #1
   12afa:	f107 0268 	add.w	r2, r7, #104	; 0x68
   12afe:	4413      	add	r3, r2
   12b00:	f813 0c50 	ldrb.w	r0, [r3, #-80]
   12b04:	68fa      	ldr	r2, [r7, #12]
   12b06:	1c53      	adds	r3, r2, #1
   12b08:	60fb      	str	r3, [r7, #12]
   12b0a:	697c      	ldr	r4, [r7, #20]
   12b0c:	68bb      	ldr	r3, [r7, #8]
   12b0e:	6939      	ldr	r1, [r7, #16]
   12b10:	47a0      	blx	r4
  for (size_t i = 0U; i < len; i++) {
   12b12:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   12b14:	3301      	adds	r3, #1
   12b16:	64bb      	str	r3, [r7, #72]	; 0x48
   12b18:	e7e7      	b.n	12aea <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x3de>
  }

  // append pad spaces up to given width
  if (flags & FLAGS_LEFT) {
   12b1a:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
   12b1e:	f003 0302 	and.w	r3, r3, #2
   12b22:	2b00      	cmp	r3, #0
   12b24:	d00e      	beq.n	12b44 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x438>
    while (idx - start_idx < width) {
   12b26:	68fa      	ldr	r2, [r7, #12]
   12b28:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   12b2a:	1ad3      	subs	r3, r2, r3
   12b2c:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
   12b2e:	429a      	cmp	r2, r3
   12b30:	d908      	bls.n	12b44 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x438>
      out(' ', buffer, idx++, maxlen);
   12b32:	68fa      	ldr	r2, [r7, #12]
   12b34:	1c53      	adds	r3, r2, #1
   12b36:	60fb      	str	r3, [r7, #12]
   12b38:	697c      	ldr	r4, [r7, #20]
   12b3a:	68bb      	ldr	r3, [r7, #8]
   12b3c:	6939      	ldr	r1, [r7, #16]
   12b3e:	2020      	movs	r0, #32
   12b40:	47a0      	blx	r4
    while (idx - start_idx < width) {
   12b42:	e7f0      	b.n	12b26 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x41a>
    }
  }

  return idx;
   12b44:	68fb      	ldr	r3, [r7, #12]
}
   12b46:	4618      	mov	r0, r3
   12b48:	376c      	adds	r7, #108	; 0x6c
   12b4a:	46bd      	mov	sp, r7
   12b4c:	bd90      	pop	{r4, r7, pc}
   12b4e:	bf00      	nop

00012b50 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)>:
#endif  // PRINTF_SUPPORT_FLOAT


// internal vsnprintf
static int _vsnprintf(out_fct_type out, char* buffer, const size_t maxlen, const char* format, va_list va)
{
   12b50:	b5b0      	push	{r4, r5, r7, lr}
   12b52:	b0a0      	sub	sp, #128	; 0x80
   12b54:	af0a      	add	r7, sp, #40	; 0x28
   12b56:	60f8      	str	r0, [r7, #12]
   12b58:	60b9      	str	r1, [r7, #8]
   12b5a:	607a      	str	r2, [r7, #4]
   12b5c:	603b      	str	r3, [r7, #0]
  unsigned int flags, width, precision, n;
  size_t idx = 0U;
   12b5e:	2300      	movs	r3, #0
   12b60:	647b      	str	r3, [r7, #68]	; 0x44

  if (!buffer) {
   12b62:	68bb      	ldr	r3, [r7, #8]
   12b64:	2b00      	cmp	r3, #0
   12b66:	d101      	bne.n	12b6c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x1c>
    // use null output function
    out = _out_null;
   12b68:	4ba2      	ldr	r3, [pc, #648]	; (12df4 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2a4>)
   12b6a:	60fb      	str	r3, [r7, #12]
  }

  while (*format)
   12b6c:	683b      	ldr	r3, [r7, #0]
   12b6e:	781b      	ldrb	r3, [r3, #0]
   12b70:	2b00      	cmp	r3, #0
   12b72:	f000 8445 	beq.w	13400 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8b0>
  {
    // format specifier?  %[flags][width][.precision][length]
    if (*format != '%') {
   12b76:	683b      	ldr	r3, [r7, #0]
   12b78:	781b      	ldrb	r3, [r3, #0]
   12b7a:	2b25      	cmp	r3, #37	; 0x25
   12b7c:	d00d      	beq.n	12b9a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x4a>
      // no
      out(*format, buffer, idx++, maxlen);
   12b7e:	683b      	ldr	r3, [r7, #0]
   12b80:	7818      	ldrb	r0, [r3, #0]
   12b82:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   12b84:	1c53      	adds	r3, r2, #1
   12b86:	647b      	str	r3, [r7, #68]	; 0x44
   12b88:	68fc      	ldr	r4, [r7, #12]
   12b8a:	687b      	ldr	r3, [r7, #4]
   12b8c:	68b9      	ldr	r1, [r7, #8]
   12b8e:	47a0      	blx	r4
      format++;
   12b90:	683b      	ldr	r3, [r7, #0]
   12b92:	3301      	adds	r3, #1
   12b94:	603b      	str	r3, [r7, #0]
      continue;
   12b96:	f000 bc31 	b.w	133fc <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8ac>
    }
    else {
      // yes, evaluate it
      format++;
   12b9a:	683b      	ldr	r3, [r7, #0]
   12b9c:	3301      	adds	r3, #1
   12b9e:	603b      	str	r3, [r7, #0]
    }

    // evaluate flags
    flags = 0U;
   12ba0:	2300      	movs	r3, #0
   12ba2:	657b      	str	r3, [r7, #84]	; 0x54
    do {
      switch (*format) {
   12ba4:	683b      	ldr	r3, [r7, #0]
   12ba6:	781b      	ldrb	r3, [r3, #0]
   12ba8:	3b20      	subs	r3, #32
   12baa:	2b10      	cmp	r3, #16
   12bac:	d856      	bhi.n	12c5c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x10c>
   12bae:	a201      	add	r2, pc, #4	; (adr r2, 12bb4 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x64>)
   12bb0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   12bb4:	00012c35 	.word	0x00012c35
   12bb8:	00012c5d 	.word	0x00012c5d
   12bbc:	00012c5d 	.word	0x00012c5d
   12bc0:	00012c49 	.word	0x00012c49
   12bc4:	00012c5d 	.word	0x00012c5d
   12bc8:	00012c5d 	.word	0x00012c5d
   12bcc:	00012c5d 	.word	0x00012c5d
   12bd0:	00012c5d 	.word	0x00012c5d
   12bd4:	00012c5d 	.word	0x00012c5d
   12bd8:	00012c5d 	.word	0x00012c5d
   12bdc:	00012c5d 	.word	0x00012c5d
   12be0:	00012c21 	.word	0x00012c21
   12be4:	00012c5d 	.word	0x00012c5d
   12be8:	00012c0d 	.word	0x00012c0d
   12bec:	00012c5d 	.word	0x00012c5d
   12bf0:	00012c5d 	.word	0x00012c5d
   12bf4:	00012bf9 	.word	0x00012bf9
        case '0': flags |= FLAGS_ZEROPAD; format++; n = 1U; break;
   12bf8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   12bfa:	f043 0301 	orr.w	r3, r3, #1
   12bfe:	657b      	str	r3, [r7, #84]	; 0x54
   12c00:	683b      	ldr	r3, [r7, #0]
   12c02:	3301      	adds	r3, #1
   12c04:	603b      	str	r3, [r7, #0]
   12c06:	2301      	movs	r3, #1
   12c08:	64bb      	str	r3, [r7, #72]	; 0x48
   12c0a:	e02a      	b.n	12c62 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x112>
        case '-': flags |= FLAGS_LEFT;    format++; n = 1U; break;
   12c0c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   12c0e:	f043 0302 	orr.w	r3, r3, #2
   12c12:	657b      	str	r3, [r7, #84]	; 0x54
   12c14:	683b      	ldr	r3, [r7, #0]
   12c16:	3301      	adds	r3, #1
   12c18:	603b      	str	r3, [r7, #0]
   12c1a:	2301      	movs	r3, #1
   12c1c:	64bb      	str	r3, [r7, #72]	; 0x48
   12c1e:	e020      	b.n	12c62 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x112>
        case '+': flags |= FLAGS_PLUS;    format++; n = 1U; break;
   12c20:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   12c22:	f043 0304 	orr.w	r3, r3, #4
   12c26:	657b      	str	r3, [r7, #84]	; 0x54
   12c28:	683b      	ldr	r3, [r7, #0]
   12c2a:	3301      	adds	r3, #1
   12c2c:	603b      	str	r3, [r7, #0]
   12c2e:	2301      	movs	r3, #1
   12c30:	64bb      	str	r3, [r7, #72]	; 0x48
   12c32:	e016      	b.n	12c62 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x112>
        case ' ': flags |= FLAGS_SPACE;   format++; n = 1U; break;
   12c34:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   12c36:	f043 0308 	orr.w	r3, r3, #8
   12c3a:	657b      	str	r3, [r7, #84]	; 0x54
   12c3c:	683b      	ldr	r3, [r7, #0]
   12c3e:	3301      	adds	r3, #1
   12c40:	603b      	str	r3, [r7, #0]
   12c42:	2301      	movs	r3, #1
   12c44:	64bb      	str	r3, [r7, #72]	; 0x48
   12c46:	e00c      	b.n	12c62 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x112>
        case '#': flags |= FLAGS_HASH;    format++; n = 1U; break;
   12c48:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   12c4a:	f043 0310 	orr.w	r3, r3, #16
   12c4e:	657b      	str	r3, [r7, #84]	; 0x54
   12c50:	683b      	ldr	r3, [r7, #0]
   12c52:	3301      	adds	r3, #1
   12c54:	603b      	str	r3, [r7, #0]
   12c56:	2301      	movs	r3, #1
   12c58:	64bb      	str	r3, [r7, #72]	; 0x48
   12c5a:	e002      	b.n	12c62 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x112>
        default :                                   n = 0U; break;
   12c5c:	2300      	movs	r3, #0
   12c5e:	64bb      	str	r3, [r7, #72]	; 0x48
   12c60:	bf00      	nop
      }
    } while (n);
   12c62:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   12c64:	2b00      	cmp	r3, #0
   12c66:	d000      	beq.n	12c6a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x11a>
    do {
   12c68:	e79c      	b.n	12ba4 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x54>

    // evaluate width field
    width = 0U;
   12c6a:	2300      	movs	r3, #0
   12c6c:	653b      	str	r3, [r7, #80]	; 0x50
    if (_is_digit(*format)) {
   12c6e:	683b      	ldr	r3, [r7, #0]
   12c70:	781b      	ldrb	r3, [r3, #0]
   12c72:	4618      	mov	r0, r3
   12c74:	f7ff fb18 	bl	122a8 <_is_digit(char)>
   12c78:	4603      	mov	r3, r0
   12c7a:	2b00      	cmp	r3, #0
   12c7c:	d005      	beq.n	12c8a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x13a>
      width = _atoi(&format);
   12c7e:	463b      	mov	r3, r7
   12c80:	4618      	mov	r0, r3
   12c82:	f7ff fb25 	bl	122d0 <_atoi(char const**)>
   12c86:	6538      	str	r0, [r7, #80]	; 0x50
   12c88:	e018      	b.n	12cbc <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x16c>
    }
    else if (*format == '*') {
   12c8a:	683b      	ldr	r3, [r7, #0]
   12c8c:	781b      	ldrb	r3, [r3, #0]
   12c8e:	2b2a      	cmp	r3, #42	; 0x2a
   12c90:	d114      	bne.n	12cbc <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x16c>
      const int w = va_arg(va, int);
   12c92:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   12c94:	1d1a      	adds	r2, r3, #4
   12c96:	66ba      	str	r2, [r7, #104]	; 0x68
   12c98:	681b      	ldr	r3, [r3, #0]
   12c9a:	633b      	str	r3, [r7, #48]	; 0x30
      if (w < 0) {
   12c9c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   12c9e:	2b00      	cmp	r3, #0
   12ca0:	da07      	bge.n	12cb2 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x162>
        flags |= FLAGS_LEFT;    // reverse padding
   12ca2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   12ca4:	f043 0302 	orr.w	r3, r3, #2
   12ca8:	657b      	str	r3, [r7, #84]	; 0x54
        width = (unsigned int)-w;
   12caa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   12cac:	425b      	negs	r3, r3
   12cae:	653b      	str	r3, [r7, #80]	; 0x50
   12cb0:	e001      	b.n	12cb6 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x166>
      }
      else {
        width = (unsigned int)w;
   12cb2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   12cb4:	653b      	str	r3, [r7, #80]	; 0x50
      }
      format++;
   12cb6:	683b      	ldr	r3, [r7, #0]
   12cb8:	3301      	adds	r3, #1
   12cba:	603b      	str	r3, [r7, #0]
    }

    // evaluate precision field
    precision = 0U;
   12cbc:	2300      	movs	r3, #0
   12cbe:	64fb      	str	r3, [r7, #76]	; 0x4c
    if (*format == '.') {
   12cc0:	683b      	ldr	r3, [r7, #0]
   12cc2:	781b      	ldrb	r3, [r3, #0]
   12cc4:	2b2e      	cmp	r3, #46	; 0x2e
   12cc6:	d124      	bne.n	12d12 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x1c2>
      flags |= FLAGS_PRECISION;
   12cc8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   12cca:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
   12cce:	657b      	str	r3, [r7, #84]	; 0x54
      format++;
   12cd0:	683b      	ldr	r3, [r7, #0]
   12cd2:	3301      	adds	r3, #1
   12cd4:	603b      	str	r3, [r7, #0]
      if (_is_digit(*format)) {
   12cd6:	683b      	ldr	r3, [r7, #0]
   12cd8:	781b      	ldrb	r3, [r3, #0]
   12cda:	4618      	mov	r0, r3
   12cdc:	f7ff fae4 	bl	122a8 <_is_digit(char)>
   12ce0:	4603      	mov	r3, r0
   12ce2:	2b00      	cmp	r3, #0
   12ce4:	d005      	beq.n	12cf2 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x1a2>
        precision = _atoi(&format);
   12ce6:	463b      	mov	r3, r7
   12ce8:	4618      	mov	r0, r3
   12cea:	f7ff faf1 	bl	122d0 <_atoi(char const**)>
   12cee:	64f8      	str	r0, [r7, #76]	; 0x4c
   12cf0:	e00f      	b.n	12d12 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x1c2>
      }
      else if (*format == '*') {
   12cf2:	683b      	ldr	r3, [r7, #0]
   12cf4:	781b      	ldrb	r3, [r3, #0]
   12cf6:	2b2a      	cmp	r3, #42	; 0x2a
   12cf8:	d10b      	bne.n	12d12 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x1c2>
        const int prec = (int)va_arg(va, int);
   12cfa:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   12cfc:	1d1a      	adds	r2, r3, #4
   12cfe:	66ba      	str	r2, [r7, #104]	; 0x68
   12d00:	681b      	ldr	r3, [r3, #0]
   12d02:	62fb      	str	r3, [r7, #44]	; 0x2c
        precision = prec > 0 ? (unsigned int)prec : 0U;
   12d04:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   12d06:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   12d0a:	64fb      	str	r3, [r7, #76]	; 0x4c
        format++;
   12d0c:	683b      	ldr	r3, [r7, #0]
   12d0e:	3301      	adds	r3, #1
   12d10:	603b      	str	r3, [r7, #0]
      }
    }

    // evaluate length field
    switch (*format) {
   12d12:	683b      	ldr	r3, [r7, #0]
   12d14:	781b      	ldrb	r3, [r3, #0]
   12d16:	3b68      	subs	r3, #104	; 0x68
   12d18:	2b12      	cmp	r3, #18
   12d1a:	d867      	bhi.n	12dec <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x29c>
   12d1c:	a201      	add	r2, pc, #4	; (adr r2, 12d24 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x1d4>)
   12d1e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   12d22:	bf00      	nop
   12d24:	00012d97 	.word	0x00012d97
   12d28:	00012ded 	.word	0x00012ded
   12d2c:	00012dcd 	.word	0x00012dcd
   12d30:	00012ded 	.word	0x00012ded
   12d34:	00012d71 	.word	0x00012d71
   12d38:	00012ded 	.word	0x00012ded
   12d3c:	00012ded 	.word	0x00012ded
   12d40:	00012ded 	.word	0x00012ded
   12d44:	00012ded 	.word	0x00012ded
   12d48:	00012ded 	.word	0x00012ded
   12d4c:	00012ded 	.word	0x00012ded
   12d50:	00012ded 	.word	0x00012ded
   12d54:	00012dbd 	.word	0x00012dbd
   12d58:	00012ded 	.word	0x00012ded
   12d5c:	00012ded 	.word	0x00012ded
   12d60:	00012ded 	.word	0x00012ded
   12d64:	00012ded 	.word	0x00012ded
   12d68:	00012ded 	.word	0x00012ded
   12d6c:	00012ddd 	.word	0x00012ddd
      case 'l' :
        flags |= FLAGS_LONG;
   12d70:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   12d72:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   12d76:	657b      	str	r3, [r7, #84]	; 0x54
        format++;
   12d78:	683b      	ldr	r3, [r7, #0]
   12d7a:	3301      	adds	r3, #1
   12d7c:	603b      	str	r3, [r7, #0]
        if (*format == 'l') {
   12d7e:	683b      	ldr	r3, [r7, #0]
   12d80:	781b      	ldrb	r3, [r3, #0]
   12d82:	2b6c      	cmp	r3, #108	; 0x6c
   12d84:	d134      	bne.n	12df0 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2a0>
          flags |= FLAGS_LONG_LONG;
   12d86:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   12d88:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   12d8c:	657b      	str	r3, [r7, #84]	; 0x54
          format++;
   12d8e:	683b      	ldr	r3, [r7, #0]
   12d90:	3301      	adds	r3, #1
   12d92:	603b      	str	r3, [r7, #0]
        }
        break;
   12d94:	e02c      	b.n	12df0 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2a0>
      case 'h' :
        flags |= FLAGS_SHORT;
   12d96:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   12d98:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   12d9c:	657b      	str	r3, [r7, #84]	; 0x54
        format++;
   12d9e:	683b      	ldr	r3, [r7, #0]
   12da0:	3301      	adds	r3, #1
   12da2:	603b      	str	r3, [r7, #0]
        if (*format == 'h') {
   12da4:	683b      	ldr	r3, [r7, #0]
   12da6:	781b      	ldrb	r3, [r3, #0]
   12da8:	2b68      	cmp	r3, #104	; 0x68
   12daa:	d125      	bne.n	12df8 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2a8>
          flags |= FLAGS_CHAR;
   12dac:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   12dae:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   12db2:	657b      	str	r3, [r7, #84]	; 0x54
          format++;
   12db4:	683b      	ldr	r3, [r7, #0]
   12db6:	3301      	adds	r3, #1
   12db8:	603b      	str	r3, [r7, #0]
        }
        break;
   12dba:	e01d      	b.n	12df8 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2a8>
#if defined(PRINTF_SUPPORT_PTRDIFF_T)
      case 't' :
        flags |= (sizeof(ptrdiff_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
   12dbc:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   12dbe:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   12dc2:	657b      	str	r3, [r7, #84]	; 0x54
        format++;
   12dc4:	683b      	ldr	r3, [r7, #0]
   12dc6:	3301      	adds	r3, #1
   12dc8:	603b      	str	r3, [r7, #0]
        break;
   12dca:	e016      	b.n	12dfa <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2aa>
#endif
      case 'j' :
        flags |= (sizeof(intmax_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
   12dcc:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   12dce:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   12dd2:	657b      	str	r3, [r7, #84]	; 0x54
        format++;
   12dd4:	683b      	ldr	r3, [r7, #0]
   12dd6:	3301      	adds	r3, #1
   12dd8:	603b      	str	r3, [r7, #0]
        break;
   12dda:	e00e      	b.n	12dfa <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2aa>
      case 'z' :
        flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
   12ddc:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   12dde:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   12de2:	657b      	str	r3, [r7, #84]	; 0x54
        format++;
   12de4:	683b      	ldr	r3, [r7, #0]
   12de6:	3301      	adds	r3, #1
   12de8:	603b      	str	r3, [r7, #0]
        break;
   12dea:	e006      	b.n	12dfa <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2aa>
      default :
        break;
   12dec:	bf00      	nop
   12dee:	e004      	b.n	12dfa <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2aa>
        break;
   12df0:	bf00      	nop
   12df2:	e002      	b.n	12dfa <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2aa>
   12df4:	00012239 	.word	0x00012239
        break;
   12df8:	bf00      	nop
    }

    // evaluate specifier
    switch (*format) {
   12dfa:	683b      	ldr	r3, [r7, #0]
   12dfc:	781b      	ldrb	r3, [r3, #0]
   12dfe:	3b25      	subs	r3, #37	; 0x25
   12e00:	2b53      	cmp	r3, #83	; 0x53
   12e02:	f200 82ee 	bhi.w	133e2 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x892>
   12e06:	a201      	add	r2, pc, #4	; (adr r2, 12e0c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2bc>)
   12e08:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   12e0c:	000133cb 	.word	0x000133cb
   12e10:	000133e3 	.word	0x000133e3
   12e14:	000133e3 	.word	0x000133e3
   12e18:	000133e3 	.word	0x000133e3
   12e1c:	000133e3 	.word	0x000133e3
   12e20:	000133e3 	.word	0x000133e3
   12e24:	000133e3 	.word	0x000133e3
   12e28:	000133e3 	.word	0x000133e3
   12e2c:	000133e3 	.word	0x000133e3
   12e30:	000133e3 	.word	0x000133e3
   12e34:	000133e3 	.word	0x000133e3
   12e38:	000133e3 	.word	0x000133e3
   12e3c:	000133e3 	.word	0x000133e3
   12e40:	000133e3 	.word	0x000133e3
   12e44:	000133e3 	.word	0x000133e3
   12e48:	000133e3 	.word	0x000133e3
   12e4c:	000133e3 	.word	0x000133e3
   12e50:	000133e3 	.word	0x000133e3
   12e54:	000133e3 	.word	0x000133e3
   12e58:	000133e3 	.word	0x000133e3
   12e5c:	000133e3 	.word	0x000133e3
   12e60:	000133e3 	.word	0x000133e3
   12e64:	000133e3 	.word	0x000133e3
   12e68:	000133e3 	.word	0x000133e3
   12e6c:	000133e3 	.word	0x000133e3
   12e70:	000133e3 	.word	0x000133e3
   12e74:	000133e3 	.word	0x000133e3
   12e78:	000133e3 	.word	0x000133e3
   12e7c:	000133e3 	.word	0x000133e3
   12e80:	000133e3 	.word	0x000133e3
   12e84:	000133e3 	.word	0x000133e3
   12e88:	000133e3 	.word	0x000133e3
   12e8c:	000133e3 	.word	0x000133e3
   12e90:	000131e9 	.word	0x000131e9
   12e94:	000133e3 	.word	0x000133e3
   12e98:	000133e3 	.word	0x000133e3
   12e9c:	000133e3 	.word	0x000133e3
   12ea0:	000133e3 	.word	0x000133e3
   12ea4:	000133e3 	.word	0x000133e3
   12ea8:	000133e3 	.word	0x000133e3
   12eac:	000133e3 	.word	0x000133e3
   12eb0:	000133e3 	.word	0x000133e3
   12eb4:	000133e3 	.word	0x000133e3
   12eb8:	000133e3 	.word	0x000133e3
   12ebc:	000133e3 	.word	0x000133e3
   12ec0:	000133e3 	.word	0x000133e3
   12ec4:	000133e3 	.word	0x000133e3
   12ec8:	000133e3 	.word	0x000133e3
   12ecc:	000133e3 	.word	0x000133e3
   12ed0:	000133e3 	.word	0x000133e3
   12ed4:	000133e3 	.word	0x000133e3
   12ed8:	00012f5d 	.word	0x00012f5d
   12edc:	000133e3 	.word	0x000133e3
   12ee0:	000133e3 	.word	0x000133e3
   12ee4:	000133e3 	.word	0x000133e3
   12ee8:	000133e3 	.word	0x000133e3
   12eec:	000133e3 	.word	0x000133e3
   12ef0:	000133e3 	.word	0x000133e3
   12ef4:	000133e3 	.word	0x000133e3
   12ef8:	000133e3 	.word	0x000133e3
   12efc:	000133e3 	.word	0x000133e3
   12f00:	00012f5d 	.word	0x00012f5d
   12f04:	00013225 	.word	0x00013225
   12f08:	00012f5d 	.word	0x00012f5d
   12f0c:	000133e3 	.word	0x000133e3
   12f10:	000131e9 	.word	0x000131e9
   12f14:	000133e3 	.word	0x000133e3
   12f18:	000133e3 	.word	0x000133e3
   12f1c:	00012f5d 	.word	0x00012f5d
   12f20:	000133e3 	.word	0x000133e3
   12f24:	000133e3 	.word	0x000133e3
   12f28:	000133e3 	.word	0x000133e3
   12f2c:	000133e3 	.word	0x000133e3
   12f30:	000133e3 	.word	0x000133e3
   12f34:	00012f5d 	.word	0x00012f5d
   12f38:	00013383 	.word	0x00013383
   12f3c:	000133e3 	.word	0x000133e3
   12f40:	000133e3 	.word	0x000133e3
   12f44:	000132ad 	.word	0x000132ad
   12f48:	000133e3 	.word	0x000133e3
   12f4c:	00012f5d 	.word	0x00012f5d
   12f50:	000133e3 	.word	0x000133e3
   12f54:	000133e3 	.word	0x000133e3
   12f58:	00012f5d 	.word	0x00012f5d
      case 'X' :
      case 'o' :
      case 'b' : {
        // set the base
        unsigned int base;
        if (*format == 'x' || *format == 'X') {
   12f5c:	683b      	ldr	r3, [r7, #0]
   12f5e:	781b      	ldrb	r3, [r3, #0]
   12f60:	2b78      	cmp	r3, #120	; 0x78
   12f62:	d003      	beq.n	12f6c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x41c>
   12f64:	683b      	ldr	r3, [r7, #0]
   12f66:	781b      	ldrb	r3, [r3, #0]
   12f68:	2b58      	cmp	r3, #88	; 0x58
   12f6a:	d102      	bne.n	12f72 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x422>
          base = 16U;
   12f6c:	2310      	movs	r3, #16
   12f6e:	643b      	str	r3, [r7, #64]	; 0x40
   12f70:	e013      	b.n	12f9a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x44a>
        }
        else if (*format == 'o') {
   12f72:	683b      	ldr	r3, [r7, #0]
   12f74:	781b      	ldrb	r3, [r3, #0]
   12f76:	2b6f      	cmp	r3, #111	; 0x6f
   12f78:	d102      	bne.n	12f80 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x430>
          base =  8U;
   12f7a:	2308      	movs	r3, #8
   12f7c:	643b      	str	r3, [r7, #64]	; 0x40
   12f7e:	e00c      	b.n	12f9a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x44a>
        }
        else if (*format == 'b') {
   12f80:	683b      	ldr	r3, [r7, #0]
   12f82:	781b      	ldrb	r3, [r3, #0]
   12f84:	2b62      	cmp	r3, #98	; 0x62
   12f86:	d102      	bne.n	12f8e <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x43e>
          base =  2U;
   12f88:	2302      	movs	r3, #2
   12f8a:	643b      	str	r3, [r7, #64]	; 0x40
   12f8c:	e005      	b.n	12f9a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x44a>
        }
        else {
          base = 10U;
   12f8e:	230a      	movs	r3, #10
   12f90:	643b      	str	r3, [r7, #64]	; 0x40
          flags &= ~FLAGS_HASH;   // no hash for dec format
   12f92:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   12f94:	f023 0310 	bic.w	r3, r3, #16
   12f98:	657b      	str	r3, [r7, #84]	; 0x54
        }
        // uppercase
        if (*format == 'X') {
   12f9a:	683b      	ldr	r3, [r7, #0]
   12f9c:	781b      	ldrb	r3, [r3, #0]
   12f9e:	2b58      	cmp	r3, #88	; 0x58
   12fa0:	d103      	bne.n	12faa <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x45a>
          flags |= FLAGS_UPPERCASE;
   12fa2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   12fa4:	f043 0320 	orr.w	r3, r3, #32
   12fa8:	657b      	str	r3, [r7, #84]	; 0x54
        }

        // no plus or space flag for u, x, X, o, b
        if ((*format != 'i') && (*format != 'd')) {
   12faa:	683b      	ldr	r3, [r7, #0]
   12fac:	781b      	ldrb	r3, [r3, #0]
   12fae:	2b69      	cmp	r3, #105	; 0x69
   12fb0:	d007      	beq.n	12fc2 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x472>
   12fb2:	683b      	ldr	r3, [r7, #0]
   12fb4:	781b      	ldrb	r3, [r3, #0]
   12fb6:	2b64      	cmp	r3, #100	; 0x64
   12fb8:	d003      	beq.n	12fc2 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x472>
          flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
   12fba:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   12fbc:	f023 030c 	bic.w	r3, r3, #12
   12fc0:	657b      	str	r3, [r7, #84]	; 0x54
        }

        // ignore '0' flag when precision is given
        if (flags & FLAGS_PRECISION) {
   12fc2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   12fc4:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   12fc8:	2b00      	cmp	r3, #0
   12fca:	d003      	beq.n	12fd4 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x484>
          flags &= ~FLAGS_ZEROPAD;
   12fcc:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   12fce:	f023 0301 	bic.w	r3, r3, #1
   12fd2:	657b      	str	r3, [r7, #84]	; 0x54
        }

        // convert the integer
        if ((*format == 'i') || (*format == 'd')) {
   12fd4:	683b      	ldr	r3, [r7, #0]
   12fd6:	781b      	ldrb	r3, [r3, #0]
   12fd8:	2b69      	cmp	r3, #105	; 0x69
   12fda:	d004      	beq.n	12fe6 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x496>
   12fdc:	683b      	ldr	r3, [r7, #0]
   12fde:	781b      	ldrb	r3, [r3, #0]
   12fe0:	2b64      	cmp	r3, #100	; 0x64
   12fe2:	f040 808d 	bne.w	13100 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x5b0>
          // signed
          if (flags & FLAGS_LONG_LONG) {
   12fe6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   12fe8:	f403 7300 	and.w	r3, r3, #512	; 0x200
   12fec:	2b00      	cmp	r3, #0
   12fee:	d02e      	beq.n	1304e <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x4fe>
#if defined(PRINTF_SUPPORT_LONG_LONG)
            const long long value = va_arg(va, long long);
   12ff0:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   12ff2:	3307      	adds	r3, #7
   12ff4:	f023 0307 	bic.w	r3, r3, #7
   12ff8:	f103 0208 	add.w	r2, r3, #8
   12ffc:	66ba      	str	r2, [r7, #104]	; 0x68
   12ffe:	e9d3 3400 	ldrd	r3, r4, [r3]
   13002:	e9c7 3404 	strd	r3, r4, [r7, #16]
            idx = _ntoa_long_long(out, buffer, idx, maxlen, (unsigned long long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
   13006:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
   1300a:	2b00      	cmp	r3, #0
   1300c:	f174 0200 	sbcs.w	r2, r4, #0
   13010:	da02      	bge.n	13018 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x4c8>
   13012:	425b      	negs	r3, r3
   13014:	eb64 0444 	sbc.w	r4, r4, r4, lsl #1
   13018:	4619      	mov	r1, r3
   1301a:	4622      	mov	r2, r4
   1301c:	697b      	ldr	r3, [r7, #20]
   1301e:	0fdb      	lsrs	r3, r3, #31
   13020:	b2d8      	uxtb	r0, r3
   13022:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   13024:	f04f 0400 	mov.w	r4, #0
   13028:	6d7d      	ldr	r5, [r7, #84]	; 0x54
   1302a:	9508      	str	r5, [sp, #32]
   1302c:	6d3d      	ldr	r5, [r7, #80]	; 0x50
   1302e:	9507      	str	r5, [sp, #28]
   13030:	6cfd      	ldr	r5, [r7, #76]	; 0x4c
   13032:	9506      	str	r5, [sp, #24]
   13034:	e9cd 3404 	strd	r3, r4, [sp, #16]
   13038:	9002      	str	r0, [sp, #8]
   1303a:	e9cd 1200 	strd	r1, r2, [sp]
   1303e:	687b      	ldr	r3, [r7, #4]
   13040:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   13042:	68b9      	ldr	r1, [r7, #8]
   13044:	68f8      	ldr	r0, [r7, #12]
   13046:	f7ff faf0 	bl	1262a <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)>
   1304a:	6478      	str	r0, [r7, #68]	; 0x44
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
          }
          else {
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
          }
   1304c:	e0c8      	b.n	131e0 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x690>
          else if (flags & FLAGS_LONG) {
   1304e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   13050:	f403 7380 	and.w	r3, r3, #256	; 0x100
   13054:	2b00      	cmp	r3, #0
   13056:	d01e      	beq.n	13096 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x546>
            const long value = va_arg(va, long);
   13058:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   1305a:	1d1a      	adds	r2, r3, #4
   1305c:	66ba      	str	r2, [r7, #104]	; 0x68
   1305e:	681b      	ldr	r3, [r3, #0]
   13060:	61fb      	str	r3, [r7, #28]
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
   13062:	69fb      	ldr	r3, [r7, #28]
   13064:	2b00      	cmp	r3, #0
   13066:	bfb8      	it	lt
   13068:	425b      	neglt	r3, r3
   1306a:	4619      	mov	r1, r3
   1306c:	69fb      	ldr	r3, [r7, #28]
   1306e:	0fdb      	lsrs	r3, r3, #31
   13070:	b2db      	uxtb	r3, r3
   13072:	6d7a      	ldr	r2, [r7, #84]	; 0x54
   13074:	9205      	str	r2, [sp, #20]
   13076:	6d3a      	ldr	r2, [r7, #80]	; 0x50
   13078:	9204      	str	r2, [sp, #16]
   1307a:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
   1307c:	9203      	str	r2, [sp, #12]
   1307e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   13080:	9202      	str	r2, [sp, #8]
   13082:	9301      	str	r3, [sp, #4]
   13084:	9100      	str	r1, [sp, #0]
   13086:	687b      	ldr	r3, [r7, #4]
   13088:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   1308a:	68b9      	ldr	r1, [r7, #8]
   1308c:	68f8      	ldr	r0, [r7, #12]
   1308e:	f7ff fa64 	bl	1255a <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)>
   13092:	6478      	str	r0, [r7, #68]	; 0x44
          }
   13094:	e0a4      	b.n	131e0 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x690>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
   13096:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   13098:	f003 0340 	and.w	r3, r3, #64	; 0x40
   1309c:	2b00      	cmp	r3, #0
   1309e:	d005      	beq.n	130ac <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x55c>
   130a0:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   130a2:	1d1a      	adds	r2, r3, #4
   130a4:	66ba      	str	r2, [r7, #104]	; 0x68
   130a6:	681b      	ldr	r3, [r3, #0]
   130a8:	b2db      	uxtb	r3, r3
   130aa:	e00e      	b.n	130ca <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x57a>
   130ac:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   130ae:	f003 0380 	and.w	r3, r3, #128	; 0x80
   130b2:	2b00      	cmp	r3, #0
   130b4:	d005      	beq.n	130c2 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x572>
   130b6:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   130b8:	1d1a      	adds	r2, r3, #4
   130ba:	66ba      	str	r2, [r7, #104]	; 0x68
   130bc:	681b      	ldr	r3, [r3, #0]
   130be:	b21b      	sxth	r3, r3
   130c0:	e003      	b.n	130ca <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x57a>
   130c2:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   130c4:	1d1a      	adds	r2, r3, #4
   130c6:	66ba      	str	r2, [r7, #104]	; 0x68
   130c8:	681b      	ldr	r3, [r3, #0]
   130ca:	623b      	str	r3, [r7, #32]
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
   130cc:	6a3b      	ldr	r3, [r7, #32]
   130ce:	2b00      	cmp	r3, #0
   130d0:	bfb8      	it	lt
   130d2:	425b      	neglt	r3, r3
   130d4:	4619      	mov	r1, r3
   130d6:	6a3b      	ldr	r3, [r7, #32]
   130d8:	0fdb      	lsrs	r3, r3, #31
   130da:	b2db      	uxtb	r3, r3
   130dc:	6d7a      	ldr	r2, [r7, #84]	; 0x54
   130de:	9205      	str	r2, [sp, #20]
   130e0:	6d3a      	ldr	r2, [r7, #80]	; 0x50
   130e2:	9204      	str	r2, [sp, #16]
   130e4:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
   130e6:	9203      	str	r2, [sp, #12]
   130e8:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   130ea:	9202      	str	r2, [sp, #8]
   130ec:	9301      	str	r3, [sp, #4]
   130ee:	9100      	str	r1, [sp, #0]
   130f0:	687b      	ldr	r3, [r7, #4]
   130f2:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   130f4:	68b9      	ldr	r1, [r7, #8]
   130f6:	68f8      	ldr	r0, [r7, #12]
   130f8:	f7ff fa2f 	bl	1255a <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)>
   130fc:	6478      	str	r0, [r7, #68]	; 0x44
          }
   130fe:	e06f      	b.n	131e0 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x690>
        }
        else {
          // unsigned
          if (flags & FLAGS_LONG_LONG) {
   13100:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   13102:	f403 7300 	and.w	r3, r3, #512	; 0x200
   13106:	2b00      	cmp	r3, #0
   13108:	d020      	beq.n	1314c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x5fc>
#if defined(PRINTF_SUPPORT_LONG_LONG)
            idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
   1310a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   1310c:	3307      	adds	r3, #7
   1310e:	f023 0307 	bic.w	r3, r3, #7
   13112:	f103 0208 	add.w	r2, r3, #8
   13116:	66ba      	str	r2, [r7, #104]	; 0x68
   13118:	e9d3 3400 	ldrd	r3, r4, [r3]
   1311c:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   1311e:	4611      	mov	r1, r2
   13120:	f04f 0200 	mov.w	r2, #0
   13124:	6d78      	ldr	r0, [r7, #84]	; 0x54
   13126:	9008      	str	r0, [sp, #32]
   13128:	6d38      	ldr	r0, [r7, #80]	; 0x50
   1312a:	9007      	str	r0, [sp, #28]
   1312c:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
   1312e:	9006      	str	r0, [sp, #24]
   13130:	e9cd 1204 	strd	r1, r2, [sp, #16]
   13134:	2200      	movs	r2, #0
   13136:	9202      	str	r2, [sp, #8]
   13138:	e9cd 3400 	strd	r3, r4, [sp]
   1313c:	687b      	ldr	r3, [r7, #4]
   1313e:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   13140:	68b9      	ldr	r1, [r7, #8]
   13142:	68f8      	ldr	r0, [r7, #12]
   13144:	f7ff fa71 	bl	1262a <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)>
   13148:	6478      	str	r0, [r7, #68]	; 0x44
   1314a:	e049      	b.n	131e0 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x690>
#endif
          }
          else if (flags & FLAGS_LONG) {
   1314c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   1314e:	f403 7380 	and.w	r3, r3, #256	; 0x100
   13152:	2b00      	cmp	r3, #0
   13154:	d016      	beq.n	13184 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x634>
            idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
   13156:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   13158:	1d1a      	adds	r2, r3, #4
   1315a:	66ba      	str	r2, [r7, #104]	; 0x68
   1315c:	681b      	ldr	r3, [r3, #0]
   1315e:	6d7a      	ldr	r2, [r7, #84]	; 0x54
   13160:	9205      	str	r2, [sp, #20]
   13162:	6d3a      	ldr	r2, [r7, #80]	; 0x50
   13164:	9204      	str	r2, [sp, #16]
   13166:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
   13168:	9203      	str	r2, [sp, #12]
   1316a:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   1316c:	9202      	str	r2, [sp, #8]
   1316e:	2200      	movs	r2, #0
   13170:	9201      	str	r2, [sp, #4]
   13172:	9300      	str	r3, [sp, #0]
   13174:	687b      	ldr	r3, [r7, #4]
   13176:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   13178:	68b9      	ldr	r1, [r7, #8]
   1317a:	68f8      	ldr	r0, [r7, #12]
   1317c:	f7ff f9ed 	bl	1255a <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)>
   13180:	6478      	str	r0, [r7, #68]	; 0x44
   13182:	e02d      	b.n	131e0 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x690>
          }
          else {
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
   13184:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   13186:	f003 0340 	and.w	r3, r3, #64	; 0x40
   1318a:	2b00      	cmp	r3, #0
   1318c:	d005      	beq.n	1319a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x64a>
   1318e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   13190:	1d1a      	adds	r2, r3, #4
   13192:	66ba      	str	r2, [r7, #104]	; 0x68
   13194:	681b      	ldr	r3, [r3, #0]
   13196:	b2db      	uxtb	r3, r3
   13198:	e00e      	b.n	131b8 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x668>
   1319a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   1319c:	f003 0380 	and.w	r3, r3, #128	; 0x80
   131a0:	2b00      	cmp	r3, #0
   131a2:	d005      	beq.n	131b0 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x660>
   131a4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   131a6:	1d1a      	adds	r2, r3, #4
   131a8:	66ba      	str	r2, [r7, #104]	; 0x68
   131aa:	681b      	ldr	r3, [r3, #0]
   131ac:	b29b      	uxth	r3, r3
   131ae:	e003      	b.n	131b8 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x668>
   131b0:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   131b2:	1d1a      	adds	r2, r3, #4
   131b4:	66ba      	str	r2, [r7, #104]	; 0x68
   131b6:	681b      	ldr	r3, [r3, #0]
   131b8:	627b      	str	r3, [r7, #36]	; 0x24
            idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);
   131ba:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   131bc:	9305      	str	r3, [sp, #20]
   131be:	6d3b      	ldr	r3, [r7, #80]	; 0x50
   131c0:	9304      	str	r3, [sp, #16]
   131c2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   131c4:	9303      	str	r3, [sp, #12]
   131c6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   131c8:	9302      	str	r3, [sp, #8]
   131ca:	2300      	movs	r3, #0
   131cc:	9301      	str	r3, [sp, #4]
   131ce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   131d0:	9300      	str	r3, [sp, #0]
   131d2:	687b      	ldr	r3, [r7, #4]
   131d4:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   131d6:	68b9      	ldr	r1, [r7, #8]
   131d8:	68f8      	ldr	r0, [r7, #12]
   131da:	f7ff f9be 	bl	1255a <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)>
   131de:	6478      	str	r0, [r7, #68]	; 0x44
          }
        }
        format++;
   131e0:	683b      	ldr	r3, [r7, #0]
   131e2:	3301      	adds	r3, #1
   131e4:	603b      	str	r3, [r7, #0]
        break;
   131e6:	e109      	b.n	133fc <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8ac>
      }
#if defined(PRINTF_SUPPORT_FLOAT)
      case 'f' :
      case 'F' :
        idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
   131e8:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   131ea:	3307      	adds	r3, #7
   131ec:	f023 0307 	bic.w	r3, r3, #7
   131f0:	f103 0208 	add.w	r2, r3, #8
   131f4:	66ba      	str	r2, [r7, #104]	; 0x68
   131f6:	ed93 7b00 	vldr	d7, [r3]
   131fa:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   131fc:	9302      	str	r3, [sp, #8]
   131fe:	6d3b      	ldr	r3, [r7, #80]	; 0x50
   13200:	9301      	str	r3, [sp, #4]
   13202:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   13204:	9300      	str	r3, [sp, #0]
   13206:	eeb0 0a47 	vmov.f32	s0, s14
   1320a:	eef0 0a67 	vmov.f32	s1, s15
   1320e:	687b      	ldr	r3, [r7, #4]
   13210:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   13212:	68b9      	ldr	r1, [r7, #8]
   13214:	68f8      	ldr	r0, [r7, #12]
   13216:	f7ff fa79 	bl	1270c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)>
   1321a:	6478      	str	r0, [r7, #68]	; 0x44
        format++;
   1321c:	683b      	ldr	r3, [r7, #0]
   1321e:	3301      	adds	r3, #1
   13220:	603b      	str	r3, [r7, #0]
        break;
   13222:	e0eb      	b.n	133fc <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8ac>
#endif  // PRINTF_SUPPORT_FLOAT
      case 'c' : {
        unsigned int l = 1U;
   13224:	2301      	movs	r3, #1
   13226:	63fb      	str	r3, [r7, #60]	; 0x3c
        // pre padding
        if (!(flags & FLAGS_LEFT)) {
   13228:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   1322a:	f003 0302 	and.w	r3, r3, #2
   1322e:	2b00      	cmp	r3, #0
   13230:	d113      	bne.n	1325a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x70a>
          while (l++ < width) {
   13232:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   13234:	1c5a      	adds	r2, r3, #1
   13236:	63fa      	str	r2, [r7, #60]	; 0x3c
   13238:	6d3a      	ldr	r2, [r7, #80]	; 0x50
   1323a:	429a      	cmp	r2, r3
   1323c:	bf8c      	ite	hi
   1323e:	2301      	movhi	r3, #1
   13240:	2300      	movls	r3, #0
   13242:	b2db      	uxtb	r3, r3
   13244:	2b00      	cmp	r3, #0
   13246:	d008      	beq.n	1325a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x70a>
            out(' ', buffer, idx++, maxlen);
   13248:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   1324a:	1c53      	adds	r3, r2, #1
   1324c:	647b      	str	r3, [r7, #68]	; 0x44
   1324e:	68fc      	ldr	r4, [r7, #12]
   13250:	687b      	ldr	r3, [r7, #4]
   13252:	68b9      	ldr	r1, [r7, #8]
   13254:	2020      	movs	r0, #32
   13256:	47a0      	blx	r4
          while (l++ < width) {
   13258:	e7eb      	b.n	13232 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x6e2>
          }
        }
        // char output
        out((char)va_arg(va, int), buffer, idx++, maxlen);
   1325a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   1325c:	1d1a      	adds	r2, r3, #4
   1325e:	66ba      	str	r2, [r7, #104]	; 0x68
   13260:	681b      	ldr	r3, [r3, #0]
   13262:	b2d8      	uxtb	r0, r3
   13264:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   13266:	1c53      	adds	r3, r2, #1
   13268:	647b      	str	r3, [r7, #68]	; 0x44
   1326a:	68fc      	ldr	r4, [r7, #12]
   1326c:	687b      	ldr	r3, [r7, #4]
   1326e:	68b9      	ldr	r1, [r7, #8]
   13270:	47a0      	blx	r4
        // post padding
        if (flags & FLAGS_LEFT) {
   13272:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   13274:	f003 0302 	and.w	r3, r3, #2
   13278:	2b00      	cmp	r3, #0
   1327a:	d013      	beq.n	132a4 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x754>
          while (l++ < width) {
   1327c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   1327e:	1c5a      	adds	r2, r3, #1
   13280:	63fa      	str	r2, [r7, #60]	; 0x3c
   13282:	6d3a      	ldr	r2, [r7, #80]	; 0x50
   13284:	429a      	cmp	r2, r3
   13286:	bf8c      	ite	hi
   13288:	2301      	movhi	r3, #1
   1328a:	2300      	movls	r3, #0
   1328c:	b2db      	uxtb	r3, r3
   1328e:	2b00      	cmp	r3, #0
   13290:	d008      	beq.n	132a4 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x754>
            out(' ', buffer, idx++, maxlen);
   13292:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   13294:	1c53      	adds	r3, r2, #1
   13296:	647b      	str	r3, [r7, #68]	; 0x44
   13298:	68fc      	ldr	r4, [r7, #12]
   1329a:	687b      	ldr	r3, [r7, #4]
   1329c:	68b9      	ldr	r1, [r7, #8]
   1329e:	2020      	movs	r0, #32
   132a0:	47a0      	blx	r4
          while (l++ < width) {
   132a2:	e7eb      	b.n	1327c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x72c>
          }
        }
        format++;
   132a4:	683b      	ldr	r3, [r7, #0]
   132a6:	3301      	adds	r3, #1
   132a8:	603b      	str	r3, [r7, #0]
        break;
   132aa:	e0a7      	b.n	133fc <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8ac>
      }

      case 's' : {
        char* p = va_arg(va, char*);
   132ac:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   132ae:	1d1a      	adds	r2, r3, #4
   132b0:	66ba      	str	r2, [r7, #104]	; 0x68
   132b2:	681b      	ldr	r3, [r3, #0]
   132b4:	63bb      	str	r3, [r7, #56]	; 0x38
        unsigned int l = _strlen(p);
   132b6:	6bb8      	ldr	r0, [r7, #56]	; 0x38
   132b8:	f7fe ffdf 	bl	1227a <_strlen(char const*)>
   132bc:	6378      	str	r0, [r7, #52]	; 0x34
        // pre padding
        if (flags & FLAGS_PRECISION) {
   132be:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   132c0:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   132c4:	2b00      	cmp	r3, #0
   132c6:	d007      	beq.n	132d8 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x788>
          l = (l < precision ? l : precision);
   132c8:	6b7a      	ldr	r2, [r7, #52]	; 0x34
   132ca:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   132cc:	429a      	cmp	r2, r3
   132ce:	d201      	bcs.n	132d4 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x784>
   132d0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   132d2:	e000      	b.n	132d6 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x786>
   132d4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   132d6:	637b      	str	r3, [r7, #52]	; 0x34
        }
        if (!(flags & FLAGS_LEFT)) {
   132d8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   132da:	f003 0302 	and.w	r3, r3, #2
   132de:	2b00      	cmp	r3, #0
   132e0:	d113      	bne.n	1330a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7ba>
          while (l++ < width) {
   132e2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   132e4:	1c5a      	adds	r2, r3, #1
   132e6:	637a      	str	r2, [r7, #52]	; 0x34
   132e8:	6d3a      	ldr	r2, [r7, #80]	; 0x50
   132ea:	429a      	cmp	r2, r3
   132ec:	bf8c      	ite	hi
   132ee:	2301      	movhi	r3, #1
   132f0:	2300      	movls	r3, #0
   132f2:	b2db      	uxtb	r3, r3
   132f4:	2b00      	cmp	r3, #0
   132f6:	d008      	beq.n	1330a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7ba>
            out(' ', buffer, idx++, maxlen);
   132f8:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   132fa:	1c53      	adds	r3, r2, #1
   132fc:	647b      	str	r3, [r7, #68]	; 0x44
   132fe:	68fc      	ldr	r4, [r7, #12]
   13300:	687b      	ldr	r3, [r7, #4]
   13302:	68b9      	ldr	r1, [r7, #8]
   13304:	2020      	movs	r0, #32
   13306:	47a0      	blx	r4
          while (l++ < width) {
   13308:	e7eb      	b.n	132e2 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x792>
          }
        }
        // string output
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
   1330a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1330c:	781b      	ldrb	r3, [r3, #0]
   1330e:	2b00      	cmp	r3, #0
   13310:	d00b      	beq.n	1332a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7da>
   13312:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   13314:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   13318:	2b00      	cmp	r3, #0
   1331a:	d004      	beq.n	13326 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7d6>
   1331c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   1331e:	1e5a      	subs	r2, r3, #1
   13320:	64fa      	str	r2, [r7, #76]	; 0x4c
   13322:	2b00      	cmp	r3, #0
   13324:	d001      	beq.n	1332a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7da>
   13326:	2301      	movs	r3, #1
   13328:	e000      	b.n	1332c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7dc>
   1332a:	2300      	movs	r3, #0
   1332c:	2b00      	cmp	r3, #0
   1332e:	d00b      	beq.n	13348 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7f8>
          out(*(p++), buffer, idx++, maxlen);
   13330:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   13332:	1c5a      	adds	r2, r3, #1
   13334:	63ba      	str	r2, [r7, #56]	; 0x38
   13336:	7818      	ldrb	r0, [r3, #0]
   13338:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   1333a:	1c53      	adds	r3, r2, #1
   1333c:	647b      	str	r3, [r7, #68]	; 0x44
   1333e:	68fc      	ldr	r4, [r7, #12]
   13340:	687b      	ldr	r3, [r7, #4]
   13342:	68b9      	ldr	r1, [r7, #8]
   13344:	47a0      	blx	r4
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
   13346:	e7e0      	b.n	1330a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7ba>
        }
        // post padding
        if (flags & FLAGS_LEFT) {
   13348:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   1334a:	f003 0302 	and.w	r3, r3, #2
   1334e:	2b00      	cmp	r3, #0
   13350:	d013      	beq.n	1337a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x82a>
          while (l++ < width) {
   13352:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   13354:	1c5a      	adds	r2, r3, #1
   13356:	637a      	str	r2, [r7, #52]	; 0x34
   13358:	6d3a      	ldr	r2, [r7, #80]	; 0x50
   1335a:	429a      	cmp	r2, r3
   1335c:	bf8c      	ite	hi
   1335e:	2301      	movhi	r3, #1
   13360:	2300      	movls	r3, #0
   13362:	b2db      	uxtb	r3, r3
   13364:	2b00      	cmp	r3, #0
   13366:	d008      	beq.n	1337a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x82a>
            out(' ', buffer, idx++, maxlen);
   13368:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   1336a:	1c53      	adds	r3, r2, #1
   1336c:	647b      	str	r3, [r7, #68]	; 0x44
   1336e:	68fc      	ldr	r4, [r7, #12]
   13370:	687b      	ldr	r3, [r7, #4]
   13372:	68b9      	ldr	r1, [r7, #8]
   13374:	2020      	movs	r0, #32
   13376:	47a0      	blx	r4
          while (l++ < width) {
   13378:	e7eb      	b.n	13352 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x802>
          }
        }
        format++;
   1337a:	683b      	ldr	r3, [r7, #0]
   1337c:	3301      	adds	r3, #1
   1337e:	603b      	str	r3, [r7, #0]
        break;
   13380:	e03c      	b.n	133fc <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8ac>
      }

      case 'p' : {
        width = sizeof(void*) * 2U;
   13382:	2308      	movs	r3, #8
   13384:	653b      	str	r3, [r7, #80]	; 0x50
        flags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;
   13386:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   13388:	f043 0321 	orr.w	r3, r3, #33	; 0x21
   1338c:	657b      	str	r3, [r7, #84]	; 0x54
#if defined(PRINTF_SUPPORT_LONG_LONG)
        const bool is_ll = sizeof(uintptr_t) == sizeof(long long);
   1338e:	2300      	movs	r3, #0
   13390:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
        if (is_ll) {
          idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);
        }
        else {
#endif
          idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)((uintptr_t)va_arg(va, void*)), false, 16U, precision, width, flags);
   13394:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   13396:	1d1a      	adds	r2, r3, #4
   13398:	66ba      	str	r2, [r7, #104]	; 0x68
   1339a:	681b      	ldr	r3, [r3, #0]
   1339c:	461a      	mov	r2, r3
   1339e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   133a0:	9305      	str	r3, [sp, #20]
   133a2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
   133a4:	9304      	str	r3, [sp, #16]
   133a6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   133a8:	9303      	str	r3, [sp, #12]
   133aa:	2310      	movs	r3, #16
   133ac:	9302      	str	r3, [sp, #8]
   133ae:	2300      	movs	r3, #0
   133b0:	9301      	str	r3, [sp, #4]
   133b2:	9200      	str	r2, [sp, #0]
   133b4:	687b      	ldr	r3, [r7, #4]
   133b6:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   133b8:	68b9      	ldr	r1, [r7, #8]
   133ba:	68f8      	ldr	r0, [r7, #12]
   133bc:	f7ff f8cd 	bl	1255a <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)>
   133c0:	6478      	str	r0, [r7, #68]	; 0x44
#if defined(PRINTF_SUPPORT_LONG_LONG)
        }
#endif
        format++;
   133c2:	683b      	ldr	r3, [r7, #0]
   133c4:	3301      	adds	r3, #1
   133c6:	603b      	str	r3, [r7, #0]
        break;
   133c8:	e018      	b.n	133fc <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8ac>
      }

      case '%' :
        out('%', buffer, idx++, maxlen);
   133ca:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   133cc:	1c53      	adds	r3, r2, #1
   133ce:	647b      	str	r3, [r7, #68]	; 0x44
   133d0:	68fc      	ldr	r4, [r7, #12]
   133d2:	687b      	ldr	r3, [r7, #4]
   133d4:	68b9      	ldr	r1, [r7, #8]
   133d6:	2025      	movs	r0, #37	; 0x25
   133d8:	47a0      	blx	r4
        format++;
   133da:	683b      	ldr	r3, [r7, #0]
   133dc:	3301      	adds	r3, #1
   133de:	603b      	str	r3, [r7, #0]
        break;
   133e0:	e00c      	b.n	133fc <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8ac>

      default :
        out(*format, buffer, idx++, maxlen);
   133e2:	683b      	ldr	r3, [r7, #0]
   133e4:	7818      	ldrb	r0, [r3, #0]
   133e6:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   133e8:	1c53      	adds	r3, r2, #1
   133ea:	647b      	str	r3, [r7, #68]	; 0x44
   133ec:	68fc      	ldr	r4, [r7, #12]
   133ee:	687b      	ldr	r3, [r7, #4]
   133f0:	68b9      	ldr	r1, [r7, #8]
   133f2:	47a0      	blx	r4
        format++;
   133f4:	683b      	ldr	r3, [r7, #0]
   133f6:	3301      	adds	r3, #1
   133f8:	603b      	str	r3, [r7, #0]
        break;
   133fa:	bf00      	nop
  while (*format)
   133fc:	f7ff bbb6 	b.w	12b6c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x1c>
    }
  }

  // termination
  out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);
   13400:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   13402:	687b      	ldr	r3, [r7, #4]
   13404:	429a      	cmp	r2, r3
   13406:	d302      	bcc.n	1340e <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8be>
   13408:	687b      	ldr	r3, [r7, #4]
   1340a:	1e5a      	subs	r2, r3, #1
   1340c:	e000      	b.n	13410 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8c0>
   1340e:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   13410:	68fc      	ldr	r4, [r7, #12]
   13412:	687b      	ldr	r3, [r7, #4]
   13414:	68b9      	ldr	r1, [r7, #8]
   13416:	2000      	movs	r0, #0
   13418:	47a0      	blx	r4

  // return written chars without terminating \0
  return (int)idx;
   1341a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
}
   1341c:	4618      	mov	r0, r3
   1341e:	3758      	adds	r7, #88	; 0x58
   13420:	46bd      	mov	sp, r7
   13422:	bdb0      	pop	{r4, r5, r7, pc}

00013424 <printf>:

///////////////////////////////////////////////////////////////////////////////


int printf(const char* format, ...)
{
   13424:	b40f      	push	{r0, r1, r2, r3}
   13426:	b580      	push	{r7, lr}
   13428:	b086      	sub	sp, #24
   1342a:	af02      	add	r7, sp, #8
  va_list va;
  va_start(va, format);
   1342c:	f107 031c 	add.w	r3, r7, #28
   13430:	60bb      	str	r3, [r7, #8]
  char buffer[1];
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
   13432:	1d39      	adds	r1, r7, #4
   13434:	68bb      	ldr	r3, [r7, #8]
   13436:	9300      	str	r3, [sp, #0]
   13438:	69bb      	ldr	r3, [r7, #24]
   1343a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1343e:	4806      	ldr	r0, [pc, #24]	; (13458 <printf+0x34>)
   13440:	f7ff fb86 	bl	12b50 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)>
   13444:	60f8      	str	r0, [r7, #12]
  va_end(va);
  return ret;
   13446:	68fb      	ldr	r3, [r7, #12]
}
   13448:	4618      	mov	r0, r3
   1344a:	3710      	adds	r7, #16
   1344c:	46bd      	mov	sp, r7
   1344e:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
   13452:	b004      	add	sp, #16
   13454:	4770      	bx	lr
   13456:	bf00      	nop
   13458:	00012255 	.word	0x00012255

0001345c <__cxa_pure_virtual>:
   1345c:	b508      	push	{r3, lr}
   1345e:	f000 f80d 	bl	1347c <std::terminate()>

00013462 <__cxxabiv1::__terminate(void (*)())>:
   13462:	b508      	push	{r3, lr}
   13464:	4780      	blx	r0
   13466:	f001 f965 	bl	14734 <abort>
   1346a:	Address 0x000000000001346a is out of bounds.


0001346c <std::get_terminate()>:
   1346c:	4b02      	ldr	r3, [pc, #8]	; (13478 <std::get_terminate()+0xc>)
   1346e:	6818      	ldr	r0, [r3, #0]
   13470:	f3bf 8f5b 	dmb	ish
   13474:	4770      	bx	lr
   13476:	bf00      	nop
   13478:	10000188 	.word	0x10000188

0001347c <std::terminate()>:
   1347c:	b508      	push	{r3, lr}
   1347e:	f7ff fff5 	bl	1346c <std::get_terminate()>
   13482:	f7ff ffee 	bl	13462 <__cxxabiv1::__terminate(void (*)())>
   13486:	Address 0x0000000000013486 is out of bounds.


00013488 <__aeabi_d2f>:
   13488:	ea4f 0241 	mov.w	r2, r1, lsl #1
   1348c:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
   13490:	bf24      	itt	cs
   13492:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
   13496:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
   1349a:	d90d      	bls.n	134b8 <__aeabi_d2f+0x30>
   1349c:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
   134a0:	ea4f 02c0 	mov.w	r2, r0, lsl #3
   134a4:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
   134a8:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
   134ac:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
   134b0:	bf08      	it	eq
   134b2:	f020 0001 	biceq.w	r0, r0, #1
   134b6:	4770      	bx	lr
   134b8:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
   134bc:	d121      	bne.n	13502 <__aeabi_d2f+0x7a>
   134be:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
   134c2:	bfbc      	itt	lt
   134c4:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
   134c8:	4770      	bxlt	lr
   134ca:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   134ce:	ea4f 5252 	mov.w	r2, r2, lsr #21
   134d2:	f1c2 0218 	rsb	r2, r2, #24
   134d6:	f1c2 0c20 	rsb	ip, r2, #32
   134da:	fa10 f30c 	lsls.w	r3, r0, ip
   134de:	fa20 f002 	lsr.w	r0, r0, r2
   134e2:	bf18      	it	ne
   134e4:	f040 0001 	orrne.w	r0, r0, #1
   134e8:	ea4f 23c1 	mov.w	r3, r1, lsl #11
   134ec:	ea4f 23d3 	mov.w	r3, r3, lsr #11
   134f0:	fa03 fc0c 	lsl.w	ip, r3, ip
   134f4:	ea40 000c 	orr.w	r0, r0, ip
   134f8:	fa23 f302 	lsr.w	r3, r3, r2
   134fc:	ea4f 0343 	mov.w	r3, r3, lsl #1
   13500:	e7cc      	b.n	1349c <__aeabi_d2f+0x14>
   13502:	ea7f 5362 	mvns.w	r3, r2, asr #21
   13506:	d107      	bne.n	13518 <__aeabi_d2f+0x90>
   13508:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
   1350c:	bf1e      	ittt	ne
   1350e:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
   13512:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
   13516:	4770      	bxne	lr
   13518:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
   1351c:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
   13520:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   13524:	4770      	bx	lr
   13526:	bf00      	nop

00013528 <__aeabi_uldivmod>:
   13528:	b953      	cbnz	r3, 13540 <__aeabi_uldivmod+0x18>
   1352a:	b94a      	cbnz	r2, 13540 <__aeabi_uldivmod+0x18>
   1352c:	2900      	cmp	r1, #0
   1352e:	bf08      	it	eq
   13530:	2800      	cmpeq	r0, #0
   13532:	bf1c      	itt	ne
   13534:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
   13538:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
   1353c:	f001 b8f8 	b.w	14730 <__aeabi_idiv0>
   13540:	f1ad 0c08 	sub.w	ip, sp, #8
   13544:	e96d ce04 	strd	ip, lr, [sp, #-16]!
   13548:	f000 f806 	bl	13558 <__udivmoddi4>
   1354c:	f8dd e004 	ldr.w	lr, [sp, #4]
   13550:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   13554:	b004      	add	sp, #16
   13556:	4770      	bx	lr

00013558 <__udivmoddi4>:
   13558:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1355c:	9e08      	ldr	r6, [sp, #32]
   1355e:	4604      	mov	r4, r0
   13560:	4688      	mov	r8, r1
   13562:	2b00      	cmp	r3, #0
   13564:	d14b      	bne.n	135fe <__udivmoddi4+0xa6>
   13566:	428a      	cmp	r2, r1
   13568:	4615      	mov	r5, r2
   1356a:	d967      	bls.n	1363c <__udivmoddi4+0xe4>
   1356c:	fab2 f282 	clz	r2, r2
   13570:	b14a      	cbz	r2, 13586 <__udivmoddi4+0x2e>
   13572:	f1c2 0720 	rsb	r7, r2, #32
   13576:	fa01 f302 	lsl.w	r3, r1, r2
   1357a:	fa20 f707 	lsr.w	r7, r0, r7
   1357e:	4095      	lsls	r5, r2
   13580:	ea47 0803 	orr.w	r8, r7, r3
   13584:	4094      	lsls	r4, r2
   13586:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   1358a:	0c23      	lsrs	r3, r4, #16
   1358c:	fbb8 f7fe 	udiv	r7, r8, lr
   13590:	fa1f fc85 	uxth.w	ip, r5
   13594:	fb0e 8817 	mls	r8, lr, r7, r8
   13598:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
   1359c:	fb07 f10c 	mul.w	r1, r7, ip
   135a0:	4299      	cmp	r1, r3
   135a2:	d909      	bls.n	135b8 <__udivmoddi4+0x60>
   135a4:	18eb      	adds	r3, r5, r3
   135a6:	f107 30ff 	add.w	r0, r7, #4294967295	; 0xffffffff
   135aa:	f080 811b 	bcs.w	137e4 <__udivmoddi4+0x28c>
   135ae:	4299      	cmp	r1, r3
   135b0:	f240 8118 	bls.w	137e4 <__udivmoddi4+0x28c>
   135b4:	3f02      	subs	r7, #2
   135b6:	442b      	add	r3, r5
   135b8:	1a5b      	subs	r3, r3, r1
   135ba:	b2a4      	uxth	r4, r4
   135bc:	fbb3 f0fe 	udiv	r0, r3, lr
   135c0:	fb0e 3310 	mls	r3, lr, r0, r3
   135c4:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
   135c8:	fb00 fc0c 	mul.w	ip, r0, ip
   135cc:	45a4      	cmp	ip, r4
   135ce:	d909      	bls.n	135e4 <__udivmoddi4+0x8c>
   135d0:	192c      	adds	r4, r5, r4
   135d2:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   135d6:	f080 8107 	bcs.w	137e8 <__udivmoddi4+0x290>
   135da:	45a4      	cmp	ip, r4
   135dc:	f240 8104 	bls.w	137e8 <__udivmoddi4+0x290>
   135e0:	3802      	subs	r0, #2
   135e2:	442c      	add	r4, r5
   135e4:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
   135e8:	eba4 040c 	sub.w	r4, r4, ip
   135ec:	2700      	movs	r7, #0
   135ee:	b11e      	cbz	r6, 135f8 <__udivmoddi4+0xa0>
   135f0:	40d4      	lsrs	r4, r2
   135f2:	2300      	movs	r3, #0
   135f4:	e9c6 4300 	strd	r4, r3, [r6]
   135f8:	4639      	mov	r1, r7
   135fa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   135fe:	428b      	cmp	r3, r1
   13600:	d909      	bls.n	13616 <__udivmoddi4+0xbe>
   13602:	2e00      	cmp	r6, #0
   13604:	f000 80eb 	beq.w	137de <__udivmoddi4+0x286>
   13608:	2700      	movs	r7, #0
   1360a:	e9c6 0100 	strd	r0, r1, [r6]
   1360e:	4638      	mov	r0, r7
   13610:	4639      	mov	r1, r7
   13612:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   13616:	fab3 f783 	clz	r7, r3
   1361a:	2f00      	cmp	r7, #0
   1361c:	d147      	bne.n	136ae <__udivmoddi4+0x156>
   1361e:	428b      	cmp	r3, r1
   13620:	d302      	bcc.n	13628 <__udivmoddi4+0xd0>
   13622:	4282      	cmp	r2, r0
   13624:	f200 80fa 	bhi.w	1381c <__udivmoddi4+0x2c4>
   13628:	1a84      	subs	r4, r0, r2
   1362a:	eb61 0303 	sbc.w	r3, r1, r3
   1362e:	2001      	movs	r0, #1
   13630:	4698      	mov	r8, r3
   13632:	2e00      	cmp	r6, #0
   13634:	d0e0      	beq.n	135f8 <__udivmoddi4+0xa0>
   13636:	e9c6 4800 	strd	r4, r8, [r6]
   1363a:	e7dd      	b.n	135f8 <__udivmoddi4+0xa0>
   1363c:	b902      	cbnz	r2, 13640 <__udivmoddi4+0xe8>
   1363e:	deff      	udf	#255	; 0xff
   13640:	fab2 f282 	clz	r2, r2
   13644:	2a00      	cmp	r2, #0
   13646:	f040 808f 	bne.w	13768 <__udivmoddi4+0x210>
   1364a:	1b49      	subs	r1, r1, r5
   1364c:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   13650:	fa1f f885 	uxth.w	r8, r5
   13654:	2701      	movs	r7, #1
   13656:	fbb1 fcfe 	udiv	ip, r1, lr
   1365a:	0c23      	lsrs	r3, r4, #16
   1365c:	fb0e 111c 	mls	r1, lr, ip, r1
   13660:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
   13664:	fb08 f10c 	mul.w	r1, r8, ip
   13668:	4299      	cmp	r1, r3
   1366a:	d907      	bls.n	1367c <__udivmoddi4+0x124>
   1366c:	18eb      	adds	r3, r5, r3
   1366e:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
   13672:	d202      	bcs.n	1367a <__udivmoddi4+0x122>
   13674:	4299      	cmp	r1, r3
   13676:	f200 80cd 	bhi.w	13814 <__udivmoddi4+0x2bc>
   1367a:	4684      	mov	ip, r0
   1367c:	1a59      	subs	r1, r3, r1
   1367e:	b2a3      	uxth	r3, r4
   13680:	fbb1 f0fe 	udiv	r0, r1, lr
   13684:	fb0e 1410 	mls	r4, lr, r0, r1
   13688:	ea43 4404 	orr.w	r4, r3, r4, lsl #16
   1368c:	fb08 f800 	mul.w	r8, r8, r0
   13690:	45a0      	cmp	r8, r4
   13692:	d907      	bls.n	136a4 <__udivmoddi4+0x14c>
   13694:	192c      	adds	r4, r5, r4
   13696:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   1369a:	d202      	bcs.n	136a2 <__udivmoddi4+0x14a>
   1369c:	45a0      	cmp	r8, r4
   1369e:	f200 80b6 	bhi.w	1380e <__udivmoddi4+0x2b6>
   136a2:	4618      	mov	r0, r3
   136a4:	eba4 0408 	sub.w	r4, r4, r8
   136a8:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
   136ac:	e79f      	b.n	135ee <__udivmoddi4+0x96>
   136ae:	f1c7 0c20 	rsb	ip, r7, #32
   136b2:	40bb      	lsls	r3, r7
   136b4:	fa22 fe0c 	lsr.w	lr, r2, ip
   136b8:	ea4e 0e03 	orr.w	lr, lr, r3
   136bc:	fa01 f407 	lsl.w	r4, r1, r7
   136c0:	fa20 f50c 	lsr.w	r5, r0, ip
   136c4:	fa21 f30c 	lsr.w	r3, r1, ip
   136c8:	ea4f 481e 	mov.w	r8, lr, lsr #16
   136cc:	4325      	orrs	r5, r4
   136ce:	fbb3 f9f8 	udiv	r9, r3, r8
   136d2:	0c2c      	lsrs	r4, r5, #16
   136d4:	fb08 3319 	mls	r3, r8, r9, r3
   136d8:	fa1f fa8e 	uxth.w	sl, lr
   136dc:	ea44 4303 	orr.w	r3, r4, r3, lsl #16
   136e0:	fb09 f40a 	mul.w	r4, r9, sl
   136e4:	429c      	cmp	r4, r3
   136e6:	fa02 f207 	lsl.w	r2, r2, r7
   136ea:	fa00 f107 	lsl.w	r1, r0, r7
   136ee:	d90b      	bls.n	13708 <__udivmoddi4+0x1b0>
   136f0:	eb1e 0303 	adds.w	r3, lr, r3
   136f4:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
   136f8:	f080 8087 	bcs.w	1380a <__udivmoddi4+0x2b2>
   136fc:	429c      	cmp	r4, r3
   136fe:	f240 8084 	bls.w	1380a <__udivmoddi4+0x2b2>
   13702:	f1a9 0902 	sub.w	r9, r9, #2
   13706:	4473      	add	r3, lr
   13708:	1b1b      	subs	r3, r3, r4
   1370a:	b2ad      	uxth	r5, r5
   1370c:	fbb3 f0f8 	udiv	r0, r3, r8
   13710:	fb08 3310 	mls	r3, r8, r0, r3
   13714:	ea45 4403 	orr.w	r4, r5, r3, lsl #16
   13718:	fb00 fa0a 	mul.w	sl, r0, sl
   1371c:	45a2      	cmp	sl, r4
   1371e:	d908      	bls.n	13732 <__udivmoddi4+0x1da>
   13720:	eb1e 0404 	adds.w	r4, lr, r4
   13724:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   13728:	d26b      	bcs.n	13802 <__udivmoddi4+0x2aa>
   1372a:	45a2      	cmp	sl, r4
   1372c:	d969      	bls.n	13802 <__udivmoddi4+0x2aa>
   1372e:	3802      	subs	r0, #2
   13730:	4474      	add	r4, lr
   13732:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
   13736:	fba0 8902 	umull	r8, r9, r0, r2
   1373a:	eba4 040a 	sub.w	r4, r4, sl
   1373e:	454c      	cmp	r4, r9
   13740:	46c2      	mov	sl, r8
   13742:	464b      	mov	r3, r9
   13744:	d354      	bcc.n	137f0 <__udivmoddi4+0x298>
   13746:	d051      	beq.n	137ec <__udivmoddi4+0x294>
   13748:	2e00      	cmp	r6, #0
   1374a:	d069      	beq.n	13820 <__udivmoddi4+0x2c8>
   1374c:	ebb1 050a 	subs.w	r5, r1, sl
   13750:	eb64 0403 	sbc.w	r4, r4, r3
   13754:	fa04 fc0c 	lsl.w	ip, r4, ip
   13758:	40fd      	lsrs	r5, r7
   1375a:	40fc      	lsrs	r4, r7
   1375c:	ea4c 0505 	orr.w	r5, ip, r5
   13760:	e9c6 5400 	strd	r5, r4, [r6]
   13764:	2700      	movs	r7, #0
   13766:	e747      	b.n	135f8 <__udivmoddi4+0xa0>
   13768:	f1c2 0320 	rsb	r3, r2, #32
   1376c:	fa20 f703 	lsr.w	r7, r0, r3
   13770:	4095      	lsls	r5, r2
   13772:	fa01 f002 	lsl.w	r0, r1, r2
   13776:	fa21 f303 	lsr.w	r3, r1, r3
   1377a:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   1377e:	4338      	orrs	r0, r7
   13780:	0c01      	lsrs	r1, r0, #16
   13782:	fbb3 f7fe 	udiv	r7, r3, lr
   13786:	fa1f f885 	uxth.w	r8, r5
   1378a:	fb0e 3317 	mls	r3, lr, r7, r3
   1378e:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
   13792:	fb07 f308 	mul.w	r3, r7, r8
   13796:	428b      	cmp	r3, r1
   13798:	fa04 f402 	lsl.w	r4, r4, r2
   1379c:	d907      	bls.n	137ae <__udivmoddi4+0x256>
   1379e:	1869      	adds	r1, r5, r1
   137a0:	f107 3cff 	add.w	ip, r7, #4294967295	; 0xffffffff
   137a4:	d22f      	bcs.n	13806 <__udivmoddi4+0x2ae>
   137a6:	428b      	cmp	r3, r1
   137a8:	d92d      	bls.n	13806 <__udivmoddi4+0x2ae>
   137aa:	3f02      	subs	r7, #2
   137ac:	4429      	add	r1, r5
   137ae:	1acb      	subs	r3, r1, r3
   137b0:	b281      	uxth	r1, r0
   137b2:	fbb3 f0fe 	udiv	r0, r3, lr
   137b6:	fb0e 3310 	mls	r3, lr, r0, r3
   137ba:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
   137be:	fb00 f308 	mul.w	r3, r0, r8
   137c2:	428b      	cmp	r3, r1
   137c4:	d907      	bls.n	137d6 <__udivmoddi4+0x27e>
   137c6:	1869      	adds	r1, r5, r1
   137c8:	f100 3cff 	add.w	ip, r0, #4294967295	; 0xffffffff
   137cc:	d217      	bcs.n	137fe <__udivmoddi4+0x2a6>
   137ce:	428b      	cmp	r3, r1
   137d0:	d915      	bls.n	137fe <__udivmoddi4+0x2a6>
   137d2:	3802      	subs	r0, #2
   137d4:	4429      	add	r1, r5
   137d6:	1ac9      	subs	r1, r1, r3
   137d8:	ea40 4707 	orr.w	r7, r0, r7, lsl #16
   137dc:	e73b      	b.n	13656 <__udivmoddi4+0xfe>
   137de:	4637      	mov	r7, r6
   137e0:	4630      	mov	r0, r6
   137e2:	e709      	b.n	135f8 <__udivmoddi4+0xa0>
   137e4:	4607      	mov	r7, r0
   137e6:	e6e7      	b.n	135b8 <__udivmoddi4+0x60>
   137e8:	4618      	mov	r0, r3
   137ea:	e6fb      	b.n	135e4 <__udivmoddi4+0x8c>
   137ec:	4541      	cmp	r1, r8
   137ee:	d2ab      	bcs.n	13748 <__udivmoddi4+0x1f0>
   137f0:	ebb8 0a02 	subs.w	sl, r8, r2
   137f4:	eb69 020e 	sbc.w	r2, r9, lr
   137f8:	3801      	subs	r0, #1
   137fa:	4613      	mov	r3, r2
   137fc:	e7a4      	b.n	13748 <__udivmoddi4+0x1f0>
   137fe:	4660      	mov	r0, ip
   13800:	e7e9      	b.n	137d6 <__udivmoddi4+0x27e>
   13802:	4618      	mov	r0, r3
   13804:	e795      	b.n	13732 <__udivmoddi4+0x1da>
   13806:	4667      	mov	r7, ip
   13808:	e7d1      	b.n	137ae <__udivmoddi4+0x256>
   1380a:	4681      	mov	r9, r0
   1380c:	e77c      	b.n	13708 <__udivmoddi4+0x1b0>
   1380e:	3802      	subs	r0, #2
   13810:	442c      	add	r4, r5
   13812:	e747      	b.n	136a4 <__udivmoddi4+0x14c>
   13814:	f1ac 0c02 	sub.w	ip, ip, #2
   13818:	442b      	add	r3, r5
   1381a:	e72f      	b.n	1367c <__udivmoddi4+0x124>
   1381c:	4638      	mov	r0, r7
   1381e:	e708      	b.n	13632 <__udivmoddi4+0xda>
   13820:	4637      	mov	r7, r6
   13822:	e6e9      	b.n	135f8 <__udivmoddi4+0xa0>

00013824 <selfrel_offset31>:
   13824:	6803      	ldr	r3, [r0, #0]
   13826:	005a      	lsls	r2, r3, #1
   13828:	bf4c      	ite	mi
   1382a:	f043 4300 	orrmi.w	r3, r3, #2147483648	; 0x80000000
   1382e:	f023 4300 	bicpl.w	r3, r3, #2147483648	; 0x80000000
   13832:	4418      	add	r0, r3
   13834:	4770      	bx	lr
   13836:	bf00      	nop

00013838 <search_EIT_table>:
   13838:	b361      	cbz	r1, 13894 <search_EIT_table+0x5c>
   1383a:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1383e:	f101 3aff 	add.w	sl, r1, #4294967295	; 0xffffffff
   13842:	4690      	mov	r8, r2
   13844:	4606      	mov	r6, r0
   13846:	46d1      	mov	r9, sl
   13848:	2700      	movs	r7, #0
   1384a:	eb07 0409 	add.w	r4, r7, r9
   1384e:	eb04 74d4 	add.w	r4, r4, r4, lsr #31
   13852:	1064      	asrs	r4, r4, #1
   13854:	00e5      	lsls	r5, r4, #3
   13856:	1971      	adds	r1, r6, r5
   13858:	4608      	mov	r0, r1
   1385a:	f7ff ffe3 	bl	13824 <selfrel_offset31>
   1385e:	45a2      	cmp	sl, r4
   13860:	4683      	mov	fp, r0
   13862:	f105 0008 	add.w	r0, r5, #8
   13866:	4430      	add	r0, r6
   13868:	d009      	beq.n	1387e <search_EIT_table+0x46>
   1386a:	f7ff ffdb 	bl	13824 <selfrel_offset31>
   1386e:	45c3      	cmp	fp, r8
   13870:	f100 30ff 	add.w	r0, r0, #4294967295	; 0xffffffff
   13874:	d805      	bhi.n	13882 <search_EIT_table+0x4a>
   13876:	4540      	cmp	r0, r8
   13878:	d209      	bcs.n	1388e <search_EIT_table+0x56>
   1387a:	1c67      	adds	r7, r4, #1
   1387c:	e7e5      	b.n	1384a <search_EIT_table+0x12>
   1387e:	45c3      	cmp	fp, r8
   13880:	d905      	bls.n	1388e <search_EIT_table+0x56>
   13882:	42a7      	cmp	r7, r4
   13884:	d002      	beq.n	1388c <search_EIT_table+0x54>
   13886:	f104 39ff 	add.w	r9, r4, #4294967295	; 0xffffffff
   1388a:	e7de      	b.n	1384a <search_EIT_table+0x12>
   1388c:	2100      	movs	r1, #0
   1388e:	4608      	mov	r0, r1
   13890:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   13894:	4608      	mov	r0, r1
   13896:	4770      	bx	lr

00013898 <__gnu_unwind_get_pr_addr>:
   13898:	2801      	cmp	r0, #1
   1389a:	d007      	beq.n	138ac <__gnu_unwind_get_pr_addr+0x14>
   1389c:	2802      	cmp	r0, #2
   1389e:	d007      	beq.n	138b0 <__gnu_unwind_get_pr_addr+0x18>
   138a0:	4b04      	ldr	r3, [pc, #16]	; (138b4 <__gnu_unwind_get_pr_addr+0x1c>)
   138a2:	2800      	cmp	r0, #0
   138a4:	bf0c      	ite	eq
   138a6:	4618      	moveq	r0, r3
   138a8:	2000      	movne	r0, #0
   138aa:	4770      	bx	lr
   138ac:	4802      	ldr	r0, [pc, #8]	; (138b8 <__gnu_unwind_get_pr_addr+0x20>)
   138ae:	4770      	bx	lr
   138b0:	4802      	ldr	r0, [pc, #8]	; (138bc <__gnu_unwind_get_pr_addr+0x24>)
   138b2:	4770      	bx	lr
   138b4:	00013f85 	.word	0x00013f85
   138b8:	00013f89 	.word	0x00013f89
   138bc:	00013f8d 	.word	0x00013f8d

000138c0 <get_eit_entry>:
   138c0:	b530      	push	{r4, r5, lr}
   138c2:	4b25      	ldr	r3, [pc, #148]	; (13958 <get_eit_entry+0x98>)
   138c4:	b083      	sub	sp, #12
   138c6:	4604      	mov	r4, r0
   138c8:	1e8d      	subs	r5, r1, #2
   138ca:	b34b      	cbz	r3, 13920 <get_eit_entry+0x60>
   138cc:	a901      	add	r1, sp, #4
   138ce:	4628      	mov	r0, r5
   138d0:	f3af 8000 	nop.w
   138d4:	b1f0      	cbz	r0, 13914 <get_eit_entry+0x54>
   138d6:	9901      	ldr	r1, [sp, #4]
   138d8:	462a      	mov	r2, r5
   138da:	f7ff ffad 	bl	13838 <search_EIT_table>
   138de:	4601      	mov	r1, r0
   138e0:	b1c0      	cbz	r0, 13914 <get_eit_entry+0x54>
   138e2:	f7ff ff9f 	bl	13824 <selfrel_offset31>
   138e6:	684b      	ldr	r3, [r1, #4]
   138e8:	64a0      	str	r0, [r4, #72]	; 0x48
   138ea:	2b01      	cmp	r3, #1
   138ec:	d02e      	beq.n	1394c <get_eit_entry+0x8c>
   138ee:	2b00      	cmp	r3, #0
   138f0:	f101 0004 	add.w	r0, r1, #4
   138f4:	db26      	blt.n	13944 <get_eit_entry+0x84>
   138f6:	f7ff ff95 	bl	13824 <selfrel_offset31>
   138fa:	2300      	movs	r3, #0
   138fc:	e9c4 0313 	strd	r0, r3, [r4, #76]	; 0x4c
   13900:	6803      	ldr	r3, [r0, #0]
   13902:	2b00      	cmp	r3, #0
   13904:	db12      	blt.n	1392c <get_eit_entry+0x6c>
   13906:	f7ff ff8d 	bl	13824 <selfrel_offset31>
   1390a:	2300      	movs	r3, #0
   1390c:	6120      	str	r0, [r4, #16]
   1390e:	4618      	mov	r0, r3
   13910:	b003      	add	sp, #12
   13912:	bd30      	pop	{r4, r5, pc}
   13914:	2300      	movs	r3, #0
   13916:	6123      	str	r3, [r4, #16]
   13918:	2309      	movs	r3, #9
   1391a:	4618      	mov	r0, r3
   1391c:	b003      	add	sp, #12
   1391e:	bd30      	pop	{r4, r5, pc}
   13920:	490e      	ldr	r1, [pc, #56]	; (1395c <get_eit_entry+0x9c>)
   13922:	480f      	ldr	r0, [pc, #60]	; (13960 <get_eit_entry+0xa0>)
   13924:	1a09      	subs	r1, r1, r0
   13926:	10c9      	asrs	r1, r1, #3
   13928:	9101      	str	r1, [sp, #4]
   1392a:	e7d5      	b.n	138d8 <get_eit_entry+0x18>
   1392c:	f3c3 6003 	ubfx	r0, r3, #24, #4
   13930:	f7ff ffb2 	bl	13898 <__gnu_unwind_get_pr_addr>
   13934:	2800      	cmp	r0, #0
   13936:	bf14      	ite	ne
   13938:	2300      	movne	r3, #0
   1393a:	2309      	moveq	r3, #9
   1393c:	6120      	str	r0, [r4, #16]
   1393e:	4618      	mov	r0, r3
   13940:	b003      	add	sp, #12
   13942:	bd30      	pop	{r4, r5, pc}
   13944:	2301      	movs	r3, #1
   13946:	e9c4 0313 	strd	r0, r3, [r4, #76]	; 0x4c
   1394a:	e7d9      	b.n	13900 <get_eit_entry+0x40>
   1394c:	2300      	movs	r3, #0
   1394e:	6123      	str	r3, [r4, #16]
   13950:	2305      	movs	r3, #5
   13952:	4618      	mov	r0, r3
   13954:	b003      	add	sp, #12
   13956:	bd30      	pop	{r4, r5, pc}
   13958:	00000000 	.word	0x00000000
   1395c:	0001661c 	.word	0x0001661c
   13960:	000161e4 	.word	0x000161e4

00013964 <restore_non_core_regs>:
   13964:	6803      	ldr	r3, [r0, #0]
   13966:	07da      	lsls	r2, r3, #31
   13968:	b510      	push	{r4, lr}
   1396a:	4604      	mov	r4, r0
   1396c:	d406      	bmi.n	1397c <restore_non_core_regs+0x18>
   1396e:	079b      	lsls	r3, r3, #30
   13970:	f100 0048 	add.w	r0, r0, #72	; 0x48
   13974:	d509      	bpl.n	1398a <restore_non_core_regs+0x26>
   13976:	f000 fc5f 	bl	14238 <__gnu_Unwind_Restore_VFP_D>
   1397a:	6823      	ldr	r3, [r4, #0]
   1397c:	0759      	lsls	r1, r3, #29
   1397e:	d509      	bpl.n	13994 <restore_non_core_regs+0x30>
   13980:	071a      	lsls	r2, r3, #28
   13982:	d50e      	bpl.n	139a2 <restore_non_core_regs+0x3e>
   13984:	06db      	lsls	r3, r3, #27
   13986:	d513      	bpl.n	139b0 <restore_non_core_regs+0x4c>
   13988:	bd10      	pop	{r4, pc}
   1398a:	f000 fc4d 	bl	14228 <__gnu_Unwind_Restore_VFP>
   1398e:	6823      	ldr	r3, [r4, #0]
   13990:	0759      	lsls	r1, r3, #29
   13992:	d4f5      	bmi.n	13980 <restore_non_core_regs+0x1c>
   13994:	f104 00d0 	add.w	r0, r4, #208	; 0xd0
   13998:	f000 fc56 	bl	14248 <__gnu_Unwind_Restore_VFP_D_16_to_31>
   1399c:	6823      	ldr	r3, [r4, #0]
   1399e:	071a      	lsls	r2, r3, #28
   139a0:	d4f0      	bmi.n	13984 <restore_non_core_regs+0x20>
   139a2:	f504 70a8 	add.w	r0, r4, #336	; 0x150
   139a6:	f000 fc57 	bl	14258 <__gnu_Unwind_Restore_WMMXD>
   139aa:	6823      	ldr	r3, [r4, #0]
   139ac:	06db      	lsls	r3, r3, #27
   139ae:	d4eb      	bmi.n	13988 <restore_non_core_regs+0x24>
   139b0:	f504 70e8 	add.w	r0, r4, #464	; 0x1d0
   139b4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   139b8:	f000 bc92 	b.w	142e0 <__gnu_Unwind_Restore_WMMXC>

000139bc <_Unwind_decode_typeinfo_ptr.isra.0>:
   139bc:	6803      	ldr	r3, [r0, #0]
   139be:	b103      	cbz	r3, 139c2 <_Unwind_decode_typeinfo_ptr.isra.0+0x6>
   139c0:	4403      	add	r3, r0
   139c2:	4618      	mov	r0, r3
   139c4:	4770      	bx	lr
   139c6:	bf00      	nop

000139c8 <__gnu_unwind_24bit.isra.1>:
   139c8:	2009      	movs	r0, #9
   139ca:	4770      	bx	lr

000139cc <_Unwind_DebugHook>:
   139cc:	4770      	bx	lr
   139ce:	bf00      	nop

000139d0 <unwind_phase2>:
   139d0:	b570      	push	{r4, r5, r6, lr}
   139d2:	4604      	mov	r4, r0
   139d4:	460d      	mov	r5, r1
   139d6:	e008      	b.n	139ea <unwind_phase2+0x1a>
   139d8:	6c2b      	ldr	r3, [r5, #64]	; 0x40
   139da:	6163      	str	r3, [r4, #20]
   139dc:	462a      	mov	r2, r5
   139de:	6923      	ldr	r3, [r4, #16]
   139e0:	4621      	mov	r1, r4
   139e2:	2001      	movs	r0, #1
   139e4:	4798      	blx	r3
   139e6:	2808      	cmp	r0, #8
   139e8:	d108      	bne.n	139fc <unwind_phase2+0x2c>
   139ea:	6c29      	ldr	r1, [r5, #64]	; 0x40
   139ec:	4620      	mov	r0, r4
   139ee:	f7ff ff67 	bl	138c0 <get_eit_entry>
   139f2:	4606      	mov	r6, r0
   139f4:	2800      	cmp	r0, #0
   139f6:	d0ef      	beq.n	139d8 <unwind_phase2+0x8>
   139f8:	f000 fe9c 	bl	14734 <abort>
   139fc:	2807      	cmp	r0, #7
   139fe:	d1fb      	bne.n	139f8 <unwind_phase2+0x28>
   13a00:	4630      	mov	r0, r6
   13a02:	6c29      	ldr	r1, [r5, #64]	; 0x40
   13a04:	f7ff ffe2 	bl	139cc <_Unwind_DebugHook>
   13a08:	1d28      	adds	r0, r5, #4
   13a0a:	f000 fc01 	bl	14210 <__restore_core_regs>
   13a0e:	bf00      	nop

00013a10 <unwind_phase2_forced>:
   13a10:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   13a14:	1d0c      	adds	r4, r1, #4
   13a16:	4605      	mov	r5, r0
   13a18:	4617      	mov	r7, r2
   13a1a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
   13a1c:	f5ad 7d72 	sub.w	sp, sp, #968	; 0x3c8
   13a20:	ae03      	add	r6, sp, #12
   13a22:	c60f      	stmia	r6!, {r0, r1, r2, r3}
   13a24:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
   13a26:	c60f      	stmia	r6!, {r0, r1, r2, r3}
   13a28:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
   13a2a:	c60f      	stmia	r6!, {r0, r1, r2, r3}
   13a2c:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
   13a30:	ac02      	add	r4, sp, #8
   13a32:	f8d5 800c 	ldr.w	r8, [r5, #12]
   13a36:	f8d5 9018 	ldr.w	r9, [r5, #24]
   13a3a:	e886 000f 	stmia.w	r6, {r0, r1, r2, r3}
   13a3e:	2300      	movs	r3, #0
   13a40:	6023      	str	r3, [r4, #0]
   13a42:	e021      	b.n	13a88 <unwind_phase2_forced+0x78>
   13a44:	6c23      	ldr	r3, [r4, #64]	; 0x40
   13a46:	616b      	str	r3, [r5, #20]
   13a48:	f44f 72f0 	mov.w	r2, #480	; 0x1e0
   13a4c:	4621      	mov	r1, r4
   13a4e:	a87a      	add	r0, sp, #488	; 0x1e8
   13a50:	f000 fe9c 	bl	1478c <memcpy>
   13a54:	692b      	ldr	r3, [r5, #16]
   13a56:	aa7a      	add	r2, sp, #488	; 0x1e8
   13a58:	4629      	mov	r1, r5
   13a5a:	4630      	mov	r0, r6
   13a5c:	4798      	blx	r3
   13a5e:	9b88      	ldr	r3, [sp, #544]	; 0x220
   13a60:	e9cd 4900 	strd	r4, r9, [sp]
   13a64:	4682      	mov	sl, r0
   13a66:	6463      	str	r3, [r4, #68]	; 0x44
   13a68:	4631      	mov	r1, r6
   13a6a:	462b      	mov	r3, r5
   13a6c:	462a      	mov	r2, r5
   13a6e:	2001      	movs	r0, #1
   13a70:	47c0      	blx	r8
   13a72:	4607      	mov	r7, r0
   13a74:	b9f8      	cbnz	r0, 13ab6 <unwind_phase2_forced+0xa6>
   13a76:	f44f 72f0 	mov.w	r2, #480	; 0x1e0
   13a7a:	a97a      	add	r1, sp, #488	; 0x1e8
   13a7c:	4620      	mov	r0, r4
   13a7e:	f000 fe85 	bl	1478c <memcpy>
   13a82:	f1ba 0f08 	cmp.w	sl, #8
   13a86:	d11c      	bne.n	13ac2 <unwind_phase2_forced+0xb2>
   13a88:	6c21      	ldr	r1, [r4, #64]	; 0x40
   13a8a:	4628      	mov	r0, r5
   13a8c:	f7ff ff18 	bl	138c0 <get_eit_entry>
   13a90:	2f00      	cmp	r7, #0
   13a92:	bf08      	it	eq
   13a94:	2609      	moveq	r6, #9
   13a96:	4607      	mov	r7, r0
   13a98:	bf18      	it	ne
   13a9a:	260a      	movne	r6, #10
   13a9c:	2800      	cmp	r0, #0
   13a9e:	d0d1      	beq.n	13a44 <unwind_phase2_forced+0x34>
   13aa0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   13aa2:	f046 0110 	orr.w	r1, r6, #16
   13aa6:	e9cd 4900 	strd	r4, r9, [sp]
   13aaa:	462a      	mov	r2, r5
   13aac:	6463      	str	r3, [r4, #68]	; 0x44
   13aae:	2001      	movs	r0, #1
   13ab0:	462b      	mov	r3, r5
   13ab2:	47c0      	blx	r8
   13ab4:	b100      	cbz	r0, 13ab8 <unwind_phase2_forced+0xa8>
   13ab6:	2709      	movs	r7, #9
   13ab8:	4638      	mov	r0, r7
   13aba:	f50d 7d72 	add.w	sp, sp, #968	; 0x3c8
   13abe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   13ac2:	f1ba 0f07 	cmp.w	sl, #7
   13ac6:	d1f6      	bne.n	13ab6 <unwind_phase2_forced+0xa6>
   13ac8:	4638      	mov	r0, r7
   13aca:	6c21      	ldr	r1, [r4, #64]	; 0x40
   13acc:	f7ff ff7e 	bl	139cc <_Unwind_DebugHook>
   13ad0:	a803      	add	r0, sp, #12
   13ad2:	f000 fb9d 	bl	14210 <__restore_core_regs>
   13ad6:	bf00      	nop

00013ad8 <_Unwind_GetCFA>:
   13ad8:	6c40      	ldr	r0, [r0, #68]	; 0x44
   13ada:	4770      	bx	lr

00013adc <__gnu_Unwind_RaiseException>:
   13adc:	b5f0      	push	{r4, r5, r6, r7, lr}
   13ade:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
   13ae0:	640b      	str	r3, [r1, #64]	; 0x40
   13ae2:	1d0d      	adds	r5, r1, #4
   13ae4:	460f      	mov	r7, r1
   13ae6:	4606      	mov	r6, r0
   13ae8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   13aea:	b0f9      	sub	sp, #484	; 0x1e4
   13aec:	ac01      	add	r4, sp, #4
   13aee:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   13af0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   13af2:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   13af4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   13af6:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   13af8:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
   13afc:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   13b00:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
   13b04:	9500      	str	r5, [sp, #0]
   13b06:	e006      	b.n	13b16 <__gnu_Unwind_RaiseException+0x3a>
   13b08:	6933      	ldr	r3, [r6, #16]
   13b0a:	466a      	mov	r2, sp
   13b0c:	4631      	mov	r1, r6
   13b0e:	4798      	blx	r3
   13b10:	2808      	cmp	r0, #8
   13b12:	4604      	mov	r4, r0
   13b14:	d108      	bne.n	13b28 <__gnu_Unwind_RaiseException+0x4c>
   13b16:	9910      	ldr	r1, [sp, #64]	; 0x40
   13b18:	4630      	mov	r0, r6
   13b1a:	f7ff fed1 	bl	138c0 <get_eit_entry>
   13b1e:	2800      	cmp	r0, #0
   13b20:	d0f2      	beq.n	13b08 <__gnu_Unwind_RaiseException+0x2c>
   13b22:	2009      	movs	r0, #9
   13b24:	b079      	add	sp, #484	; 0x1e4
   13b26:	bdf0      	pop	{r4, r5, r6, r7, pc}
   13b28:	4668      	mov	r0, sp
   13b2a:	f7ff ff1b 	bl	13964 <restore_non_core_regs>
   13b2e:	2c06      	cmp	r4, #6
   13b30:	d1f7      	bne.n	13b22 <__gnu_Unwind_RaiseException+0x46>
   13b32:	4639      	mov	r1, r7
   13b34:	4630      	mov	r0, r6
   13b36:	f7ff ff4b 	bl	139d0 <unwind_phase2>
   13b3a:	bf00      	nop

00013b3c <__gnu_Unwind_ForcedUnwind>:
   13b3c:	b430      	push	{r4, r5}
   13b3e:	6bdd      	ldr	r5, [r3, #60]	; 0x3c
   13b40:	60c1      	str	r1, [r0, #12]
   13b42:	6182      	str	r2, [r0, #24]
   13b44:	4619      	mov	r1, r3
   13b46:	641d      	str	r5, [r3, #64]	; 0x40
   13b48:	2200      	movs	r2, #0
   13b4a:	bc30      	pop	{r4, r5}
   13b4c:	e760      	b.n	13a10 <unwind_phase2_forced>
   13b4e:	bf00      	nop

00013b50 <__gnu_Unwind_Resume>:
   13b50:	b570      	push	{r4, r5, r6, lr}
   13b52:	68c6      	ldr	r6, [r0, #12]
   13b54:	6943      	ldr	r3, [r0, #20]
   13b56:	640b      	str	r3, [r1, #64]	; 0x40
   13b58:	b9be      	cbnz	r6, 13b8a <__gnu_Unwind_Resume+0x3a>
   13b5a:	6903      	ldr	r3, [r0, #16]
   13b5c:	460a      	mov	r2, r1
   13b5e:	4604      	mov	r4, r0
   13b60:	460d      	mov	r5, r1
   13b62:	4601      	mov	r1, r0
   13b64:	2002      	movs	r0, #2
   13b66:	4798      	blx	r3
   13b68:	2807      	cmp	r0, #7
   13b6a:	d007      	beq.n	13b7c <__gnu_Unwind_Resume+0x2c>
   13b6c:	2808      	cmp	r0, #8
   13b6e:	d103      	bne.n	13b78 <__gnu_Unwind_Resume+0x28>
   13b70:	4629      	mov	r1, r5
   13b72:	4620      	mov	r0, r4
   13b74:	f7ff ff2c 	bl	139d0 <unwind_phase2>
   13b78:	f000 fddc 	bl	14734 <abort>
   13b7c:	4630      	mov	r0, r6
   13b7e:	6c29      	ldr	r1, [r5, #64]	; 0x40
   13b80:	f7ff ff24 	bl	139cc <_Unwind_DebugHook>
   13b84:	1d28      	adds	r0, r5, #4
   13b86:	f000 fb43 	bl	14210 <__restore_core_regs>
   13b8a:	2201      	movs	r2, #1
   13b8c:	f7ff ff40 	bl	13a10 <unwind_phase2_forced>
   13b90:	f000 fdd0 	bl	14734 <abort>

00013b94 <__gnu_Unwind_Resume_or_Rethrow>:
   13b94:	68c2      	ldr	r2, [r0, #12]
   13b96:	b11a      	cbz	r2, 13ba0 <__gnu_Unwind_Resume_or_Rethrow+0xc>
   13b98:	6bca      	ldr	r2, [r1, #60]	; 0x3c
   13b9a:	640a      	str	r2, [r1, #64]	; 0x40
   13b9c:	2200      	movs	r2, #0
   13b9e:	e737      	b.n	13a10 <unwind_phase2_forced>
   13ba0:	e79c      	b.n	13adc <__gnu_Unwind_RaiseException>
   13ba2:	bf00      	nop

00013ba4 <_Unwind_Complete>:
   13ba4:	4770      	bx	lr
   13ba6:	bf00      	nop

00013ba8 <_Unwind_DeleteException>:
   13ba8:	6883      	ldr	r3, [r0, #8]
   13baa:	b113      	cbz	r3, 13bb2 <_Unwind_DeleteException+0xa>
   13bac:	4601      	mov	r1, r0
   13bae:	2001      	movs	r0, #1
   13bb0:	4718      	bx	r3
   13bb2:	4770      	bx	lr

00013bb4 <_Unwind_VRS_Get>:
   13bb4:	2904      	cmp	r1, #4
   13bb6:	d807      	bhi.n	13bc8 <_Unwind_VRS_Get+0x14>
   13bb8:	e8df f001 	tbb	[pc, r1]
   13bbc:	08060803 	.word	0x08060803
   13bc0:	08          	.byte	0x08
   13bc1:	00          	.byte	0x00
   13bc2:	b90b      	cbnz	r3, 13bc8 <_Unwind_VRS_Get+0x14>
   13bc4:	2a0f      	cmp	r2, #15
   13bc6:	d903      	bls.n	13bd0 <_Unwind_VRS_Get+0x1c>
   13bc8:	2002      	movs	r0, #2
   13bca:	4770      	bx	lr
   13bcc:	2001      	movs	r0, #1
   13bce:	4770      	bx	lr
   13bd0:	eb00 0282 	add.w	r2, r0, r2, lsl #2
   13bd4:	4618      	mov	r0, r3
   13bd6:	6853      	ldr	r3, [r2, #4]
   13bd8:	9a00      	ldr	r2, [sp, #0]
   13bda:	6013      	str	r3, [r2, #0]
   13bdc:	4770      	bx	lr
   13bde:	bf00      	nop

00013be0 <_Unwind_GetGR>:
   13be0:	b510      	push	{r4, lr}
   13be2:	b084      	sub	sp, #16
   13be4:	2300      	movs	r3, #0
   13be6:	ac03      	add	r4, sp, #12
   13be8:	460a      	mov	r2, r1
   13bea:	9400      	str	r4, [sp, #0]
   13bec:	4619      	mov	r1, r3
   13bee:	f7ff ffe1 	bl	13bb4 <_Unwind_VRS_Get>
   13bf2:	9803      	ldr	r0, [sp, #12]
   13bf4:	b004      	add	sp, #16
   13bf6:	bd10      	pop	{r4, pc}

00013bf8 <_Unwind_VRS_Set>:
   13bf8:	2904      	cmp	r1, #4
   13bfa:	d807      	bhi.n	13c0c <_Unwind_VRS_Set+0x14>
   13bfc:	e8df f001 	tbb	[pc, r1]
   13c00:	08060803 	.word	0x08060803
   13c04:	08          	.byte	0x08
   13c05:	00          	.byte	0x00
   13c06:	b90b      	cbnz	r3, 13c0c <_Unwind_VRS_Set+0x14>
   13c08:	2a0f      	cmp	r2, #15
   13c0a:	d903      	bls.n	13c14 <_Unwind_VRS_Set+0x1c>
   13c0c:	2002      	movs	r0, #2
   13c0e:	4770      	bx	lr
   13c10:	2001      	movs	r0, #1
   13c12:	4770      	bx	lr
   13c14:	eb00 0082 	add.w	r0, r0, r2, lsl #2
   13c18:	9a00      	ldr	r2, [sp, #0]
   13c1a:	6812      	ldr	r2, [r2, #0]
   13c1c:	6042      	str	r2, [r0, #4]
   13c1e:	4618      	mov	r0, r3
   13c20:	4770      	bx	lr
   13c22:	bf00      	nop

00013c24 <_Unwind_SetGR>:
   13c24:	b510      	push	{r4, lr}
   13c26:	b084      	sub	sp, #16
   13c28:	ac04      	add	r4, sp, #16
   13c2a:	2300      	movs	r3, #0
   13c2c:	f844 2d04 	str.w	r2, [r4, #-4]!
   13c30:	460a      	mov	r2, r1
   13c32:	9400      	str	r4, [sp, #0]
   13c34:	4619      	mov	r1, r3
   13c36:	f7ff ffdf 	bl	13bf8 <_Unwind_VRS_Set>
   13c3a:	b004      	add	sp, #16
   13c3c:	bd10      	pop	{r4, pc}
   13c3e:	bf00      	nop

00013c40 <__gnu_Unwind_Backtrace>:
   13c40:	b5f0      	push	{r4, r5, r6, r7, lr}
   13c42:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
   13c44:	6413      	str	r3, [r2, #64]	; 0x40
   13c46:	1d15      	adds	r5, r2, #4
   13c48:	4607      	mov	r7, r0
   13c4a:	460e      	mov	r6, r1
   13c4c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   13c4e:	f5ad 7d0f 	sub.w	sp, sp, #572	; 0x23c
   13c52:	ac17      	add	r4, sp, #92	; 0x5c
   13c54:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   13c56:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   13c58:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   13c5a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   13c5c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   13c5e:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
   13c62:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   13c66:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
   13c6a:	9516      	str	r5, [sp, #88]	; 0x58
   13c6c:	e010      	b.n	13c90 <__gnu_Unwind_Backtrace+0x50>
   13c6e:	a816      	add	r0, sp, #88	; 0x58
   13c70:	f7ff ffd8 	bl	13c24 <_Unwind_SetGR>
   13c74:	4631      	mov	r1, r6
   13c76:	a816      	add	r0, sp, #88	; 0x58
   13c78:	47b8      	blx	r7
   13c7a:	aa16      	add	r2, sp, #88	; 0x58
   13c7c:	4669      	mov	r1, sp
   13c7e:	b978      	cbnz	r0, 13ca0 <__gnu_Unwind_Backtrace+0x60>
   13c80:	9b04      	ldr	r3, [sp, #16]
   13c82:	2008      	movs	r0, #8
   13c84:	4798      	blx	r3
   13c86:	2805      	cmp	r0, #5
   13c88:	4604      	mov	r4, r0
   13c8a:	d00a      	beq.n	13ca2 <__gnu_Unwind_Backtrace+0x62>
   13c8c:	2809      	cmp	r0, #9
   13c8e:	d007      	beq.n	13ca0 <__gnu_Unwind_Backtrace+0x60>
   13c90:	9926      	ldr	r1, [sp, #152]	; 0x98
   13c92:	4668      	mov	r0, sp
   13c94:	f7ff fe14 	bl	138c0 <get_eit_entry>
   13c98:	466a      	mov	r2, sp
   13c9a:	210c      	movs	r1, #12
   13c9c:	2800      	cmp	r0, #0
   13c9e:	d0e6      	beq.n	13c6e <__gnu_Unwind_Backtrace+0x2e>
   13ca0:	2409      	movs	r4, #9
   13ca2:	a816      	add	r0, sp, #88	; 0x58
   13ca4:	f7ff fe5e 	bl	13964 <restore_non_core_regs>
   13ca8:	4620      	mov	r0, r4
   13caa:	f50d 7d0f 	add.w	sp, sp, #572	; 0x23c
   13cae:	bdf0      	pop	{r4, r5, r6, r7, pc}

00013cb0 <__gnu_unwind_pr_common>:
   13cb0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   13cb4:	460d      	mov	r5, r1
   13cb6:	6cc9      	ldr	r1, [r1, #76]	; 0x4c
   13cb8:	b089      	sub	sp, #36	; 0x24
   13cba:	1d0c      	adds	r4, r1, #4
   13cbc:	4616      	mov	r6, r2
   13cbe:	f000 0b03 	and.w	fp, r0, #3
   13cc2:	680a      	ldr	r2, [r1, #0]
   13cc4:	9406      	str	r4, [sp, #24]
   13cc6:	461f      	mov	r7, r3
   13cc8:	2b00      	cmp	r3, #0
   13cca:	d068      	beq.n	13d9e <__gnu_unwind_pr_common+0xee>
   13ccc:	0c13      	lsrs	r3, r2, #16
   13cce:	b2d9      	uxtb	r1, r3
   13cd0:	0412      	lsls	r2, r2, #16
   13cd2:	f88d 301d 	strb.w	r3, [sp, #29]
   13cd6:	2302      	movs	r3, #2
   13cd8:	eb04 0481 	add.w	r4, r4, r1, lsl #2
   13cdc:	9205      	str	r2, [sp, #20]
   13cde:	f88d 301c 	strb.w	r3, [sp, #28]
   13ce2:	6d2b      	ldr	r3, [r5, #80]	; 0x50
   13ce4:	f1bb 0f02 	cmp.w	fp, #2
   13ce8:	bf08      	it	eq
   13cea:	6bac      	ldreq	r4, [r5, #56]	; 0x38
   13cec:	f013 0301 	ands.w	r3, r3, #1
   13cf0:	d146      	bne.n	13d80 <__gnu_unwind_pr_common+0xd0>
   13cf2:	9301      	str	r3, [sp, #4]
   13cf4:	f000 0308 	and.w	r3, r0, #8
   13cf8:	9300      	str	r3, [sp, #0]
   13cfa:	f8d4 9000 	ldr.w	r9, [r4]
   13cfe:	f1b9 0f00 	cmp.w	r9, #0
   13d02:	f000 80f3 	beq.w	13eec <__gnu_unwind_pr_common+0x23c>
   13d06:	2f02      	cmp	r7, #2
   13d08:	d045      	beq.n	13d96 <__gnu_unwind_pr_common+0xe6>
   13d0a:	f8b4 9000 	ldrh.w	r9, [r4]
   13d0e:	f8b4 8002 	ldrh.w	r8, [r4, #2]
   13d12:	3404      	adds	r4, #4
   13d14:	6cab      	ldr	r3, [r5, #72]	; 0x48
   13d16:	f028 0a01 	bic.w	sl, r8, #1
   13d1a:	210f      	movs	r1, #15
   13d1c:	4630      	mov	r0, r6
   13d1e:	449a      	add	sl, r3
   13d20:	f7ff ff5e 	bl	13be0 <_Unwind_GetGR>
   13d24:	4582      	cmp	sl, r0
   13d26:	d834      	bhi.n	13d92 <__gnu_unwind_pr_common+0xe2>
   13d28:	f029 0301 	bic.w	r3, r9, #1
   13d2c:	4453      	add	r3, sl
   13d2e:	4283      	cmp	r3, r0
   13d30:	bf94      	ite	ls
   13d32:	2000      	movls	r0, #0
   13d34:	2001      	movhi	r0, #1
   13d36:	ea4f 0848 	mov.w	r8, r8, lsl #1
   13d3a:	f008 0802 	and.w	r8, r8, #2
   13d3e:	f009 0901 	and.w	r9, r9, #1
   13d42:	ea48 0809 	orr.w	r8, r8, r9
   13d46:	f1b8 0f01 	cmp.w	r8, #1
   13d4a:	d03a      	beq.n	13dc2 <__gnu_unwind_pr_common+0x112>
   13d4c:	d331      	bcc.n	13db2 <__gnu_unwind_pr_common+0x102>
   13d4e:	f1b8 0f02 	cmp.w	r8, #2
   13d52:	d11a      	bne.n	13d8a <__gnu_unwind_pr_common+0xda>
   13d54:	6823      	ldr	r3, [r4, #0]
   13d56:	f023 4a00 	bic.w	sl, r3, #2147483648	; 0x80000000
   13d5a:	f1bb 0f00 	cmp.w	fp, #0
   13d5e:	d166      	bne.n	13e2e <__gnu_unwind_pr_common+0x17e>
   13d60:	b130      	cbz	r0, 13d70 <__gnu_unwind_pr_common+0xc0>
   13d62:	9a00      	ldr	r2, [sp, #0]
   13d64:	2a00      	cmp	r2, #0
   13d66:	d06c      	beq.n	13e42 <__gnu_unwind_pr_common+0x192>
   13d68:	f1ba 0f00 	cmp.w	sl, #0
   13d6c:	f000 8090 	beq.w	13e90 <__gnu_unwind_pr_common+0x1e0>
   13d70:	2b00      	cmp	r3, #0
   13d72:	da00      	bge.n	13d76 <__gnu_unwind_pr_common+0xc6>
   13d74:	3404      	adds	r4, #4
   13d76:	f10a 0301 	add.w	r3, sl, #1
   13d7a:	eb04 0483 	add.w	r4, r4, r3, lsl #2
   13d7e:	e7bc      	b.n	13cfa <__gnu_unwind_pr_common+0x4a>
   13d80:	4630      	mov	r0, r6
   13d82:	a905      	add	r1, sp, #20
   13d84:	f000 fb46 	bl	14414 <__gnu_unwind_execute>
   13d88:	b178      	cbz	r0, 13daa <__gnu_unwind_pr_common+0xfa>
   13d8a:	2009      	movs	r0, #9
   13d8c:	b009      	add	sp, #36	; 0x24
   13d8e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   13d92:	2000      	movs	r0, #0
   13d94:	e7cf      	b.n	13d36 <__gnu_unwind_pr_common+0x86>
   13d96:	f8d4 8004 	ldr.w	r8, [r4, #4]
   13d9a:	3408      	adds	r4, #8
   13d9c:	e7ba      	b.n	13d14 <__gnu_unwind_pr_common+0x64>
   13d9e:	0212      	lsls	r2, r2, #8
   13da0:	2303      	movs	r3, #3
   13da2:	9205      	str	r2, [sp, #20]
   13da4:	f8ad 301c 	strh.w	r3, [sp, #28]
   13da8:	e79b      	b.n	13ce2 <__gnu_unwind_pr_common+0x32>
   13daa:	2008      	movs	r0, #8
   13dac:	b009      	add	sp, #36	; 0x24
   13dae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   13db2:	f1bb 0f00 	cmp.w	fp, #0
   13db6:	d002      	beq.n	13dbe <__gnu_unwind_pr_common+0x10e>
   13db8:	2800      	cmp	r0, #0
   13dba:	f040 80b4 	bne.w	13f26 <__gnu_unwind_pr_common+0x276>
   13dbe:	3404      	adds	r4, #4
   13dc0:	e79b      	b.n	13cfa <__gnu_unwind_pr_common+0x4a>
   13dc2:	f1bb 0f00 	cmp.w	fp, #0
   13dc6:	d118      	bne.n	13dfa <__gnu_unwind_pr_common+0x14a>
   13dc8:	b1a8      	cbz	r0, 13df6 <__gnu_unwind_pr_common+0x146>
   13dca:	e9d4 2300 	ldrd	r2, r3, [r4]
   13dce:	1c99      	adds	r1, r3, #2
   13dd0:	ea4f 72d2 	mov.w	r2, r2, lsr #31
   13dd4:	d0d9      	beq.n	13d8a <__gnu_unwind_pr_common+0xda>
   13dd6:	f105 0158 	add.w	r1, r5, #88	; 0x58
   13dda:	3301      	adds	r3, #1
   13ddc:	9104      	str	r1, [sp, #16]
   13dde:	f000 80b5 	beq.w	13f4c <__gnu_unwind_pr_common+0x29c>
   13de2:	1d20      	adds	r0, r4, #4
   13de4:	f7ff fdea 	bl	139bc <_Unwind_decode_typeinfo_ptr.isra.0>
   13de8:	ab04      	add	r3, sp, #16
   13dea:	4601      	mov	r1, r0
   13dec:	4628      	mov	r0, r5
   13dee:	f3af 8000 	nop.w
   13df2:	2800      	cmp	r0, #0
   13df4:	d167      	bne.n	13ec6 <__gnu_unwind_pr_common+0x216>
   13df6:	3408      	adds	r4, #8
   13df8:	e77f      	b.n	13cfa <__gnu_unwind_pr_common+0x4a>
   13dfa:	210d      	movs	r1, #13
   13dfc:	4630      	mov	r0, r6
   13dfe:	f8d5 8020 	ldr.w	r8, [r5, #32]
   13e02:	f7ff feed 	bl	13be0 <_Unwind_GetGR>
   13e06:	4580      	cmp	r8, r0
   13e08:	d1f5      	bne.n	13df6 <__gnu_unwind_pr_common+0x146>
   13e0a:	6aab      	ldr	r3, [r5, #40]	; 0x28
   13e0c:	429c      	cmp	r4, r3
   13e0e:	d1f2      	bne.n	13df6 <__gnu_unwind_pr_common+0x146>
   13e10:	4620      	mov	r0, r4
   13e12:	f7ff fd07 	bl	13824 <selfrel_offset31>
   13e16:	210f      	movs	r1, #15
   13e18:	4602      	mov	r2, r0
   13e1a:	4630      	mov	r0, r6
   13e1c:	f7ff ff02 	bl	13c24 <_Unwind_SetGR>
   13e20:	4630      	mov	r0, r6
   13e22:	462a      	mov	r2, r5
   13e24:	2100      	movs	r1, #0
   13e26:	f7ff fefd 	bl	13c24 <_Unwind_SetGR>
   13e2a:	2007      	movs	r0, #7
   13e2c:	e7ae      	b.n	13d8c <__gnu_unwind_pr_common+0xdc>
   13e2e:	210d      	movs	r1, #13
   13e30:	4630      	mov	r0, r6
   13e32:	f8d5 8020 	ldr.w	r8, [r5, #32]
   13e36:	f7ff fed3 	bl	13be0 <_Unwind_GetGR>
   13e3a:	4580      	cmp	r8, r0
   13e3c:	d032      	beq.n	13ea4 <__gnu_unwind_pr_common+0x1f4>
   13e3e:	6823      	ldr	r3, [r4, #0]
   13e40:	e796      	b.n	13d70 <__gnu_unwind_pr_common+0xc0>
   13e42:	f1ba 0f00 	cmp.w	sl, #0
   13e46:	d023      	beq.n	13e90 <__gnu_unwind_pr_common+0x1e0>
   13e48:	f105 0358 	add.w	r3, r5, #88	; 0x58
   13e4c:	f104 0804 	add.w	r8, r4, #4
   13e50:	f8cd b008 	str.w	fp, [sp, #8]
   13e54:	f8dd 9000 	ldr.w	r9, [sp]
   13e58:	9703      	str	r7, [sp, #12]
   13e5a:	46a3      	mov	fp, r4
   13e5c:	461c      	mov	r4, r3
   13e5e:	e002      	b.n	13e66 <__gnu_unwind_pr_common+0x1b6>
   13e60:	4557      	cmp	r7, sl
   13e62:	46b9      	mov	r9, r7
   13e64:	d040      	beq.n	13ee8 <__gnu_unwind_pr_common+0x238>
   13e66:	4640      	mov	r0, r8
   13e68:	9404      	str	r4, [sp, #16]
   13e6a:	f7ff fda7 	bl	139bc <_Unwind_decode_typeinfo_ptr.isra.0>
   13e6e:	ab04      	add	r3, sp, #16
   13e70:	4601      	mov	r1, r0
   13e72:	2200      	movs	r2, #0
   13e74:	4628      	mov	r0, r5
   13e76:	f3af 8000 	nop.w
   13e7a:	f109 0701 	add.w	r7, r9, #1
   13e7e:	f108 0804 	add.w	r8, r8, #4
   13e82:	2800      	cmp	r0, #0
   13e84:	d0ec      	beq.n	13e60 <__gnu_unwind_pr_common+0x1b0>
   13e86:	45d1      	cmp	r9, sl
   13e88:	465c      	mov	r4, fp
   13e8a:	e9dd b702 	ldrd	fp, r7, [sp, #8]
   13e8e:	d1d6      	bne.n	13e3e <__gnu_unwind_pr_common+0x18e>
   13e90:	4630      	mov	r0, r6
   13e92:	210d      	movs	r1, #13
   13e94:	f7ff fea4 	bl	13be0 <_Unwind_GetGR>
   13e98:	9b04      	ldr	r3, [sp, #16]
   13e9a:	6228      	str	r0, [r5, #32]
   13e9c:	e9c5 3409 	strd	r3, r4, [r5, #36]	; 0x24
   13ea0:	2006      	movs	r0, #6
   13ea2:	e773      	b.n	13d8c <__gnu_unwind_pr_common+0xdc>
   13ea4:	6aab      	ldr	r3, [r5, #40]	; 0x28
   13ea6:	429c      	cmp	r4, r3
   13ea8:	d1c9      	bne.n	13e3e <__gnu_unwind_pr_common+0x18e>
   13eaa:	2204      	movs	r2, #4
   13eac:	f04f 0800 	mov.w	r8, #0
   13eb0:	18a3      	adds	r3, r4, r2
   13eb2:	e9c5 a80a 	strd	sl, r8, [r5, #40]	; 0x28
   13eb6:	e9c5 230c 	strd	r2, r3, [r5, #48]	; 0x30
   13eba:	6823      	ldr	r3, [r4, #0]
   13ebc:	4543      	cmp	r3, r8
   13ebe:	db4d      	blt.n	13f5c <__gnu_unwind_pr_common+0x2ac>
   13ec0:	2301      	movs	r3, #1
   13ec2:	9301      	str	r3, [sp, #4]
   13ec4:	e757      	b.n	13d76 <__gnu_unwind_pr_common+0xc6>
   13ec6:	4680      	mov	r8, r0
   13ec8:	210d      	movs	r1, #13
   13eca:	4630      	mov	r0, r6
   13ecc:	f7ff fe88 	bl	13be0 <_Unwind_GetGR>
   13ed0:	f1b8 0f02 	cmp.w	r8, #2
   13ed4:	6228      	str	r0, [r5, #32]
   13ed6:	d13e      	bne.n	13f56 <__gnu_unwind_pr_common+0x2a6>
   13ed8:	462b      	mov	r3, r5
   13eda:	9a04      	ldr	r2, [sp, #16]
   13edc:	f843 2f2c 	str.w	r2, [r3, #44]!
   13ee0:	626b      	str	r3, [r5, #36]	; 0x24
   13ee2:	62ac      	str	r4, [r5, #40]	; 0x28
   13ee4:	2006      	movs	r0, #6
   13ee6:	e751      	b.n	13d8c <__gnu_unwind_pr_common+0xdc>
   13ee8:	465c      	mov	r4, fp
   13eea:	e7d1      	b.n	13e90 <__gnu_unwind_pr_common+0x1e0>
   13eec:	a905      	add	r1, sp, #20
   13eee:	4630      	mov	r0, r6
   13ef0:	f000 fa90 	bl	14414 <__gnu_unwind_execute>
   13ef4:	2800      	cmp	r0, #0
   13ef6:	f47f af48 	bne.w	13d8a <__gnu_unwind_pr_common+0xda>
   13efa:	9b01      	ldr	r3, [sp, #4]
   13efc:	2b00      	cmp	r3, #0
   13efe:	f43f af54 	beq.w	13daa <__gnu_unwind_pr_common+0xfa>
   13f02:	210f      	movs	r1, #15
   13f04:	4630      	mov	r0, r6
   13f06:	f7ff fe6b 	bl	13be0 <_Unwind_GetGR>
   13f0a:	210e      	movs	r1, #14
   13f0c:	4602      	mov	r2, r0
   13f0e:	4630      	mov	r0, r6
   13f10:	f7ff fe88 	bl	13c24 <_Unwind_SetGR>
   13f14:	4630      	mov	r0, r6
   13f16:	4a1a      	ldr	r2, [pc, #104]	; (13f80 <__gnu_unwind_pr_common+0x2d0>)
   13f18:	210f      	movs	r1, #15
   13f1a:	f7ff fe83 	bl	13c24 <_Unwind_SetGR>
   13f1e:	2007      	movs	r0, #7
   13f20:	b009      	add	sp, #36	; 0x24
   13f22:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   13f26:	4620      	mov	r0, r4
   13f28:	f7ff fc7c 	bl	13824 <selfrel_offset31>
   13f2c:	3404      	adds	r4, #4
   13f2e:	4607      	mov	r7, r0
   13f30:	63ac      	str	r4, [r5, #56]	; 0x38
   13f32:	4628      	mov	r0, r5
   13f34:	f3af 8000 	nop.w
   13f38:	2800      	cmp	r0, #0
   13f3a:	f43f af26 	beq.w	13d8a <__gnu_unwind_pr_common+0xda>
   13f3e:	4630      	mov	r0, r6
   13f40:	463a      	mov	r2, r7
   13f42:	210f      	movs	r1, #15
   13f44:	f7ff fe6e 	bl	13c24 <_Unwind_SetGR>
   13f48:	2007      	movs	r0, #7
   13f4a:	e71f      	b.n	13d8c <__gnu_unwind_pr_common+0xdc>
   13f4c:	4630      	mov	r0, r6
   13f4e:	210d      	movs	r1, #13
   13f50:	f7ff fe46 	bl	13be0 <_Unwind_GetGR>
   13f54:	6228      	str	r0, [r5, #32]
   13f56:	9b04      	ldr	r3, [sp, #16]
   13f58:	626b      	str	r3, [r5, #36]	; 0x24
   13f5a:	e7c2      	b.n	13ee2 <__gnu_unwind_pr_common+0x232>
   13f5c:	f10a 0001 	add.w	r0, sl, #1
   13f60:	eb04 0080 	add.w	r0, r4, r0, lsl #2
   13f64:	f7ff fc5e 	bl	13824 <selfrel_offset31>
   13f68:	210f      	movs	r1, #15
   13f6a:	4602      	mov	r2, r0
   13f6c:	4630      	mov	r0, r6
   13f6e:	f7ff fe59 	bl	13c24 <_Unwind_SetGR>
   13f72:	4630      	mov	r0, r6
   13f74:	462a      	mov	r2, r5
   13f76:	4641      	mov	r1, r8
   13f78:	f7ff fe54 	bl	13c24 <_Unwind_SetGR>
   13f7c:	2007      	movs	r0, #7
   13f7e:	e705      	b.n	13d8c <__gnu_unwind_pr_common+0xdc>
   13f80:	00000000 	.word	0x00000000

00013f84 <__aeabi_unwind_cpp_pr0>:
   13f84:	2300      	movs	r3, #0
   13f86:	e693      	b.n	13cb0 <__gnu_unwind_pr_common>

00013f88 <__aeabi_unwind_cpp_pr1>:
   13f88:	2301      	movs	r3, #1
   13f8a:	e691      	b.n	13cb0 <__gnu_unwind_pr_common>

00013f8c <__aeabi_unwind_cpp_pr2>:
   13f8c:	2302      	movs	r3, #2
   13f8e:	e68f      	b.n	13cb0 <__gnu_unwind_pr_common>

00013f90 <_Unwind_VRS_Pop>:
   13f90:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   13f94:	4605      	mov	r5, r0
   13f96:	b0c4      	sub	sp, #272	; 0x110
   13f98:	2904      	cmp	r1, #4
   13f9a:	d806      	bhi.n	13faa <_Unwind_VRS_Pop+0x1a>
   13f9c:	e8df f001 	tbb	[pc, r1]
   13fa0:	03052b4d 	.word	0x03052b4d
   13fa4:	09          	.byte	0x09
   13fa5:	00          	.byte	0x00
   13fa6:	2b03      	cmp	r3, #3
   13fa8:	d05f      	beq.n	1406a <_Unwind_VRS_Pop+0xda>
   13faa:	2002      	movs	r0, #2
   13fac:	b044      	add	sp, #272	; 0x110
   13fae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   13fb2:	2b00      	cmp	r3, #0
   13fb4:	d1f9      	bne.n	13faa <_Unwind_VRS_Pop+0x1a>
   13fb6:	2a10      	cmp	r2, #16
   13fb8:	d8f7      	bhi.n	13faa <_Unwind_VRS_Pop+0x1a>
   13fba:	682b      	ldr	r3, [r5, #0]
   13fbc:	06dc      	lsls	r4, r3, #27
   13fbe:	f100 80f4 	bmi.w	141aa <_Unwind_VRS_Pop+0x21a>
   13fc2:	ac22      	add	r4, sp, #136	; 0x88
   13fc4:	4620      	mov	r0, r4
   13fc6:	9201      	str	r2, [sp, #4]
   13fc8:	f000 f994 	bl	142f4 <__gnu_Unwind_Save_WMMXC>
   13fcc:	6ba8      	ldr	r0, [r5, #56]	; 0x38
   13fce:	9a01      	ldr	r2, [sp, #4]
   13fd0:	2300      	movs	r3, #0
   13fd2:	2601      	movs	r6, #1
   13fd4:	fa06 f103 	lsl.w	r1, r6, r3
   13fd8:	4211      	tst	r1, r2
   13fda:	d003      	beq.n	13fe4 <_Unwind_VRS_Pop+0x54>
   13fdc:	6801      	ldr	r1, [r0, #0]
   13fde:	f844 1023 	str.w	r1, [r4, r3, lsl #2]
   13fe2:	3004      	adds	r0, #4
   13fe4:	3301      	adds	r3, #1
   13fe6:	2b04      	cmp	r3, #4
   13fe8:	d1f4      	bne.n	13fd4 <_Unwind_VRS_Pop+0x44>
   13fea:	63a8      	str	r0, [r5, #56]	; 0x38
   13fec:	4620      	mov	r0, r4
   13fee:	f000 f977 	bl	142e0 <__gnu_Unwind_Restore_WMMXC>
   13ff2:	2000      	movs	r0, #0
   13ff4:	e7da      	b.n	13fac <_Unwind_VRS_Pop+0x1c>
   13ff6:	2b01      	cmp	r3, #1
   13ff8:	ea4f 4612 	mov.w	r6, r2, lsr #16
   13ffc:	b297      	uxth	r7, r2
   13ffe:	d052      	beq.n	140a6 <_Unwind_VRS_Pop+0x116>
   14000:	2b05      	cmp	r3, #5
   14002:	d1d2      	bne.n	13faa <_Unwind_VRS_Pop+0x1a>
   14004:	eb06 0807 	add.w	r8, r6, r7
   14008:	f1b8 0f20 	cmp.w	r8, #32
   1400c:	d8cd      	bhi.n	13faa <_Unwind_VRS_Pop+0x1a>
   1400e:	2e0f      	cmp	r6, #15
   14010:	f240 8099 	bls.w	14146 <_Unwind_VRS_Pop+0x1b6>
   14014:	46b8      	mov	r8, r7
   14016:	2f00      	cmp	r7, #0
   14018:	f040 80db 	bne.w	141d2 <_Unwind_VRS_Pop+0x242>
   1401c:	6baa      	ldr	r2, [r5, #56]	; 0x38
   1401e:	63aa      	str	r2, [r5, #56]	; 0x38
   14020:	2e0f      	cmp	r6, #15
   14022:	f240 80be 	bls.w	141a2 <_Unwind_VRS_Pop+0x212>
   14026:	f1b8 0f00 	cmp.w	r8, #0
   1402a:	d002      	beq.n	14032 <_Unwind_VRS_Pop+0xa2>
   1402c:	a802      	add	r0, sp, #8
   1402e:	f000 f90b 	bl	14248 <__gnu_Unwind_Restore_VFP_D_16_to_31>
   14032:	2000      	movs	r0, #0
   14034:	b044      	add	sp, #272	; 0x110
   14036:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1403a:	2b00      	cmp	r3, #0
   1403c:	d1b5      	bne.n	13faa <_Unwind_VRS_Pop+0x1a>
   1403e:	6bac      	ldr	r4, [r5, #56]	; 0x38
   14040:	b297      	uxth	r7, r2
   14042:	1d28      	adds	r0, r5, #4
   14044:	2601      	movs	r6, #1
   14046:	fa06 f103 	lsl.w	r1, r6, r3
   1404a:	4239      	tst	r1, r7
   1404c:	f103 0301 	add.w	r3, r3, #1
   14050:	d002      	beq.n	14058 <_Unwind_VRS_Pop+0xc8>
   14052:	6821      	ldr	r1, [r4, #0]
   14054:	6001      	str	r1, [r0, #0]
   14056:	3404      	adds	r4, #4
   14058:	2b10      	cmp	r3, #16
   1405a:	f100 0004 	add.w	r0, r0, #4
   1405e:	d1f2      	bne.n	14046 <_Unwind_VRS_Pop+0xb6>
   14060:	f412 5000 	ands.w	r0, r2, #8192	; 0x2000
   14064:	d1e5      	bne.n	14032 <_Unwind_VRS_Pop+0xa2>
   14066:	63ac      	str	r4, [r5, #56]	; 0x38
   14068:	e7a0      	b.n	13fac <_Unwind_VRS_Pop+0x1c>
   1406a:	0c16      	lsrs	r6, r2, #16
   1406c:	b297      	uxth	r7, r2
   1406e:	19f3      	adds	r3, r6, r7
   14070:	2b10      	cmp	r3, #16
   14072:	d89a      	bhi.n	13faa <_Unwind_VRS_Pop+0x1a>
   14074:	682b      	ldr	r3, [r5, #0]
   14076:	071a      	lsls	r2, r3, #28
   14078:	d45d      	bmi.n	14136 <_Unwind_VRS_Pop+0x1a6>
   1407a:	ac22      	add	r4, sp, #136	; 0x88
   1407c:	4620      	mov	r0, r4
   1407e:	f000 f90d 	bl	1429c <__gnu_Unwind_Save_WMMXD>
   14082:	eb04 01c6 	add.w	r1, r4, r6, lsl #3
   14086:	6bab      	ldr	r3, [r5, #56]	; 0x38
   14088:	b13f      	cbz	r7, 1409a <_Unwind_VRS_Pop+0x10a>
   1408a:	eb03 02c7 	add.w	r2, r3, r7, lsl #3
   1408e:	6818      	ldr	r0, [r3, #0]
   14090:	f841 0b04 	str.w	r0, [r1], #4
   14094:	3304      	adds	r3, #4
   14096:	4293      	cmp	r3, r2
   14098:	d1f9      	bne.n	1408e <_Unwind_VRS_Pop+0xfe>
   1409a:	4620      	mov	r0, r4
   1409c:	63ab      	str	r3, [r5, #56]	; 0x38
   1409e:	f000 f8db 	bl	14258 <__gnu_Unwind_Restore_WMMXD>
   140a2:	2000      	movs	r0, #0
   140a4:	e782      	b.n	13fac <_Unwind_VRS_Pop+0x1c>
   140a6:	19f2      	adds	r2, r6, r7
   140a8:	2a10      	cmp	r2, #16
   140aa:	f63f af7e 	bhi.w	13faa <_Unwind_VRS_Pop+0x1a>
   140ae:	2e0f      	cmp	r6, #15
   140b0:	f63f af7b 	bhi.w	13faa <_Unwind_VRS_Pop+0x1a>
   140b4:	682a      	ldr	r2, [r5, #0]
   140b6:	07d1      	lsls	r1, r2, #31
   140b8:	d508      	bpl.n	140cc <_Unwind_VRS_Pop+0x13c>
   140ba:	4628      	mov	r0, r5
   140bc:	f022 0203 	bic.w	r2, r2, #3
   140c0:	f840 2b48 	str.w	r2, [r0], #72
   140c4:	9301      	str	r3, [sp, #4]
   140c6:	f000 f8b3 	bl	14230 <__gnu_Unwind_Save_VFP>
   140ca:	9b01      	ldr	r3, [sp, #4]
   140cc:	9301      	str	r3, [sp, #4]
   140ce:	ac22      	add	r4, sp, #136	; 0x88
   140d0:	4620      	mov	r0, r4
   140d2:	f000 f8ad 	bl	14230 <__gnu_Unwind_Save_VFP>
   140d6:	6ba9      	ldr	r1, [r5, #56]	; 0x38
   140d8:	9b01      	ldr	r3, [sp, #4]
   140da:	2f00      	cmp	r7, #0
   140dc:	f000 8095 	beq.w	1420a <_Unwind_VRS_Pop+0x27a>
   140e0:	007f      	lsls	r7, r7, #1
   140e2:	eb04 04c6 	add.w	r4, r4, r6, lsl #3
   140e6:	f04f 0800 	mov.w	r8, #0
   140ea:	3c04      	subs	r4, #4
   140ec:	eb01 0287 	add.w	r2, r1, r7, lsl #2
   140f0:	f851 0b04 	ldr.w	r0, [r1], #4
   140f4:	f844 0f04 	str.w	r0, [r4, #4]!
   140f8:	4291      	cmp	r1, r2
   140fa:	d1f9      	bne.n	140f0 <_Unwind_VRS_Pop+0x160>
   140fc:	f1b8 0f00 	cmp.w	r8, #0
   14100:	d00f      	beq.n	14122 <_Unwind_VRS_Pop+0x192>
   14102:	ac02      	add	r4, sp, #8
   14104:	2e10      	cmp	r6, #16
   14106:	4631      	mov	r1, r6
   14108:	bf38      	it	cc
   1410a:	2110      	movcc	r1, #16
   1410c:	eb04 01c1 	add.w	r1, r4, r1, lsl #3
   14110:	3984      	subs	r1, #132	; 0x84
   14112:	eb02 04c8 	add.w	r4, r2, r8, lsl #3
   14116:	f852 0b04 	ldr.w	r0, [r2], #4
   1411a:	f841 0f04 	str.w	r0, [r1, #4]!
   1411e:	4294      	cmp	r4, r2
   14120:	d1f9      	bne.n	14116 <_Unwind_VRS_Pop+0x186>
   14122:	2b01      	cmp	r3, #1
   14124:	f47f af7b 	bne.w	1401e <_Unwind_VRS_Pop+0x8e>
   14128:	ac22      	add	r4, sp, #136	; 0x88
   1412a:	3204      	adds	r2, #4
   1412c:	63aa      	str	r2, [r5, #56]	; 0x38
   1412e:	4620      	mov	r0, r4
   14130:	f000 f87a 	bl	14228 <__gnu_Unwind_Restore_VFP>
   14134:	e77d      	b.n	14032 <_Unwind_VRS_Pop+0xa2>
   14136:	f023 0308 	bic.w	r3, r3, #8
   1413a:	602b      	str	r3, [r5, #0]
   1413c:	f505 70a8 	add.w	r0, r5, #336	; 0x150
   14140:	f000 f8ac 	bl	1429c <__gnu_Unwind_Save_WMMXD>
   14144:	e799      	b.n	1407a <_Unwind_VRS_Pop+0xea>
   14146:	f1b8 0f10 	cmp.w	r8, #16
   1414a:	682a      	ldr	r2, [r5, #0]
   1414c:	d943      	bls.n	141d6 <_Unwind_VRS_Pop+0x246>
   1414e:	07d0      	lsls	r0, r2, #31
   14150:	f1a8 0810 	sub.w	r8, r8, #16
   14154:	d50b      	bpl.n	1416e <_Unwind_VRS_Pop+0x1de>
   14156:	4628      	mov	r0, r5
   14158:	f022 0201 	bic.w	r2, r2, #1
   1415c:	f042 0202 	orr.w	r2, r2, #2
   14160:	f840 2b48 	str.w	r2, [r0], #72
   14164:	9301      	str	r3, [sp, #4]
   14166:	f000 f86b 	bl	14240 <__gnu_Unwind_Save_VFP_D>
   1416a:	682a      	ldr	r2, [r5, #0]
   1416c:	9b01      	ldr	r3, [sp, #4]
   1416e:	0751      	lsls	r1, r2, #29
   14170:	d425      	bmi.n	141be <_Unwind_VRS_Pop+0x22e>
   14172:	2e0f      	cmp	r6, #15
   14174:	d804      	bhi.n	14180 <_Unwind_VRS_Pop+0x1f0>
   14176:	a822      	add	r0, sp, #136	; 0x88
   14178:	9301      	str	r3, [sp, #4]
   1417a:	f000 f861 	bl	14240 <__gnu_Unwind_Save_VFP_D>
   1417e:	9b01      	ldr	r3, [sp, #4]
   14180:	9301      	str	r3, [sp, #4]
   14182:	ac02      	add	r4, sp, #8
   14184:	4620      	mov	r0, r4
   14186:	f000 f863 	bl	14250 <__gnu_Unwind_Save_VFP_D_16_to_31>
   1418a:	f1c6 0110 	rsb	r1, r6, #16
   1418e:	2900      	cmp	r1, #0
   14190:	6baa      	ldr	r2, [r5, #56]	; 0x38
   14192:	9b01      	ldr	r3, [sp, #4]
   14194:	ddb6      	ble.n	14104 <_Unwind_VRS_Pop+0x174>
   14196:	ac22      	add	r4, sp, #136	; 0x88
   14198:	004f      	lsls	r7, r1, #1
   1419a:	eb04 04c6 	add.w	r4, r4, r6, lsl #3
   1419e:	4611      	mov	r1, r2
   141a0:	e7a3      	b.n	140ea <_Unwind_VRS_Pop+0x15a>
   141a2:	a822      	add	r0, sp, #136	; 0x88
   141a4:	f000 f848 	bl	14238 <__gnu_Unwind_Restore_VFP_D>
   141a8:	e73d      	b.n	14026 <_Unwind_VRS_Pop+0x96>
   141aa:	f023 0310 	bic.w	r3, r3, #16
   141ae:	602b      	str	r3, [r5, #0]
   141b0:	f505 70e8 	add.w	r0, r5, #464	; 0x1d0
   141b4:	9201      	str	r2, [sp, #4]
   141b6:	f000 f89d 	bl	142f4 <__gnu_Unwind_Save_WMMXC>
   141ba:	9a01      	ldr	r2, [sp, #4]
   141bc:	e701      	b.n	13fc2 <_Unwind_VRS_Pop+0x32>
   141be:	4628      	mov	r0, r5
   141c0:	f022 0204 	bic.w	r2, r2, #4
   141c4:	f840 2bd0 	str.w	r2, [r0], #208
   141c8:	9301      	str	r3, [sp, #4]
   141ca:	f000 f841 	bl	14250 <__gnu_Unwind_Save_VFP_D_16_to_31>
   141ce:	9b01      	ldr	r3, [sp, #4]
   141d0:	e7cf      	b.n	14172 <_Unwind_VRS_Pop+0x1e2>
   141d2:	682a      	ldr	r2, [r5, #0]
   141d4:	e7cb      	b.n	1416e <_Unwind_VRS_Pop+0x1de>
   141d6:	07d0      	lsls	r0, r2, #31
   141d8:	d50a      	bpl.n	141f0 <_Unwind_VRS_Pop+0x260>
   141da:	4628      	mov	r0, r5
   141dc:	f022 0201 	bic.w	r2, r2, #1
   141e0:	f042 0202 	orr.w	r2, r2, #2
   141e4:	f840 2b48 	str.w	r2, [r0], #72
   141e8:	9301      	str	r3, [sp, #4]
   141ea:	f000 f829 	bl	14240 <__gnu_Unwind_Save_VFP_D>
   141ee:	9b01      	ldr	r3, [sp, #4]
   141f0:	9301      	str	r3, [sp, #4]
   141f2:	ac22      	add	r4, sp, #136	; 0x88
   141f4:	4620      	mov	r0, r4
   141f6:	f000 f823 	bl	14240 <__gnu_Unwind_Save_VFP_D>
   141fa:	46b8      	mov	r8, r7
   141fc:	6ba9      	ldr	r1, [r5, #56]	; 0x38
   141fe:	9b01      	ldr	r3, [sp, #4]
   14200:	2f00      	cmp	r7, #0
   14202:	f47f af6d 	bne.w	140e0 <_Unwind_VRS_Pop+0x150>
   14206:	460a      	mov	r2, r1
   14208:	e709      	b.n	1401e <_Unwind_VRS_Pop+0x8e>
   1420a:	460a      	mov	r2, r1
   1420c:	e78d      	b.n	1412a <_Unwind_VRS_Pop+0x19a>
   1420e:	bf00      	nop

00014210 <__restore_core_regs>:
   14210:	f100 0134 	add.w	r1, r0, #52	; 0x34
   14214:	e891 0038 	ldmia.w	r1, {r3, r4, r5}
   14218:	469c      	mov	ip, r3
   1421a:	46a6      	mov	lr, r4
   1421c:	f84c 5d04 	str.w	r5, [ip, #-4]!
   14220:	e890 0fff 	ldmia.w	r0, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp}
   14224:	46e5      	mov	sp, ip
   14226:	bd00      	pop	{pc}

00014228 <__gnu_Unwind_Restore_VFP>:
   14228:	ec90 0b21 	fldmiax	r0, {d0-d15}	;@ Deprecated
   1422c:	4770      	bx	lr
   1422e:	bf00      	nop

00014230 <__gnu_Unwind_Save_VFP>:
   14230:	ec80 0b21 	fstmiax	r0, {d0-d15}	;@ Deprecated
   14234:	4770      	bx	lr
   14236:	bf00      	nop

00014238 <__gnu_Unwind_Restore_VFP_D>:
   14238:	ec90 0b20 	vldmia	r0, {d0-d15}
   1423c:	4770      	bx	lr
   1423e:	bf00      	nop

00014240 <__gnu_Unwind_Save_VFP_D>:
   14240:	ec80 0b20 	vstmia	r0, {d0-d15}
   14244:	4770      	bx	lr
   14246:	bf00      	nop

00014248 <__gnu_Unwind_Restore_VFP_D_16_to_31>:
   14248:	ecd0 0b20 	vldmia	r0, {d16-d31}
   1424c:	4770      	bx	lr
   1424e:	bf00      	nop

00014250 <__gnu_Unwind_Save_VFP_D_16_to_31>:
   14250:	ecc0 0b20 	vstmia	r0, {d16-d31}
   14254:	4770      	bx	lr
   14256:	bf00      	nop

00014258 <__gnu_Unwind_Restore_WMMXD>:
   14258:	ecf0 0102 	ldfe	f0, [r0], #8
   1425c:	ecf0 1102 	ldfe	f1, [r0], #8
   14260:	ecf0 2102 	ldfe	f2, [r0], #8
   14264:	ecf0 3102 	ldfe	f3, [r0], #8
   14268:	ecf0 4102 	ldfe	f4, [r0], #8
   1426c:	ecf0 5102 	ldfe	f5, [r0], #8
   14270:	ecf0 6102 	ldfe	f6, [r0], #8
   14274:	ecf0 7102 	ldfe	f7, [r0], #8
   14278:	ecf0 8102 	ldfp	f0, [r0], #8
   1427c:	ecf0 9102 	ldfp	f1, [r0], #8
   14280:	ecf0 a102 	ldfp	f2, [r0], #8
   14284:	ecf0 b102 	ldfp	f3, [r0], #8
   14288:	ecf0 c102 	ldfp	f4, [r0], #8
   1428c:	ecf0 d102 	ldfp	f5, [r0], #8
   14290:	ecf0 e102 	ldfp	f6, [r0], #8
   14294:	ecf0 f102 	ldfp	f7, [r0], #8
   14298:	4770      	bx	lr
   1429a:	bf00      	nop

0001429c <__gnu_Unwind_Save_WMMXD>:
   1429c:	ece0 0102 	stfe	f0, [r0], #8
   142a0:	ece0 1102 	stfe	f1, [r0], #8
   142a4:	ece0 2102 	stfe	f2, [r0], #8
   142a8:	ece0 3102 	stfe	f3, [r0], #8
   142ac:	ece0 4102 	stfe	f4, [r0], #8
   142b0:	ece0 5102 	stfe	f5, [r0], #8
   142b4:	ece0 6102 	stfe	f6, [r0], #8
   142b8:	ece0 7102 	stfe	f7, [r0], #8
   142bc:	ece0 8102 	stfp	f0, [r0], #8
   142c0:	ece0 9102 	stfp	f1, [r0], #8
   142c4:	ece0 a102 	stfp	f2, [r0], #8
   142c8:	ece0 b102 	stfp	f3, [r0], #8
   142cc:	ece0 c102 	stfp	f4, [r0], #8
   142d0:	ece0 d102 	stfp	f5, [r0], #8
   142d4:	ece0 e102 	stfp	f6, [r0], #8
   142d8:	ece0 f102 	stfp	f7, [r0], #8
   142dc:	4770      	bx	lr
   142de:	bf00      	nop

000142e0 <__gnu_Unwind_Restore_WMMXC>:
   142e0:	fcb0 8101 	ldc2	1, cr8, [r0], #4
   142e4:	fcb0 9101 	ldc2	1, cr9, [r0], #4
   142e8:	fcb0 a101 	ldc2	1, cr10, [r0], #4
   142ec:	fcb0 b101 	ldc2	1, cr11, [r0], #4
   142f0:	4770      	bx	lr
   142f2:	bf00      	nop

000142f4 <__gnu_Unwind_Save_WMMXC>:
   142f4:	fca0 8101 	stc2	1, cr8, [r0], #4
   142f8:	fca0 9101 	stc2	1, cr9, [r0], #4
   142fc:	fca0 a101 	stc2	1, cr10, [r0], #4
   14300:	fca0 b101 	stc2	1, cr11, [r0], #4
   14304:	4770      	bx	lr
   14306:	bf00      	nop

00014308 <_Unwind_RaiseException>:
   14308:	46ec      	mov	ip, sp
   1430a:	b500      	push	{lr}
   1430c:	e92d 5000 	stmdb	sp!, {ip, lr}
   14310:	e92d 1fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
   14314:	f04f 0300 	mov.w	r3, #0
   14318:	e92d 000c 	stmdb	sp!, {r2, r3}
   1431c:	a901      	add	r1, sp, #4
   1431e:	f7ff fbdd 	bl	13adc <__gnu_Unwind_RaiseException>
   14322:	f8dd e040 	ldr.w	lr, [sp, #64]	; 0x40
   14326:	b012      	add	sp, #72	; 0x48
   14328:	4770      	bx	lr
   1432a:	bf00      	nop

0001432c <_Unwind_Resume>:
   1432c:	46ec      	mov	ip, sp
   1432e:	b500      	push	{lr}
   14330:	e92d 5000 	stmdb	sp!, {ip, lr}
   14334:	e92d 1fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
   14338:	f04f 0300 	mov.w	r3, #0
   1433c:	e92d 000c 	stmdb	sp!, {r2, r3}
   14340:	a901      	add	r1, sp, #4
   14342:	f7ff fc05 	bl	13b50 <__gnu_Unwind_Resume>
   14346:	f8dd e040 	ldr.w	lr, [sp, #64]	; 0x40
   1434a:	b012      	add	sp, #72	; 0x48
   1434c:	4770      	bx	lr
   1434e:	bf00      	nop

00014350 <_Unwind_Resume_or_Rethrow>:
   14350:	46ec      	mov	ip, sp
   14352:	b500      	push	{lr}
   14354:	e92d 5000 	stmdb	sp!, {ip, lr}
   14358:	e92d 1fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
   1435c:	f04f 0300 	mov.w	r3, #0
   14360:	e92d 000c 	stmdb	sp!, {r2, r3}
   14364:	a901      	add	r1, sp, #4
   14366:	f7ff fc15 	bl	13b94 <__gnu_Unwind_Resume_or_Rethrow>
   1436a:	f8dd e040 	ldr.w	lr, [sp, #64]	; 0x40
   1436e:	b012      	add	sp, #72	; 0x48
   14370:	4770      	bx	lr
   14372:	bf00      	nop

00014374 <_Unwind_ForcedUnwind>:
   14374:	46ec      	mov	ip, sp
   14376:	b500      	push	{lr}
   14378:	e92d 5000 	stmdb	sp!, {ip, lr}
   1437c:	e92d 1fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
   14380:	f04f 0300 	mov.w	r3, #0
   14384:	e92d 000c 	stmdb	sp!, {r2, r3}
   14388:	ab01      	add	r3, sp, #4
   1438a:	f7ff fbd7 	bl	13b3c <__gnu_Unwind_ForcedUnwind>
   1438e:	f8dd e040 	ldr.w	lr, [sp, #64]	; 0x40
   14392:	b012      	add	sp, #72	; 0x48
   14394:	4770      	bx	lr
   14396:	bf00      	nop

00014398 <_Unwind_Backtrace>:
   14398:	46ec      	mov	ip, sp
   1439a:	b500      	push	{lr}
   1439c:	e92d 5000 	stmdb	sp!, {ip, lr}
   143a0:	e92d 1fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
   143a4:	f04f 0300 	mov.w	r3, #0
   143a8:	e92d 000c 	stmdb	sp!, {r2, r3}
   143ac:	aa01      	add	r2, sp, #4
   143ae:	f7ff fc47 	bl	13c40 <__gnu_Unwind_Backtrace>
   143b2:	f8dd e040 	ldr.w	lr, [sp, #64]	; 0x40
   143b6:	b012      	add	sp, #72	; 0x48
   143b8:	4770      	bx	lr
   143ba:	bf00      	nop

000143bc <next_unwind_byte>:
   143bc:	7a02      	ldrb	r2, [r0, #8]
   143be:	b982      	cbnz	r2, 143e2 <next_unwind_byte+0x26>
   143c0:	7a43      	ldrb	r3, [r0, #9]
   143c2:	b1ab      	cbz	r3, 143f0 <next_unwind_byte+0x34>
   143c4:	6842      	ldr	r2, [r0, #4]
   143c6:	3b01      	subs	r3, #1
   143c8:	b410      	push	{r4}
   143ca:	7243      	strb	r3, [r0, #9]
   143cc:	6813      	ldr	r3, [r2, #0]
   143ce:	2103      	movs	r1, #3
   143d0:	1d14      	adds	r4, r2, #4
   143d2:	7201      	strb	r1, [r0, #8]
   143d4:	021a      	lsls	r2, r3, #8
   143d6:	6044      	str	r4, [r0, #4]
   143d8:	6002      	str	r2, [r0, #0]
   143da:	f85d 4b04 	ldr.w	r4, [sp], #4
   143de:	0e18      	lsrs	r0, r3, #24
   143e0:	4770      	bx	lr
   143e2:	6803      	ldr	r3, [r0, #0]
   143e4:	3a01      	subs	r2, #1
   143e6:	7202      	strb	r2, [r0, #8]
   143e8:	021a      	lsls	r2, r3, #8
   143ea:	6002      	str	r2, [r0, #0]
   143ec:	0e18      	lsrs	r0, r3, #24
   143ee:	4770      	bx	lr
   143f0:	20b0      	movs	r0, #176	; 0xb0
   143f2:	4770      	bx	lr

000143f4 <_Unwind_GetGR.constprop.0>:
   143f4:	b500      	push	{lr}
   143f6:	b085      	sub	sp, #20
   143f8:	aa03      	add	r2, sp, #12
   143fa:	2300      	movs	r3, #0
   143fc:	9200      	str	r2, [sp, #0]
   143fe:	4619      	mov	r1, r3
   14400:	220c      	movs	r2, #12
   14402:	f7ff fbd7 	bl	13bb4 <_Unwind_VRS_Get>
   14406:	9803      	ldr	r0, [sp, #12]
   14408:	b005      	add	sp, #20
   1440a:	f85d fb04 	ldr.w	pc, [sp], #4
   1440e:	bf00      	nop

00014410 <unwind_UCB_from_context>:
   14410:	e7f0      	b.n	143f4 <_Unwind_GetGR.constprop.0>
   14412:	bf00      	nop

00014414 <__gnu_unwind_execute>:
   14414:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   14418:	4605      	mov	r5, r0
   1441a:	b085      	sub	sp, #20
   1441c:	460e      	mov	r6, r1
   1441e:	f04f 0800 	mov.w	r8, #0
   14422:	4630      	mov	r0, r6
   14424:	f7ff ffca 	bl	143bc <next_unwind_byte>
   14428:	28b0      	cmp	r0, #176	; 0xb0
   1442a:	4604      	mov	r4, r0
   1442c:	f000 80b1 	beq.w	14592 <__gnu_unwind_execute+0x17e>
   14430:	0607      	lsls	r7, r0, #24
   14432:	d520      	bpl.n	14476 <__gnu_unwind_execute+0x62>
   14434:	f000 03f0 	and.w	r3, r0, #240	; 0xf0
   14438:	2b80      	cmp	r3, #128	; 0x80
   1443a:	d065      	beq.n	14508 <__gnu_unwind_execute+0xf4>
   1443c:	2b90      	cmp	r3, #144	; 0x90
   1443e:	d036      	beq.n	144ae <__gnu_unwind_execute+0x9a>
   14440:	2ba0      	cmp	r3, #160	; 0xa0
   14442:	d078      	beq.n	14536 <__gnu_unwind_execute+0x122>
   14444:	2bb0      	cmp	r3, #176	; 0xb0
   14446:	d047      	beq.n	144d8 <__gnu_unwind_execute+0xc4>
   14448:	2bc0      	cmp	r3, #192	; 0xc0
   1444a:	f000 808a 	beq.w	14562 <__gnu_unwind_execute+0x14e>
   1444e:	f000 03f8 	and.w	r3, r0, #248	; 0xf8
   14452:	2bd0      	cmp	r3, #208	; 0xd0
   14454:	d10b      	bne.n	1446e <__gnu_unwind_execute+0x5a>
   14456:	f000 0207 	and.w	r2, r0, #7
   1445a:	3201      	adds	r2, #1
   1445c:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
   14460:	2305      	movs	r3, #5
   14462:	2101      	movs	r1, #1
   14464:	4628      	mov	r0, r5
   14466:	f7ff fd93 	bl	13f90 <_Unwind_VRS_Pop>
   1446a:	2800      	cmp	r0, #0
   1446c:	d0d9      	beq.n	14422 <__gnu_unwind_execute+0xe>
   1446e:	2009      	movs	r0, #9
   14470:	b005      	add	sp, #20
   14472:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   14476:	f10d 090c 	add.w	r9, sp, #12
   1447a:	2300      	movs	r3, #0
   1447c:	4619      	mov	r1, r3
   1447e:	0087      	lsls	r7, r0, #2
   14480:	f8cd 9000 	str.w	r9, [sp]
   14484:	220d      	movs	r2, #13
   14486:	4628      	mov	r0, r5
   14488:	f7ff fb94 	bl	13bb4 <_Unwind_VRS_Get>
   1448c:	b2ff      	uxtb	r7, r7
   1448e:	9b03      	ldr	r3, [sp, #12]
   14490:	f8cd 9000 	str.w	r9, [sp]
   14494:	3704      	adds	r7, #4
   14496:	0660      	lsls	r0, r4, #25
   14498:	bf4c      	ite	mi
   1449a:	1bdf      	submi	r7, r3, r7
   1449c:	18ff      	addpl	r7, r7, r3
   1449e:	2300      	movs	r3, #0
   144a0:	4619      	mov	r1, r3
   144a2:	220d      	movs	r2, #13
   144a4:	4628      	mov	r0, r5
   144a6:	9703      	str	r7, [sp, #12]
   144a8:	f7ff fba6 	bl	13bf8 <_Unwind_VRS_Set>
   144ac:	e7b9      	b.n	14422 <__gnu_unwind_execute+0xe>
   144ae:	f000 030d 	and.w	r3, r0, #13
   144b2:	2b0d      	cmp	r3, #13
   144b4:	d0db      	beq.n	1446e <__gnu_unwind_execute+0x5a>
   144b6:	af03      	add	r7, sp, #12
   144b8:	2300      	movs	r3, #0
   144ba:	f000 020f 	and.w	r2, r0, #15
   144be:	4619      	mov	r1, r3
   144c0:	9700      	str	r7, [sp, #0]
   144c2:	4628      	mov	r0, r5
   144c4:	f7ff fb76 	bl	13bb4 <_Unwind_VRS_Get>
   144c8:	2300      	movs	r3, #0
   144ca:	9700      	str	r7, [sp, #0]
   144cc:	4619      	mov	r1, r3
   144ce:	220d      	movs	r2, #13
   144d0:	4628      	mov	r0, r5
   144d2:	f7ff fb91 	bl	13bf8 <_Unwind_VRS_Set>
   144d6:	e7a4      	b.n	14422 <__gnu_unwind_execute+0xe>
   144d8:	28b1      	cmp	r0, #177	; 0xb1
   144da:	d05f      	beq.n	1459c <__gnu_unwind_execute+0x188>
   144dc:	28b2      	cmp	r0, #178	; 0xb2
   144de:	f000 80cc 	beq.w	1467a <__gnu_unwind_execute+0x266>
   144e2:	28b3      	cmp	r0, #179	; 0xb3
   144e4:	d07e      	beq.n	145e4 <__gnu_unwind_execute+0x1d0>
   144e6:	f000 03fc 	and.w	r3, r0, #252	; 0xfc
   144ea:	2bb4      	cmp	r3, #180	; 0xb4
   144ec:	d0bf      	beq.n	1446e <__gnu_unwind_execute+0x5a>
   144ee:	f000 0207 	and.w	r2, r0, #7
   144f2:	3201      	adds	r2, #1
   144f4:	2301      	movs	r3, #1
   144f6:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
   144fa:	4619      	mov	r1, r3
   144fc:	4628      	mov	r0, r5
   144fe:	f7ff fd47 	bl	13f90 <_Unwind_VRS_Pop>
   14502:	2800      	cmp	r0, #0
   14504:	d08d      	beq.n	14422 <__gnu_unwind_execute+0xe>
   14506:	e7b2      	b.n	1446e <__gnu_unwind_execute+0x5a>
   14508:	4630      	mov	r0, r6
   1450a:	f7ff ff57 	bl	143bc <next_unwind_byte>
   1450e:	0224      	lsls	r4, r4, #8
   14510:	4304      	orrs	r4, r0
   14512:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
   14516:	d0aa      	beq.n	1446e <__gnu_unwind_execute+0x5a>
   14518:	0124      	lsls	r4, r4, #4
   1451a:	2300      	movs	r3, #0
   1451c:	b2a2      	uxth	r2, r4
   1451e:	4619      	mov	r1, r3
   14520:	4628      	mov	r0, r5
   14522:	f7ff fd35 	bl	13f90 <_Unwind_VRS_Pop>
   14526:	2800      	cmp	r0, #0
   14528:	d1a1      	bne.n	1446e <__gnu_unwind_execute+0x5a>
   1452a:	f414 4f00 	tst.w	r4, #32768	; 0x8000
   1452e:	bf18      	it	ne
   14530:	f04f 0801 	movne.w	r8, #1
   14534:	e775      	b.n	14422 <__gnu_unwind_execute+0xe>
   14536:	43c2      	mvns	r2, r0
   14538:	f002 0307 	and.w	r3, r2, #7
   1453c:	f44f 627f 	mov.w	r2, #4080	; 0xff0
   14540:	411a      	asrs	r2, r3
   14542:	0701      	lsls	r1, r0, #28
   14544:	f402 627f 	and.w	r2, r2, #4080	; 0xff0
   14548:	f04f 0300 	mov.w	r3, #0
   1454c:	bf48      	it	mi
   1454e:	f442 4280 	orrmi.w	r2, r2, #16384	; 0x4000
   14552:	4619      	mov	r1, r3
   14554:	4628      	mov	r0, r5
   14556:	f7ff fd1b 	bl	13f90 <_Unwind_VRS_Pop>
   1455a:	2800      	cmp	r0, #0
   1455c:	f43f af61 	beq.w	14422 <__gnu_unwind_execute+0xe>
   14560:	e785      	b.n	1446e <__gnu_unwind_execute+0x5a>
   14562:	28c6      	cmp	r0, #198	; 0xc6
   14564:	d051      	beq.n	1460a <__gnu_unwind_execute+0x1f6>
   14566:	28c7      	cmp	r0, #199	; 0xc7
   14568:	d05a      	beq.n	14620 <__gnu_unwind_execute+0x20c>
   1456a:	f000 03f8 	and.w	r3, r0, #248	; 0xf8
   1456e:	2bc0      	cmp	r3, #192	; 0xc0
   14570:	d069      	beq.n	14646 <__gnu_unwind_execute+0x232>
   14572:	28c8      	cmp	r0, #200	; 0xc8
   14574:	d075      	beq.n	14662 <__gnu_unwind_execute+0x24e>
   14576:	28c9      	cmp	r0, #201	; 0xc9
   14578:	f47f af79 	bne.w	1446e <__gnu_unwind_execute+0x5a>
   1457c:	4630      	mov	r0, r6
   1457e:	f7ff ff1d 	bl	143bc <next_unwind_byte>
   14582:	0302      	lsls	r2, r0, #12
   14584:	f000 000f 	and.w	r0, r0, #15
   14588:	f402 2270 	and.w	r2, r2, #983040	; 0xf0000
   1458c:	3001      	adds	r0, #1
   1458e:	4302      	orrs	r2, r0
   14590:	e766      	b.n	14460 <__gnu_unwind_execute+0x4c>
   14592:	f1b8 0f00 	cmp.w	r8, #0
   14596:	d014      	beq.n	145c2 <__gnu_unwind_execute+0x1ae>
   14598:	2000      	movs	r0, #0
   1459a:	e769      	b.n	14470 <__gnu_unwind_execute+0x5c>
   1459c:	4630      	mov	r0, r6
   1459e:	f7ff ff0d 	bl	143bc <next_unwind_byte>
   145a2:	2800      	cmp	r0, #0
   145a4:	f43f af63 	beq.w	1446e <__gnu_unwind_execute+0x5a>
   145a8:	f010 03f0 	ands.w	r3, r0, #240	; 0xf0
   145ac:	f47f af5f 	bne.w	1446e <__gnu_unwind_execute+0x5a>
   145b0:	4602      	mov	r2, r0
   145b2:	4619      	mov	r1, r3
   145b4:	4628      	mov	r0, r5
   145b6:	f7ff fceb 	bl	13f90 <_Unwind_VRS_Pop>
   145ba:	2800      	cmp	r0, #0
   145bc:	f43f af31 	beq.w	14422 <__gnu_unwind_execute+0xe>
   145c0:	e755      	b.n	1446e <__gnu_unwind_execute+0x5a>
   145c2:	ac03      	add	r4, sp, #12
   145c4:	4643      	mov	r3, r8
   145c6:	220e      	movs	r2, #14
   145c8:	4641      	mov	r1, r8
   145ca:	9400      	str	r4, [sp, #0]
   145cc:	4628      	mov	r0, r5
   145ce:	f7ff faf1 	bl	13bb4 <_Unwind_VRS_Get>
   145d2:	9400      	str	r4, [sp, #0]
   145d4:	4628      	mov	r0, r5
   145d6:	4643      	mov	r3, r8
   145d8:	220f      	movs	r2, #15
   145da:	4641      	mov	r1, r8
   145dc:	f7ff fb0c 	bl	13bf8 <_Unwind_VRS_Set>
   145e0:	4640      	mov	r0, r8
   145e2:	e745      	b.n	14470 <__gnu_unwind_execute+0x5c>
   145e4:	4630      	mov	r0, r6
   145e6:	f7ff fee9 	bl	143bc <next_unwind_byte>
   145ea:	0301      	lsls	r1, r0, #12
   145ec:	f000 000f 	and.w	r0, r0, #15
   145f0:	f401 2170 	and.w	r1, r1, #983040	; 0xf0000
   145f4:	1c42      	adds	r2, r0, #1
   145f6:	2301      	movs	r3, #1
   145f8:	430a      	orrs	r2, r1
   145fa:	4628      	mov	r0, r5
   145fc:	4619      	mov	r1, r3
   145fe:	f7ff fcc7 	bl	13f90 <_Unwind_VRS_Pop>
   14602:	2800      	cmp	r0, #0
   14604:	f43f af0d 	beq.w	14422 <__gnu_unwind_execute+0xe>
   14608:	e731      	b.n	1446e <__gnu_unwind_execute+0x5a>
   1460a:	4630      	mov	r0, r6
   1460c:	f7ff fed6 	bl	143bc <next_unwind_byte>
   14610:	0301      	lsls	r1, r0, #12
   14612:	f000 000f 	and.w	r0, r0, #15
   14616:	f401 2170 	and.w	r1, r1, #983040	; 0xf0000
   1461a:	1c42      	adds	r2, r0, #1
   1461c:	2303      	movs	r3, #3
   1461e:	e7eb      	b.n	145f8 <__gnu_unwind_execute+0x1e4>
   14620:	4630      	mov	r0, r6
   14622:	f7ff fecb 	bl	143bc <next_unwind_byte>
   14626:	4602      	mov	r2, r0
   14628:	2800      	cmp	r0, #0
   1462a:	f43f af20 	beq.w	1446e <__gnu_unwind_execute+0x5a>
   1462e:	f010 03f0 	ands.w	r3, r0, #240	; 0xf0
   14632:	f47f af1c 	bne.w	1446e <__gnu_unwind_execute+0x5a>
   14636:	2104      	movs	r1, #4
   14638:	4628      	mov	r0, r5
   1463a:	f7ff fca9 	bl	13f90 <_Unwind_VRS_Pop>
   1463e:	2800      	cmp	r0, #0
   14640:	f43f aeef 	beq.w	14422 <__gnu_unwind_execute+0xe>
   14644:	e713      	b.n	1446e <__gnu_unwind_execute+0x5a>
   14646:	f000 020f 	and.w	r2, r0, #15
   1464a:	3201      	adds	r2, #1
   1464c:	2303      	movs	r3, #3
   1464e:	f442 2220 	orr.w	r2, r2, #655360	; 0xa0000
   14652:	4619      	mov	r1, r3
   14654:	4628      	mov	r0, r5
   14656:	f7ff fc9b 	bl	13f90 <_Unwind_VRS_Pop>
   1465a:	2800      	cmp	r0, #0
   1465c:	f43f aee1 	beq.w	14422 <__gnu_unwind_execute+0xe>
   14660:	e705      	b.n	1446e <__gnu_unwind_execute+0x5a>
   14662:	4630      	mov	r0, r6
   14664:	f7ff feaa 	bl	143bc <next_unwind_byte>
   14668:	f000 02f0 	and.w	r2, r0, #240	; 0xf0
   1466c:	f000 030f 	and.w	r3, r0, #15
   14670:	3210      	adds	r2, #16
   14672:	3301      	adds	r3, #1
   14674:	ea43 3202 	orr.w	r2, r3, r2, lsl #12
   14678:	e6f2      	b.n	14460 <__gnu_unwind_execute+0x4c>
   1467a:	2300      	movs	r3, #0
   1467c:	f10d 090c 	add.w	r9, sp, #12
   14680:	220d      	movs	r2, #13
   14682:	4619      	mov	r1, r3
   14684:	f8cd 9000 	str.w	r9, [sp]
   14688:	4628      	mov	r0, r5
   1468a:	f7ff fa93 	bl	13bb4 <_Unwind_VRS_Get>
   1468e:	4630      	mov	r0, r6
   14690:	f7ff fe94 	bl	143bc <next_unwind_byte>
   14694:	0602      	lsls	r2, r0, #24
   14696:	f04f 0702 	mov.w	r7, #2
   1469a:	d50c      	bpl.n	146b6 <__gnu_unwind_execute+0x2a2>
   1469c:	9b03      	ldr	r3, [sp, #12]
   1469e:	f000 007f 	and.w	r0, r0, #127	; 0x7f
   146a2:	40b8      	lsls	r0, r7
   146a4:	4403      	add	r3, r0
   146a6:	4630      	mov	r0, r6
   146a8:	9303      	str	r3, [sp, #12]
   146aa:	f7ff fe87 	bl	143bc <next_unwind_byte>
   146ae:	0603      	lsls	r3, r0, #24
   146b0:	f107 0707 	add.w	r7, r7, #7
   146b4:	d4f2      	bmi.n	1469c <__gnu_unwind_execute+0x288>
   146b6:	9b03      	ldr	r3, [sp, #12]
   146b8:	f8cd 9000 	str.w	r9, [sp]
   146bc:	f000 047f 	and.w	r4, r0, #127	; 0x7f
   146c0:	f503 7201 	add.w	r2, r3, #516	; 0x204
   146c4:	40bc      	lsls	r4, r7
   146c6:	2300      	movs	r3, #0
   146c8:	4414      	add	r4, r2
   146ca:	4619      	mov	r1, r3
   146cc:	220d      	movs	r2, #13
   146ce:	4628      	mov	r0, r5
   146d0:	9403      	str	r4, [sp, #12]
   146d2:	f7ff fa91 	bl	13bf8 <_Unwind_VRS_Set>
   146d6:	e6a4      	b.n	14422 <__gnu_unwind_execute+0xe>

000146d8 <__gnu_unwind_frame>:
   146d8:	b510      	push	{r4, lr}
   146da:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
   146dc:	b084      	sub	sp, #16
   146de:	685a      	ldr	r2, [r3, #4]
   146e0:	2003      	movs	r0, #3
   146e2:	f88d 000c 	strb.w	r0, [sp, #12]
   146e6:	79dc      	ldrb	r4, [r3, #7]
   146e8:	f88d 400d 	strb.w	r4, [sp, #13]
   146ec:	0212      	lsls	r2, r2, #8
   146ee:	3308      	adds	r3, #8
   146f0:	4608      	mov	r0, r1
   146f2:	a901      	add	r1, sp, #4
   146f4:	9201      	str	r2, [sp, #4]
   146f6:	9302      	str	r3, [sp, #8]
   146f8:	f7ff fe8c 	bl	14414 <__gnu_unwind_execute>
   146fc:	b004      	add	sp, #16
   146fe:	bd10      	pop	{r4, pc}

00014700 <_Unwind_GetRegionStart>:
   14700:	b508      	push	{r3, lr}
   14702:	f7ff fe85 	bl	14410 <unwind_UCB_from_context>
   14706:	6c80      	ldr	r0, [r0, #72]	; 0x48
   14708:	bd08      	pop	{r3, pc}
   1470a:	bf00      	nop

0001470c <_Unwind_GetLanguageSpecificData>:
   1470c:	b508      	push	{r3, lr}
   1470e:	f7ff fe7f 	bl	14410 <unwind_UCB_from_context>
   14712:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
   14714:	79c3      	ldrb	r3, [r0, #7]
   14716:	eb00 0083 	add.w	r0, r0, r3, lsl #2
   1471a:	3008      	adds	r0, #8
   1471c:	bd08      	pop	{r3, pc}
   1471e:	bf00      	nop

00014720 <_Unwind_GetDataRelBase>:
   14720:	b508      	push	{r3, lr}
   14722:	f000 f807 	bl	14734 <abort>
   14726:	bf00      	nop

00014728 <_Unwind_GetTextRelBase>:
   14728:	b508      	push	{r3, lr}
   1472a:	f7ff fff9 	bl	14720 <_Unwind_GetDataRelBase>
   1472e:	bf00      	nop

00014730 <__aeabi_idiv0>:
   14730:	4770      	bx	lr
   14732:	bf00      	nop

00014734 <abort>:
   14734:	b508      	push	{r3, lr}
   14736:	2006      	movs	r0, #6
   14738:	f000 f85c 	bl	147f4 <raise>
   1473c:	2001      	movs	r0, #1
   1473e:	f7fd fc75 	bl	1202c <_exit>
   14742:	Address 0x0000000000014742 is out of bounds.


00014744 <__libc_init_array>:
   14744:	b570      	push	{r4, r5, r6, lr}
   14746:	4e0d      	ldr	r6, [pc, #52]	; (1477c <__libc_init_array+0x38>)
   14748:	4c0d      	ldr	r4, [pc, #52]	; (14780 <__libc_init_array+0x3c>)
   1474a:	1ba4      	subs	r4, r4, r6
   1474c:	10a4      	asrs	r4, r4, #2
   1474e:	2500      	movs	r5, #0
   14750:	42a5      	cmp	r5, r4
   14752:	d109      	bne.n	14768 <__libc_init_array+0x24>
   14754:	4e0b      	ldr	r6, [pc, #44]	; (14784 <__libc_init_array+0x40>)
   14756:	4c0c      	ldr	r4, [pc, #48]	; (14788 <__libc_init_array+0x44>)
   14758:	f7fb fdd2 	bl	10300 <_init>
   1475c:	1ba4      	subs	r4, r4, r6
   1475e:	10a4      	asrs	r4, r4, #2
   14760:	2500      	movs	r5, #0
   14762:	42a5      	cmp	r5, r4
   14764:	d105      	bne.n	14772 <__libc_init_array+0x2e>
   14766:	bd70      	pop	{r4, r5, r6, pc}
   14768:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
   1476c:	4798      	blx	r3
   1476e:	3501      	adds	r5, #1
   14770:	e7ee      	b.n	14750 <__libc_init_array+0xc>
   14772:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
   14776:	4798      	blx	r3
   14778:	3501      	adds	r5, #1
   1477a:	e7f2      	b.n	14762 <__libc_init_array+0x1e>
   1477c:	0001030c 	.word	0x0001030c
   14780:	0001030c 	.word	0x0001030c
   14784:	0001030c 	.word	0x0001030c
   14788:	00010314 	.word	0x00010314

0001478c <memcpy>:
   1478c:	b510      	push	{r4, lr}
   1478e:	1e43      	subs	r3, r0, #1
   14790:	440a      	add	r2, r1
   14792:	4291      	cmp	r1, r2
   14794:	d100      	bne.n	14798 <memcpy+0xc>
   14796:	bd10      	pop	{r4, pc}
   14798:	f811 4b01 	ldrb.w	r4, [r1], #1
   1479c:	f803 4f01 	strb.w	r4, [r3, #1]!
   147a0:	e7f7      	b.n	14792 <memcpy+0x6>

000147a2 <_raise_r>:
   147a2:	291f      	cmp	r1, #31
   147a4:	b538      	push	{r3, r4, r5, lr}
   147a6:	4604      	mov	r4, r0
   147a8:	460d      	mov	r5, r1
   147aa:	d904      	bls.n	147b6 <_raise_r+0x14>
   147ac:	2316      	movs	r3, #22
   147ae:	6003      	str	r3, [r0, #0]
   147b0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   147b4:	bd38      	pop	{r3, r4, r5, pc}
   147b6:	6c42      	ldr	r2, [r0, #68]	; 0x44
   147b8:	b112      	cbz	r2, 147c0 <_raise_r+0x1e>
   147ba:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
   147be:	b94b      	cbnz	r3, 147d4 <_raise_r+0x32>
   147c0:	4620      	mov	r0, r4
   147c2:	f000 f831 	bl	14828 <_getpid_r>
   147c6:	462a      	mov	r2, r5
   147c8:	4601      	mov	r1, r0
   147ca:	4620      	mov	r0, r4
   147cc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   147d0:	f000 b818 	b.w	14804 <_kill_r>
   147d4:	2b01      	cmp	r3, #1
   147d6:	d00a      	beq.n	147ee <_raise_r+0x4c>
   147d8:	1c59      	adds	r1, r3, #1
   147da:	d103      	bne.n	147e4 <_raise_r+0x42>
   147dc:	2316      	movs	r3, #22
   147de:	6003      	str	r3, [r0, #0]
   147e0:	2001      	movs	r0, #1
   147e2:	e7e7      	b.n	147b4 <_raise_r+0x12>
   147e4:	2400      	movs	r4, #0
   147e6:	f842 4025 	str.w	r4, [r2, r5, lsl #2]
   147ea:	4628      	mov	r0, r5
   147ec:	4798      	blx	r3
   147ee:	2000      	movs	r0, #0
   147f0:	e7e0      	b.n	147b4 <_raise_r+0x12>
   147f2:	Address 0x00000000000147f2 is out of bounds.


000147f4 <raise>:
   147f4:	4b02      	ldr	r3, [pc, #8]	; (14800 <raise+0xc>)
   147f6:	4601      	mov	r1, r0
   147f8:	6818      	ldr	r0, [r3, #0]
   147fa:	f7ff bfd2 	b.w	147a2 <_raise_r>
   147fe:	bf00      	nop
   14800:	1000018c 	.word	0x1000018c

00014804 <_kill_r>:
   14804:	b538      	push	{r3, r4, r5, lr}
   14806:	4c07      	ldr	r4, [pc, #28]	; (14824 <_kill_r+0x20>)
   14808:	2300      	movs	r3, #0
   1480a:	4605      	mov	r5, r0
   1480c:	4608      	mov	r0, r1
   1480e:	4611      	mov	r1, r2
   14810:	6023      	str	r3, [r4, #0]
   14812:	f7fd fc19 	bl	12048 <_kill>
   14816:	1c43      	adds	r3, r0, #1
   14818:	d102      	bne.n	14820 <_kill_r+0x1c>
   1481a:	6823      	ldr	r3, [r4, #0]
   1481c:	b103      	cbz	r3, 14820 <_kill_r+0x1c>
   1481e:	602b      	str	r3, [r5, #0]
   14820:	bd38      	pop	{r3, r4, r5, pc}
   14822:	bf00      	nop
   14824:	100003a4 	.word	0x100003a4

00014828 <_getpid_r>:
   14828:	f7fd bc06 	b.w	12038 <_getpid>
   1482c:	00000000 	.word	0x00000000
   14830:	746f6f62 	.word	0x746f6f62
   14834:	64616f6c 	.word	0x64616f6c
   14838:	00007265 	.word	0x00007265
   1483c:	6c707061 	.word	0x6c707061
   14840:	74616369 	.word	0x74616369
   14844:	006e6f69 	.word	0x006e6f69
   14848:	74736f68 	.word	0x74736f68
   1484c:	73657420 	.word	0x73657420
   14850:	00000074 	.word	0x00000074
   14854:	64252020 	.word	0x64252020
   14858:	78302029 	.word	0x78302029
   1485c:	58383025 	.word	0x58383025
   14860:	0000000a 	.word	0x0000000a
   14864:	25783020 	.word	0x25783020
   14868:	00583830 	.word	0x00583830
   1486c:	64252020 	.word	0x64252020
   14870:	78302029 	.word	0x78302029
   14874:	000a7025 	.word	0x000a7025
   14878:	6e75520a 	.word	0x6e75520a
   1487c:	6874203a 	.word	0x6874203a
   14880:	6f662065 	.word	0x6f662065
   14884:	776f6c6c 	.word	0x776f6c6c
   14888:	20676e69 	.word	0x20676e69
   1488c:	6d6d6f63 	.word	0x6d6d6f63
   14890:	20646e61 	.word	0x20646e61
   14894:	79206e69 	.word	0x79206e69
   14898:	2072756f 	.word	0x2072756f
   1489c:	6a6f7270 	.word	0x6a6f7270
   148a0:	20746365 	.word	0x20746365
   148a4:	65726964 	.word	0x65726964
   148a8:	726f7463 	.word	0x726f7463
   148ac:	00000079 	.word	0x00000079
   148b0:	20200a0a 	.word	0x20200a0a
   148b4:	3b315b1b 	.word	0x3b315b1b
   148b8:	006d3733 	.word	0x006d3733
   148bc:	656b616d 	.word	0x656b616d
   148c0:	61747320 	.word	0x61747320
   148c4:	72746b63 	.word	0x72746b63
   148c8:	2d656361 	.word	0x2d656361
   148cc:	54207325 	.word	0x54207325
   148d0:	45434152 	.word	0x45434152
   148d4:	00223d53 	.word	0x00223d53
   148d8:	25783020 	.word	0x25783020
   148dc:	00000070 	.word	0x00000070
   148e0:	1b0a0a22 	.word	0x1b0a0a22
   148e4:	006d305b 	.word	0x006d305b
   148e8:	73696854 	.word	0x73696854
   148ec:	6c697720 	.word	0x6c697720
   148f0:	6572206c 	.word	0x6572206c
   148f4:	74726f70 	.word	0x74726f70
   148f8:	65687420 	.word	0x65687420
   148fc:	6c696620 	.word	0x6c696620
   14900:	6e612065 	.word	0x6e612065
   14904:	696c2064 	.word	0x696c2064
   14908:	6e20656e 	.word	0x6e20656e
   1490c:	65626d75 	.word	0x65626d75
   14910:	68742072 	.word	0x68742072
   14914:	6c207461 	.word	0x6c207461
   14918:	74206465 	.word	0x74206465
   1491c:	6874206f 	.word	0x6874206f
   14920:	66207369 	.word	0x66207369
   14924:	74636e75 	.word	0x74636e75
   14928:	206e6f69 	.word	0x206e6f69
   1492c:	6e696562 	.word	0x6e696562
   14930:	61632067 	.word	0x61632067
   14934:	64656c6c 	.word	0x64656c6c
   14938:	0000002e 	.word	0x0000002e
   1493c:	33345b1b 	.word	0x33345b1b
   14940:	4157206d 	.word	0x4157206d
   14944:	4e494e52 	.word	0x4e494e52
   14948:	305b1b47 	.word	0x305b1b47
   1494c:	6d34393b 	.word	0x6d34393b
   14950:	3a73253a 	.word	0x3a73253a
   14954:	3b305b1b 	.word	0x3b305b1b
   14958:	256d3239 	.word	0x256d3239
   1495c:	5b1b3a73 	.word	0x5b1b3a73
   14960:	33393b30 	.word	0x33393b30
   14964:	3e64256d 	.word	0x3e64256d
   14968:	305b1b20 	.word	0x305b1b20
   1496c:	6d37333b 	.word	0x6d37333b
   14970:	74726f50 	.word	0x74726f50
   14974:	20642520 	.word	0x20642520
   14978:	6e6e6163 	.word	0x6e6e6163
   1497c:	6220746f 	.word	0x6220746f
   14980:	73752065 	.word	0x73752065
   14984:	66206465 	.word	0x66206465
   14988:	4520726f 	.word	0x4520726f
   1498c:	72657478 	.word	0x72657478
   14990:	206c616e 	.word	0x206c616e
   14994:	65746e49 	.word	0x65746e49
   14998:	70757272 	.word	0x70757272
   1499c:	202e7374 	.word	0x202e7374
   149a0:	6465654e 	.word	0x6465654e
   149a4:	206f7420 	.word	0x206f7420
   149a8:	20657375 	.word	0x20657375
   149ac:	4f495047 	.word	0x4f495047
   149b0:	206e6f20 	.word	0x206e6f20
   149b4:	74726f50 	.word	0x74726f50
   149b8:	6f203020 	.word	0x6f203020
   149bc:	2e322072 	.word	0x2e322072
   149c0:	6d305b1b 	.word	0x6d305b1b
   149c4:	6d305b1b 	.word	0x6d305b1b
   149c8:	0000000a 	.word	0x0000000a
   149cc:	33345b1b 	.word	0x33345b1b
   149d0:	4157206d 	.word	0x4157206d
   149d4:	4e494e52 	.word	0x4e494e52
   149d8:	305b1b47 	.word	0x305b1b47
   149dc:	6d34393b 	.word	0x6d34393b
   149e0:	3a73253a 	.word	0x3a73253a
   149e4:	3b305b1b 	.word	0x3b305b1b
   149e8:	256d3239 	.word	0x256d3239
   149ec:	5b1b3a73 	.word	0x5b1b3a73
   149f0:	33393b30 	.word	0x33393b30
   149f4:	3e64256d 	.word	0x3e64256d
   149f8:	305b1b20 	.word	0x305b1b20
   149fc:	6d37333b 	.word	0x6d37333b
   14a00:	65676445 	.word	0x65676445
   14a04:	20642520 	.word	0x20642520
   14a08:	6e6e6163 	.word	0x6e6e6163
   14a0c:	6220746f 	.word	0x6220746f
   14a10:	73752065 	.word	0x73752065
   14a14:	66206465 	.word	0x66206465
   14a18:	4520726f 	.word	0x4520726f
   14a1c:	72657478 	.word	0x72657478
   14a20:	206c616e 	.word	0x206c616e
   14a24:	65746e49 	.word	0x65746e49
   14a28:	70757272 	.word	0x70757272
   14a2c:	4e2e7374 	.word	0x4e2e7374
   14a30:	20646565 	.word	0x20646565
   14a34:	75206f74 	.word	0x75206f74
   14a38:	61206573 	.word	0x61206573
   14a3c:	73697220 	.word	0x73697220
   14a40:	2c676e69 	.word	0x2c676e69
   14a44:	6c616620 	.word	0x6c616620
   14a48:	676e696c 	.word	0x676e696c
   14a4c:	726f202c 	.word	0x726f202c
   14a50:	746f6220 	.word	0x746f6220
   14a54:	6f632068 	.word	0x6f632068
   14a58:	6769666e 	.word	0x6769666e
   14a5c:	74617275 	.word	0x74617275
   14a60:	2e6e6f69 	.word	0x2e6e6f69
   14a64:	6d305b1b 	.word	0x6d305b1b
   14a68:	0000000a 	.word	0x0000000a
   14a6c:	44202020 	.word	0x44202020
   14a70:	47554245 	.word	0x47554245
   14a74:	3b305b1b 	.word	0x3b305b1b
   14a78:	3a6d3439 	.word	0x3a6d3439
   14a7c:	1b3a7325 	.word	0x1b3a7325
   14a80:	393b305b 	.word	0x393b305b
   14a84:	73256d32 	.word	0x73256d32
   14a88:	305b1b3a 	.word	0x305b1b3a
   14a8c:	6d33393b 	.word	0x6d33393b
   14a90:	203e6425 	.word	0x203e6425
   14a94:	3b305b1b 	.word	0x3b305b1b
   14a98:	736d3733 	.word	0x736d3733
   14a9c:	20646e65 	.word	0x20646e65
   14aa0:	7830203d 	.word	0x7830203d
   14aa4:	5b1b5825 	.word	0x5b1b5825
   14aa8:	000a6d30 	.word	0x000a6d30
   14aac:	31345b1b 	.word	0x31345b1b
   14ab0:	4952436d 	.word	0x4952436d
   14ab4:	41434954 	.word	0x41434954
   14ab8:	305b1b4c 	.word	0x305b1b4c
   14abc:	6d34393b 	.word	0x6d34393b
   14ac0:	3a73253a 	.word	0x3a73253a
   14ac4:	3b305b1b 	.word	0x3b305b1b
   14ac8:	256d3239 	.word	0x256d3239
   14acc:	5b1b3a73 	.word	0x5b1b3a73
   14ad0:	33393b30 	.word	0x33393b30
   14ad4:	3e64256d 	.word	0x3e64256d
   14ad8:	305b1b20 	.word	0x305b1b20
   14adc:	6d37333b 	.word	0x6d37333b
   14ae0:	65737341 	.word	0x65737341
   14ae4:	6f697472 	.word	0x6f697472
   14ae8:	6146206e 	.word	0x6146206e
   14aec:	72756c69 	.word	0x72756c69
   14af0:	43202c65 	.word	0x43202c65
   14af4:	69646e6f 	.word	0x69646e6f
   14af8:	6e6f6974 	.word	0x6e6f6974
   14afc:	73655420 	.word	0x73655420
   14b00:	3a646574 	.word	0x3a646574
   14b04:	656c2820 	.word	0x656c2820
   14b08:	756e5f64 	.word	0x756e5f64
   14b0c:	7265626d 	.word	0x7265626d
   14b10:	34203c20 	.word	0x34203c20
   14b14:	20200a29 	.word	0x20200a29
   14b18:	20202020 	.word	0x20202020
   14b1c:	20202020 	.word	0x20202020
   14b20:	75706e49 	.word	0x75706e49
   14b24:	654c2074 	.word	0x654c2074
   14b28:	756e2064 	.word	0x756e2064
   14b2c:	7265626d 	.word	0x7265626d
   14b30:	6e616320 	.word	0x6e616320
   14b34:	62207427 	.word	0x62207427
   14b38:	72672065 	.word	0x72672065
   14b3c:	65746165 	.word	0x65746165
   14b40:	68742072 	.word	0x68742072
   14b44:	33206e61 	.word	0x33206e61
   14b48:	6e69202c 	.word	0x6e69202c
   14b4c:	20747570 	.word	0x20747570
   14b50:	6425203d 	.word	0x6425203d
   14b54:	5b1b0a2e 	.word	0x5b1b0a2e
   14b58:	5b1b6d30 	.word	0x5b1b6d30
   14b5c:	000a6d30 	.word	0x000a6d30
   14b60:	6972500a 	.word	0x6972500a
   14b64:	6e69746e 	.word	0x6e69746e
   14b68:	74532067 	.word	0x74532067
   14b6c:	206b6361 	.word	0x206b6361
   14b70:	63617254 	.word	0x63617254
   14b74:	000a3a65 	.word	0x000a3a65
   14b78:	32345b1b 	.word	0x32345b1b
   14b7c:	2020206d 	.word	0x2020206d
   14b80:	464e4920 	.word	0x464e4920
   14b84:	305b1b4f 	.word	0x305b1b4f
   14b88:	6d34393b 	.word	0x6d34393b
   14b8c:	3a73253a 	.word	0x3a73253a
   14b90:	3b305b1b 	.word	0x3b305b1b
   14b94:	256d3239 	.word	0x256d3239
   14b98:	5b1b3a73 	.word	0x5b1b3a73
   14b9c:	33393b30 	.word	0x33393b30
   14ba0:	3e64256d 	.word	0x3e64256d
   14ba4:	305b1b20 	.word	0x305b1b20
   14ba8:	6d37333b 	.word	0x6d37333b
   14bac:	72617453 	.word	0x72617453
   14bb0:	20676e69 	.word	0x20676e69
   14bb4:	6c6c6548 	.word	0x6c6c6548
   14bb8:	6f57206f 	.word	0x6f57206f
   14bbc:	20646c72 	.word	0x20646c72
   14bc0:	6c707041 	.word	0x6c707041
   14bc4:	74616369 	.word	0x74616369
   14bc8:	1b6e6f69 	.word	0x1b6e6f69
   14bcc:	0a6d305b 	.word	0x0a6d305b
   14bd0:	00000000 	.word	0x00000000
   14bd4:	32345b1b 	.word	0x32345b1b
   14bd8:	2020206d 	.word	0x2020206d
   14bdc:	464e4920 	.word	0x464e4920
   14be0:	305b1b4f 	.word	0x305b1b4f
   14be4:	6d34393b 	.word	0x6d34393b
   14be8:	3a73253a 	.word	0x3a73253a
   14bec:	3b305b1b 	.word	0x3b305b1b
   14bf0:	256d3239 	.word	0x256d3239
   14bf4:	5b1b3a73 	.word	0x5b1b3a73
   14bf8:	33393b30 	.word	0x33393b30
   14bfc:	3e64256d 	.word	0x3e64256d
   14c00:	305b1b20 	.word	0x305b1b20
   14c04:	6d37333b 	.word	0x6d37333b
   14c08:	74696e49 	.word	0x74696e49
   14c0c:	696c6169 	.word	0x696c6169
   14c10:	676e697a 	.word	0x676e697a
   14c14:	44454c20 	.word	0x44454c20
   14c18:	2e2e2e73 	.word	0x2e2e2e73
   14c1c:	6d305b1b 	.word	0x6d305b1b
   14c20:	0000000a 	.word	0x0000000a
   14c24:	32345b1b 	.word	0x32345b1b
   14c28:	2020206d 	.word	0x2020206d
   14c2c:	464e4920 	.word	0x464e4920
   14c30:	305b1b4f 	.word	0x305b1b4f
   14c34:	6d34393b 	.word	0x6d34393b
   14c38:	3a73253a 	.word	0x3a73253a
   14c3c:	3b305b1b 	.word	0x3b305b1b
   14c40:	256d3239 	.word	0x256d3239
   14c44:	5b1b3a73 	.word	0x5b1b3a73
   14c48:	33393b30 	.word	0x33393b30
   14c4c:	3e64256d 	.word	0x3e64256d
   14c50:	305b1b20 	.word	0x305b1b20
   14c54:	6d37333b 	.word	0x6d37333b
   14c58:	7344454c 	.word	0x7344454c
   14c5c:	696e4920 	.word	0x696e4920
   14c60:	6c616974 	.word	0x6c616974
   14c64:	64657a69 	.word	0x64657a69
   14c68:	305b1b21 	.word	0x305b1b21
   14c6c:	00000a6d 	.word	0x00000a6d
   14c70:	32345b1b 	.word	0x32345b1b
   14c74:	2020206d 	.word	0x2020206d
   14c78:	464e4920 	.word	0x464e4920
   14c7c:	305b1b4f 	.word	0x305b1b4f
   14c80:	6d34393b 	.word	0x6d34393b
   14c84:	3a73253a 	.word	0x3a73253a
   14c88:	3b305b1b 	.word	0x3b305b1b
   14c8c:	256d3239 	.word	0x256d3239
   14c90:	5b1b3a73 	.word	0x5b1b3a73
   14c94:	33393b30 	.word	0x33393b30
   14c98:	3e64256d 	.word	0x3e64256d
   14c9c:	305b1b20 	.word	0x305b1b20
   14ca0:	6d37333b 	.word	0x6d37333b
   14ca4:	6c6c6548 	.word	0x6c6c6548
   14ca8:	6f57206f 	.word	0x6f57206f
   14cac:	20646c72 	.word	0x20646c72
   14cb0:	58257830 	.word	0x58257830
   14cb4:	6d305b1b 	.word	0x6d305b1b
   14cb8:	ffff000a 	.word	0xffff000a

00014cbc <sjsu::lpc40xx::Gpio::ValidPortCheck() const::file>:
   14cbc:	6f697067 7070682e ffffff00              gpio.hpp....

00014cc8 <sjsu::lpc40xx::Gpio::SetInterruptEdge(sjsu::Gpio::Edge) const::file>:
   14cc8:	6f697067 7070682e ffffff00              gpio.hpp....

00014cd4 <sjsu::OnBoardLed::On(unsigned char)::file>:
   14cd4:	6f626e6f 5f647261 2e64656c 00707068     onboard_led.hpp.

00014ce4 <sjsu::OnBoardLed::Off(unsigned char)::file>:
   14ce4:	6f626e6f 5f647261 2e64656c 00707068     onboard_led.hpp.

00014cf4 <sjsu::OnBoardLed::Set(unsigned char, sjsu::OnBoardLed::LightState)::file>:
   14cf4:	6f626e6f 5f647261 2e64656c 00707068     onboard_led.hpp.

00014d04 <main::file>:
   14d04:	6e69616d 7070632e ffffff00              main.cpp....

00014d10 <main::file>:
   14d10:	6e69616d 7070632e ffffff00              main.cpp....

00014d1c <main::file>:
   14d1c:	6e69616d 7070632e ffffff00              main.cpp....

00014d28 <main::file>:
   14d28:	6e69616d 7070632e ffffff00              main.cpp....

00014d34 <vtable for sjsu::lpc40xx::Gpio>:
	...
   14d3c:	000108c9 00010971 00010999 000109dd     ....q...........
   14d4c:	000109f5 00010a3d 00010ba1 00010bcf     ....=...........

00014d5c <vtable for sjsu::lpc40xx::Pin>:
	...
   14d64:	00010379 000103f5 00010501 0001047d     y...........}...

00014d74 <main::__PRETTY_FUNCTION__>:
   14d74:	20746e69 6e69616d ff002928              int main()..

00014d80 <sjsu::lpc40xx::Gpio::ValidPortCheck() const::__PRETTY_FUNCTION__>:
   14d80:	6c6f6f62 736a7320 6c3a3a75 30346370     bool sjsu::lpc40
   14d90:	3a3a7878 6f697047 61563a3a 5064696c     xx::Gpio::ValidP
   14da0:	4374726f 6b636568 63202928 74736e6f     ortCheck() const
   14db0:	ffffff00                                ....

00014db4 <sjsu::lpc40xx::Gpio::SetInterruptEdge(sjsu::Gpio::Edge) const::__PRETTY_FUNCTION__>:
   14db4:	64696f76 736a7320 6c3a3a75 30346370     void sjsu::lpc40
   14dc4:	3a3a7878 6f697047 65533a3a 746e4974     xx::Gpio::SetInt
   14dd4:	75727265 64457470 73286567 3a75736a     erruptEdge(sjsu:
   14de4:	6970473a 453a3a6f 29656764 6e6f6320     :Gpio::Edge) con
   14df4:	ff007473                                st..

00014df8 <sjsu::OnBoardLed::Set(unsigned char, sjsu::OnBoardLed::LightState)::__PRETTY_FUNCTION__>:
   14df8:	64696f76 736a7320 4f3a3a75 616f426e     void sjsu::OnBoa
   14e08:	654c6472 533a3a64 75287465 38746e69     rdLed::Set(uint8
   14e18:	202c745f 75736a73 6e4f3a3a 72616f42     _t, sjsu::OnBoar
   14e28:	64654c64 694c3a3a 53746867 65746174     dLed::LightState
   14e38:	ffff0029                                )...

00014e3c <sjsu::OnBoardLed::On(unsigned char)::__PRETTY_FUNCTION__>:
   14e3c:	64696f76 736a7320 4f3a3a75 616f426e     void sjsu::OnBoa
   14e4c:	654c6472 4f3a3a64 6975286e 5f38746e     rdLed::On(uint8_
   14e5c:	ff002974                                t)..

00014e60 <sjsu::OnBoardLed::Off(unsigned char)::__PRETTY_FUNCTION__>:
   14e60:	64696f76 736a7320 4f3a3a75 616f426e     void sjsu::OnBoa
   14e70:	654c6472 4f3a3a64 75286666 38746e69     rdLed::Off(uint8
   14e80:	0029745f 00000000 746f6f62 64616f6c     _t).....bootload
   14e90:	00007265 6c707061 74616369 006e6f69     er..application.
   14ea0:	74736f68 73657420 00000074 64252020     host test...  %d
   14eb0:	78302029 58383025 0000000a 25783020     ) 0x%08X.... 0x%
   14ec0:	00583830 64252020 78302029 000a7025     08X.  %d) 0x%p..
   14ed0:	6e75520a 6874203a 6f662065 776f6c6c     .Run: the follow
   14ee0:	20676e69 6d6d6f63 20646e61 79206e69     ing command in y
   14ef0:	2072756f 6a6f7270 20746365 65726964     our project dire
   14f00:	726f7463 00000079 20200a0a 3b315b1b     ctory.....  .[1;
   14f10:	006d3733 656b616d 61747320 72746b63     37m.make stacktr
   14f20:	2d656361 54207325 45434152 00223d53     ace-%s TRACES=".
   14f30:	25783020 00000070 1b0a0a22 006d305b      0x%p..."...[0m.
   14f40:	73696854 6c697720 6572206c 74726f70     This will report
   14f50:	65687420 6c696620 6e612065 696c2064      the file and li
   14f60:	6e20656e 65626d75 68742072 6c207461     ne number that l
   14f70:	74206465 6874206f 66207369 74636e75     ed to this funct
   14f80:	206e6f69 6e696562 61632067 64656c6c     ion being called
   14f90:	0000002e 31345b1b 4952436d 41434954     .....[41mCRITICA
   14fa0:	305b1b4c 6d34393b 3a73253a 3b305b1b     L.[0;94m:%s:.[0;
   14fb0:	256d3239 5b1b3a73 33393b30 3e64256d     92m%s:.[0;93m%d>
   14fc0:	305b1b20 6d37333b 65737341 6f697472      .[0;37mAssertio
   14fd0:	6146206e 72756c69 43202c65 69646e6f     n Failure, Condi
   14fe0:	6e6f6974 73655420 3a646574 65702820     tion Tested: (pe
   14ff0:	68706972 6c617265 7669645f 72656469     ripheral_divider
   15000:	203d3c20 200a2934 20202020 20202020      <= 4).         
   15010:	76694420 72656469 73756d20 74276e74      Divider mustn't
   15020:	63786520 20646565 5b1b3233 5b1b6d30      exceed 32.[0m.[
   15030:	000a6d30 6972500a 6e69746e 74532067     0m...Printing St
   15040:	206b6361 63617254 000a3a65 31345b1b     ack Trace:...[41
   15050:	4952436d 41434954 305b1b4c 6d34393b     mCRITICAL.[0;94m
   15060:	3a73253a 3b305b1b 256d3239 5b1b3a73     :%s:.[0;92m%s:.[
   15070:	33393b30 3e64256d 305b1b20 6d37333b     0;93m%d> .[0;37m
   15080:	65737341 6f697472 6146206e 72756c69     Assertion Failur
   15090:	43202c65 69646e6f 6e6f6974 73655420     e, Condition Tes
   150a0:	3a646574 65642820 65726973 70735f64     ted: (desired_sp
   150b0:	5f646565 6d5f6e69 3c207a68 34383320     eed_in_mhz < 384
   150c0:	20262620 69736564 5f646572 65657073      && desired_spee
   150d0:	6e695f64 7a686d5f 31203e20 200a2932     d_in_mhz > 12). 
   150e0:	20202020 20202020 65724620 6e657571              Frequen
   150f0:	6d207963 20747375 6c206562 7265776f     cy must be lower
   15100:	61687420 3833206e 484d2034 646e617a      than 384 MHzand
   15110:	65726720 72657461 61687420 726f206e      greater than or
   15120:	75716520 74206c61 3231206f 7a484d20      equal to 12 MHz
   15130:	6d305b1b 6d305b1b 0000000a 31345b1b     .[0m.[0m.....[41
   15140:	4952436d 41434954 305b1b4c 6d34393b     mCRITICAL.[0;94m
   15150:	3a73253a 3b305b1b 256d3239 5b1b3a73     :%s:.[0;92m%s:.[
   15160:	33393b30 3e64256d 305b1b20 6d37333b     0;93m%d> .[0;37m
   15170:	65737341 6f697472 6146206e 72756c69     Assertion Failur
   15180:	43202c65 69646e6f 6e6f6974 73655420     e, Condition Tes
   15190:	3a646574 69642820 65646976 61765f72     ted: (divider_va
   151a0:	2065756c 2938203c 2020200a 20202020     lue < 8).       
   151b0:	50202020 64204c4c 64697669 76207265        PLL divider v
   151c0:	65756c61 6e657720 756f2074 666f2074     alue went out of
   151d0:	756f6220 1b73646e 1b6d305b 0a6d305b      bounds.[0m.[0m.
   151e0:	00000000 31345b1b 4952436d 41434954     .....[41mCRITICA
   151f0:	305b1b4c 6d34393b 3a73253a 3b305b1b     L.[0;94m:%s:.[0;
   15200:	256d3239 5b1b3a73 33393b30 3e64256d     92m%s:.[0;93m%d>
   15210:	305b1b20 6d37333b 65737341 6f697472      .[0;37mAssertio
   15220:	6146206e 72756c69 43202c65 69646e6f     n Failure, Condi
   15230:	6e6f6974 73655420 3a646574 61662820     tion Tested: (fa
   15240:	2965736c 2020200a 20202020 50202020     lse).          P
   15250:	6c204c4c 206b636f 6c756f63 6f6e2064     LL lock could no
   15260:	65622074 74736520 696c6261 64656873     t be established
   15270:	66656220 2065726f 656d6974 1b74756f      before timeout.
   15280:	1b6d305b 0a6d305b 00000000 31345b1b     [0m.[0m......[41
   15290:	4952436d 41434954 305b1b4c 6d34393b     mCRITICAL.[0;94m
   152a0:	3a73253a 3b305b1b 256d3239 5b1b3a73     :%s:.[0;92m%s:.[
   152b0:	33393b30 3e64256d 305b1b20 6d37333b     0;93m%d> .[0;37m
   152c0:	65737341 6f697472 6146206e 72756c69     Assertion Failur
   152d0:	43202c65 69646e6f 6e6f6974 73655420     e, Condition Tes
   152e0:	3a646574 70632820 69645f75 65646976     ted: (cpu_divide
   152f0:	203c2072 0a293233 20202020 20202020     r < 32).        
   15300:	69442020 65646976 756d2072 276e7473       Divider mustn'
   15310:	78652074 64656563 1b323320 1b6d305b     t exceed 32.[0m.
   15320:	0a6d305b 00000000 31345b1b 4952436d     [0m......[41mCRI
   15330:	41434954 305b1b4c 6d34393b 3a73253a     TICAL.[0;94m:%s:
   15340:	3b305b1b 256d3239 5b1b3a73 33393b30     .[0;92m%s:.[0;93
   15350:	3e64256d 305b1b20 6d37333b 65737341     m%d> .[0;37mAsse
   15360:	6f697472 6146206e 72756c69 43202c65     rtion Failure, C
   15370:	69646e6f 6e6f6974 73655420 3a646574     ondition Tested:
   15380:	72662820 65757165 2079636e 30203d21      (frequency != 0
   15390:	20200a29 20202020 20202020 6e6e6143     ).          Cann
   153a0:	6820746f 20657661 6f72657a 63697420     ot have zero tic
   153b0:	7020736b 6d207265 6f726369 6f636573     ks per microseco
   153c0:	202c646e 61656c70 63206573 736f6f68     nd, please choos
   153d0:	20312065 6d20726f 2e65726f 6d305b1b     e 1 or more..[0m
   153e0:	6d305b1b 0000000a 31345b1b 4952436d     .[0m.....[41mCRI
   153f0:	41434954 305b1b4c 6d34393b 3a73253a     TICAL.[0;94m:%s:
   15400:	3b305b1b 256d3239 5b1b3a73 33393b30     .[0;92m%s:.[0;93
   15410:	3e64256d 305b1b20 6d37333b 65737341     m%d> .[0;37mAsse
   15420:	6f697472 6146206e 72756c69 43202c65     rtion Failure, C
   15430:	69646e6f 6e6f6974 73655420 3a646574     ondition Tested:
   15440:	616d2820 5f686374 69676572 72657473      (match_register
   15450:	33203e20 20200a29 20202020 20202020      > 3).          
   15460:	20656854 3443504c 20787830 206e6163     The LPC40xx can 
   15470:	796c6e6f 73616820 6d203320 68637461     only has 3 match
   15480:	67657220 65747369 202e7372 61206e41      registers. An a
   15490:	6d657474 74207470 6573206f 616d2074     ttempt to set ma
   154a0:	20686374 69676572 72657473 20642520     tch register %d 
   154b0:	20736177 65747461 6574706d 5b1b2e64     was attempted..[
   154c0:	5b1b6d30 000a6d30 31345b1b 4952436d     0m.[0m...[41mCRI
   154d0:	41434954 305b1b4c 6d34393b 3a73253a     TICAL.[0;94m:%s:
   154e0:	3b305b1b 256d3239 5b1b3a73 33393b30     .[0;92m%s:.[0;93
   154f0:	3e64256d 305b1b20 6d37333b 65737341     m%d> .[0;37mAsse
   15500:	6f697472 6146206e 72756c69 43202c65     rtion Failure, C
   15510:	69646e6f 6e6f6974 73655420 3a646574     ondition Tested:
   15520:	69742820 5f72656d 72617473 74735f74      (timer_start_st
   15530:	73757461 203d3d20 75736a73 74533a3a     atus == sjsu::St
   15540:	73757461 536b3a3a 65636375 0a297373     atus::kSuccess).
   15550:	20202020 20202020 79532020 6d657473               System
   15560:	6d695420 28207265 64657375 20796220      Timer (used by 
   15570:	65657246 534f5452 61682029 41462073     FreeRTOS) has FA
   15580:	44454c49 206f7420 72617473 5b1b2174     ILED to start!.[
   15590:	5b1b6d30 000a6d30                       0m.[0m..

00015598 <sjsu::lpc40xx::SystemController::SetPeripheralClockDivider(unsigned char) const::file>:
   15598:	74737973 635f6d65 72746e6f 656c6c6f     system_controlle
   155a8:	70682e72 ffff0070                       r.hpp...

000155b0 <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const::file>:
   155b0:	74737973 635f6d65 72746e6f 656c6c6f     system_controlle
   155c0:	70682e72 ffff0070                       r.hpp...

000155c8 <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const::file>:
   155c8:	74737973 635f6d65 72746e6f 656c6c6f     system_controlle
   155d8:	70682e72 ffff0070                       r.hpp...

000155e0 <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const::file>:
   155e0:	74737973 635f6d65 72746e6f 656c6c6f     system_controlle
   155f0:	70682e72 ffff0070                       r.hpp...

000155f8 <sjsu::lpc40xx::SystemController::SetCpuClockDivider(unsigned char) const::file>:
   155f8:	74737973 635f6d65 72746e6f 656c6c6f     system_controlle
   15608:	70682e72 ffff0070                       r.hpp...

00015610 <sjsu::lpc40xx::Timer::Channel::kTimerPartial0>:
   15610:	40004000 00000001 00000001 10000318     .@.@............

00015620 <sjsu::lpc40xx::Timer::Channel::kTimer0>:
   15620:	00015610 00011de1                       .V......

00015628 <sjsu::lpc40xx::Timer::Initialize(unsigned long, void (*)(), long) const::file>:
   15628:	656d6974 70682e72 ffff0070              timer.hpp...

00015634 <sjsu::lpc40xx::Timer::SetTimer(unsigned long, sjsu::Timer::TimerIsrCondition, unsigned char) const::file>:
   15634:	656d6974 70682e72 ffff0070              timer.hpp...

00015640 <sjsu::lpc40xx::Uart::kBaudRateLUT>:
   15640:	00000271 00000000 00000001 000000d0     q...............
   15650:	00000001 00000002 00000068 00000001     ........h.......
   15660:	00000002 00000034 00000001 00000002     ....4...........
   15670:	00000023 00000001 00000002 0000001a     #...............
   15680:	00000000 00000001 0000000d 00000000     ................
   15690:	00000001 00000004 00000002 00000003     ................
   156a0:	00000002 00000002 00000003              ............

000156ac <sjsu::lpc40xx::Uart::Port::kUart0Tx>:
   156ac:	00014d64 00000200                       dM......

000156b4 <sjsu::lpc40xx::Uart::Port::kUart0Rx>:
   156b4:	00014d64 00000300                       dM......

000156bc <sjsu::lpc40xx::Uart::Port::kUart0>:
   156bc:	4000c000 00000003 000156ac 000156b4     ...@.....V...V..
   156cc:	00000009                                ....

000156d0 <vtable for sjsu::lpc40xx::Uart>:
	...
   156d8:	00011a85 00011921 00011b6d 00011c43     ....!...m...C...
   156e8:	fffffffc 00000000 000110d5 00011159     ............Y...
   156f8:	000111ad 000111cd 000111e9 0001121d     ................
   15708:	00011259 00011295                       Y.......

00015710 <vtable for sjsu::lpc40xx::Timer>:
	...
   15718:	00011765 0001184d 00011901 fffffffc     e...M...........
   15728:	00000000 000110d5 00011159 000111ad     ........Y.......
   15738:	000111cd 000111e9 0001121d 00011259     ............Y...
   15748:	00011295                                ....

0001574c <vtable for sjsu::Timer>:
	...
   15754:	0001345d 0001345d 0001345d              ]4..]4..]4..

00015760 <vtable for sjsu::lpc40xx::SystemController>:
	...
   15768:	000110d5 00011159 000111ad 000111cd     ....Y...........
   15778:	000111e9 0001121d 00011259 00011295     ........Y.......

00015788 <vtable for sjsu::SystemController>:
	...
   15790:	0001345d 0001345d 0001345d 0001345d     ]4..]4..]4..]4..
   157a0:	0001345d 0001345d 0001345d 0001345d     ]4..]4..]4..]4..

000157b0 <sjsu::lpc40xx::SystemController::SetPeripheralClockDivider(unsigned char) const::__PRETTY_FUNCTION__>:
   157b0:	74726976 206c6175 64696f76 736a7320     virtual void sjs
   157c0:	6c3a3a75 30346370 3a3a7878 74737953     u::lpc40xx::Syst
   157d0:	6f436d65 6f72746e 72656c6c 65533a3a     emController::Se
   157e0:	72655074 65687069 436c6172 6b636f6c     tPeripheralClock
   157f0:	69766944 28726564 746e6975 29745f38     Divider(uint8_t)
   15800:	6e6f6320 ff007473                        const..

00015808 <sjsu::lpc40xx::SystemController::SetMainPll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const::__PRETTY_FUNCTION__>:
   15808:	746e6975 745f3233 736a7320 6c3a3a75     uint32_t sjsu::l
   15818:	30346370 3a3a7878 74737953 6f436d65     pc40xx::SystemCo
   15828:	6f72746e 72656c6c 65533a3a 69614d74     ntroller::SetMai
   15838:	6c6c506e 736a7328 6c3a3a75 30346370     nPll(sjsu::lpc40
   15848:	3a3a7878 74737953 6f436d65 6f72746e     xx::SystemContro
   15858:	72656c6c 6c503a3a 706e496c 202c7475     ller::PllInput, 
   15868:	746e6975 745f3631 6f632029 0074736e     uint16_t) const.

00015878 <sjsu::lpc40xx::SystemController::CalculatePll(sjsu::lpc40xx::SystemController::PllInput, unsigned short) const::__PRETTY_FUNCTION__>:
   15878:	746e6975 745f3233 736a7320 6c3a3a75     uint32_t sjsu::l
   15888:	30346370 3a3a7878 74737953 6f436d65     pc40xx::SystemCo
   15898:	6f72746e 72656c6c 61433a3a 6c75636c     ntroller::Calcul
   158a8:	50657461 73286c6c 3a75736a 63706c3a     atePll(sjsu::lpc
   158b8:	78783034 79533a3a 6d657473 746e6f43     40xx::SystemCont
   158c8:	6c6c6f72 3a3a7265 496c6c50 7475706e     roller::PllInput
   158d8:	6975202c 3631746e 2029745f 736e6f63     , uint16_t) cons
   158e8:	ffff0074                                t...

000158ec <sjsu::lpc40xx::SystemController::SetCpuClockDivider(unsigned char) const::__PRETTY_FUNCTION__>:
   158ec:	64696f76 736a7320 6c3a3a75 30346370     void sjsu::lpc40
   158fc:	3a3a7878 74737953 6f436d65 6f72746e     xx::SystemContro
   1590c:	72656c6c 65533a3a 75704374 636f6c43     ller::SetCpuCloc
   1591c:	7669446b 72656469 6e697528 745f3874     kDivider(uint8_t
   1592c:	6f632029 0074736e                       ) const.

00015934 <sjsu::lpc40xx::Timer::Initialize(unsigned long, void (*)(), long) const::__PRETTY_FUNCTION__>:
   15934:	74726976 206c6175 75736a73 74533a3a     virtual sjsu::St
   15944:	73757461 736a7320 6c3a3a75 30346370     atus sjsu::lpc40
   15954:	3a3a7878 656d6954 493a3a72 6974696e     xx::Timer::Initi
   15964:	7a696c61 69752865 3233746e 202c745f     alize(uint32_t, 
   15974:	50727349 746e696f 202c7265 33746e69     IsrPointer, int3
   15984:	29745f32 6e6f6320 ff007473              2_t) const..

00015990 <sjsu::lpc40xx::Timer::SetTimer(unsigned long, sjsu::Timer::TimerIsrCondition, unsigned char) const::__PRETTY_FUNCTION__>:
   15990:	74726976 206c6175 64696f76 736a7320     virtual void sjs
   159a0:	6c3a3a75 30346370 3a3a7878 656d6954     u::lpc40xx::Time
   159b0:	533a3a72 69547465 2872656d 746e6975     r::SetTimer(uint
   159c0:	745f3233 6a73202c 3a3a7573 656d6954     32_t, sjsu::Time
   159d0:	543a3a72 72656d69 43727349 69646e6f     r::TimerIsrCondi
   159e0:	6e6f6974 6975202c 5f38746e 63202974     tion, uint8_t) c
   159f0:	74736e6f ffffff00 00000000 746f6f62     onst........boot
   15a00:	64616f6c 00007265 6c707061 74616369     loader..applicat
   15a10:	006e6f69 74736f68 73657420 00000074     ion.host test...
   15a20:	64252020 78302029 58383025 0000000a       %d) 0x%08X....
   15a30:	25783020 00583830 64252020 78302029      0x%08X.  %d) 0x
   15a40:	000a7025 6e75520a 6874203a 6f662065     %p...Run: the fo
   15a50:	776f6c6c 20676e69 6d6d6f63 20646e61     llowing command 
   15a60:	79206e69 2072756f 6a6f7270 20746365     in your project 
   15a70:	65726964 726f7463 00000079 20200a0a     directory.....  
   15a80:	3b315b1b 006d3733 656b616d 61747320     .[1;37m.make sta
   15a90:	72746b63 2d656361 54207325 45434152     cktrace-%s TRACE
   15aa0:	00223d53 25783020 00000070 1b0a0a22     S=". 0x%p..."...
   15ab0:	006d305b 73696854 6c697720 6572206c     [0m.This will re
   15ac0:	74726f70 65687420 6c696620 6e612065     port the file an
   15ad0:	696c2064 6e20656e 65626d75 68742072     d line number th
   15ae0:	6c207461 74206465 6874206f 66207369     at led to this f
   15af0:	74636e75 206e6f69 6e696562 61632067     unction being ca
   15b00:	64656c6c 0000002e 31345b1b 4952436d     lled.....[41mCRI
   15b10:	41434954 305b1b4c 6d34393b 3a73253a     TICAL.[0;94m:%s:
   15b20:	3b305b1b 256d3239 5b1b3a73 33393b30     .[0;92m%s:.[0;93
   15b30:	3e64256d 305b1b20 6d37333b 65737341     m%d> .[0;37mAsse
   15b40:	6f697472 6146206e 72756c69 43202c65     rtion Failure, C
   15b50:	69646e6f 6e6f6974 73655420 3a646574     ondition Tested:
   15b60:	73692820 3d212072 746e4920 75727265      (isr != Interru
   15b70:	6f4c7470 70756b6f 646e6148 2972656c     ptLookupHandler)
   15b80:	2020200a 20202020 4e202020 5349206f     .          No IS
   15b90:	6f662052 20646e75 20726f66 20656874     R found for the 
   15ba0:	74636576 2520726f 305b1b75 305b1b6d     vector %u.[0m.[0
   15bb0:	00000a6d 6972500a 6e69746e 74532067     m....Printing St
   15bc0:	206b6361 63617254 000a3a65 31345b1b     ack Trace:...[41
   15bd0:	7261486d 61462064 20746c75 65637845     mHard Fault Exce
   15be0:	6f697470 634f206e 72727563 0a216465     ption Occurred!.
   15bf0:	6d305b1b 00000000 203a3072 30257830     .[0m....r0: 0x%0
   15c00:	2c586c38 3a317220 25783020 586c3830     8lX, r1: 0x%08lX
   15c10:	3272202c 7830203a 6c383025 72202c58     , r2: 0x%08lX, r
   15c20:	30203a33 38302578 000a586c 3a323172     3: 0x%08lX..r12:
   15c30:	25783020 586c3830 726c202c 7830203a      0x%08lX, lr: 0x
   15c40:	6c383025 70202c58 30203a63 38302578     %08lX, pc: 0x%08
   15c50:	202c586c 3a727370 25783020 586c3830     lX, psr: 0x%08lX
   15c60:	ffff000a                                ....

00015c64 <InterruptLookupHandler::file>:
   15c64:	65746e69 70757272 70632e74 ffff0070     interrupt.cpp...

00015c74 <InterruptLookupHandler::__PRETTY_FUNCTION__>:
   15c74:	64696f76 746e4920 75727265 6f4c7470     void InterruptLo
   15c84:	70756b6f 646e6148 2872656c ffff0029     okupHandler()...

00015c94 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)::pow10>:
   15c94:	3f800000 41200000 42c80000 447a0000     ...?.. A...B..zD
   15ca4:	461c4000 47c35000 49742400 4b189680     .@.F.P.G.$tI...K
   15cb4:	4cbebc20 4e6e6b28                        ..L(knN

00015cbc <__sf_fake_stderr>:
	...

00015cdc <__sf_fake_stdin>:
	...

00015cfc <__sf_fake_stdout>:
	...
